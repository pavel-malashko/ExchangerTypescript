"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var util = require("../util");
var Mutator_1 = require("./Mutator");
var ClassDeclarationMutator = /** @class */ (function (_super) {
    __extends(ClassDeclarationMutator, _super);
    function ClassDeclarationMutator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.kind = ts.SyntaxKind.ClassDeclaration;
        _this.initializers = [];
        return _this;
    }
    ClassDeclarationMutator.prototype.mutate = function (node) {
        var members = [];
        var decorators = this.options.noAnnotate ?
            node.decorators : this.reflectClass(node);
        for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
            var member = _a[_i];
            switch (member.kind) {
                case ts.SyntaxKind.Constructor:
                case ts.SyntaxKind.MethodDeclaration:
                case ts.SyntaxKind.GetAccessor:
                case ts.SyntaxKind.SetAccessor:
                    members.push(this.mutateMethodDeclaration(member));
                    break;
                case ts.SyntaxKind.PropertyDeclaration:
                    members.push.apply(members, util.asArray(this.mutatePropertyDeclaration(member)));
                    break;
                case ts.SyntaxKind.IndexSignature:
                default:
                    members.push(member);
            }
        }
        this.addInitializers(node, members);
        this.declareTypeParameters(node, members);
        this.assertImplementing(node, members);
        this.setMerged(node);
        return ts.updateClassDeclaration(node, decorators, node.modifiers, node.name, node.typeParameters, node.heritageClauses, members);
    };
    ClassDeclarationMutator.prototype.setMerged = function (node) {
        var nodeSymbol = this.scanner.getNodeSymbol(node.name);
        this.context.setMerged(nodeSymbol);
    };
    ClassDeclarationMutator.prototype.reflectClass = function (node) {
        var classReflection = this.factory.classReflection(node);
        var decorators = util.arrayFromNodeArray(node.decorators);
        var decorator = ts.createDecorator(this.factory.annotate(classReflection));
        decorators.unshift(decorator);
        return decorators;
    };
    ClassDeclarationMutator.prototype.addInitializers = function (node, members) {
        if (this.initializers.length === 0) {
            return;
        }
        var constructor = this.getConstructor(members);
        var statements = util.arrayFromNodeArray(constructor.body.statements);
        for (var _i = 0, _a = this.initializers; _i < _a.length; _i++) {
            var initializer = _a[_i];
            statements = util.insertAfterSuper(statements, initializer);
        }
        this.updateConstructor(members, constructor, statements);
    };
    ClassDeclarationMutator.prototype.assertImplementing = function (node, members) {
        var implementsClause = util.getImplementsClause(node);
        if (!implementsClause) {
            return members;
        }
        var constructor = this.getConstructor(members);
        var statements = util.arrayFromNodeArray(constructor.body.statements);
        for (var _i = 0, _a = implementsClause.types || []; _i < _a.length; _i++) {
            var impl = _a[_i];
            var assertion = ts.createStatement(this.factory.typeAssertion(this.factory.expressionWithTypeArgumentsReflection(impl), ts.createThis()));
            statements.push(assertion);
        }
        this.updateConstructor(members, constructor, statements);
        return members;
    };
    ClassDeclarationMutator.prototype.declareTypeParameters = function (node, members) {
        var extendsClause = util.getExtendsClause(node);
        var hasTypeParameters = util.hasTypeParameters(node);
        var extendsClauseHasTypeArguments = util.extendsClauseHasTypeArguments(extendsClause);
        if (!hasTypeParameters && !extendsClauseHasTypeArguments) {
            return members;
        }
        var constructor = this.getConstructor(members);
        var statements = util.arrayFromNodeArray(constructor.body.statements);
        var typeParametersStatement;
        var thisStatement;
        var bindStatement;
        var insert = [];
        if (hasTypeParameters) {
            typeParametersStatement = this.factory.typeParametersLiteralDeclaration(util.arrayFromNodeArray(node.typeParameters));
            thisStatement = this.factory.classTypeParameterSymbolConstructorDeclaration(node.name);
            insert.push(typeParametersStatement);
        }
        if (extendsClauseHasTypeArguments) {
            bindStatement = this.factory.typeParameterBindingDeclaration(util.arrayFromNodeArray(extendsClause.types[0].typeArguments));
        }
        insert.push.apply(insert, [thisStatement, bindStatement].filter(function (statement) { return !!statement; }));
        util.insertAfterSuper(statements, insert);
        this.updateConstructor(members, constructor, statements);
        if (hasTypeParameters) {
            members.unshift(this.factory.classTypeParameterSymbolPropertyDeclaration(node.name));
        }
        return members;
    };
    ClassDeclarationMutator.prototype.mutatePropertyDeclaration = function (node) {
        if (!this.options.assertAny && this.context.isAny(node.type)) {
            return node;
        }
        if (ts.isComputedPropertyName(node.name)) {
            return node;
        }
        if (util.hasModifier(node, ts.SyntaxKind.AbstractKeyword)) {
            return node;
        }
        var isStatic = util.isStatic(node);
        var className = this.node.name.text;
        // Use decorators for static properties temporarily
        // if (util.isStatic(node)) {
        //   const decorators = util.asNewArray(node.decorators);
        //
        //   if (node.initializer) {
        //     const typeReflection = this.factory.typeReflection(node.type);
        //
        //     let decorator: ts.Decorator;
        //
        //     if (util.hasKind(typeReflection, ts.SyntaxKind.ThisKeyword)) {
        //       decorator = ts.createDecorator(this.factory.decorate(
        //         ts.createFunctionExpression(undefined, undefined, undefined, undefined, undefined, undefined,
        //           ts.createBlock([ts.createReturn(typeReflection)], true)
        //         )
        //       ));
        //     } else {
        //       decorator = ts.createDecorator(this.factory.decorate(typeReflection));
        //     }
        //
        //     decorators.unshift(decorator);
        //   }
        //
        //   return ts.updateProperty(node, decorators, node.modifiers, node.name, node.type, node.initializer);
        // }
        var name = node.name.text;
        if (!ts.isComputedPropertyName(node.name)) {
            name = this.context.getPropertyName(this.node, "_" + node.name.text);
        }
        var initializer = undefined;
        if (node.initializer) {
            initializer = this.factory.typeReflectionAndAssertion(node.type, node.initializer);
        }
        if (!isStatic && initializer) {
            this.initializers.push(ts.createStatement(ts.createBinary(ts.createPropertyAccess(isStatic ? ts.createIdentifier(className) : ts.createThis(), name), ts.SyntaxKind.FirstAssignment, initializer)));
        }
        var property = this.map(ts.updateProperty(node, node.decorators, node.modifiers, ts.createIdentifier(name), node.questionToken, node.type, isStatic ? initializer : undefined), node);
        var setAccessor;
        if (!util.hasModifier(node, ts.SyntaxKind.ReadonlyKeyword)) {
            setAccessor = this.factory.mutateFunctionBody(ts.createSetAccessor(undefined, node.modifiers, node.name, [
                ts.createParameter(undefined, undefined, undefined, node.name.text, undefined, node.type)
            ], ts.createBlock([ts.createStatement(ts.createBinary(ts.createPropertyAccess(isStatic ? ts.createIdentifier(className) : ts.createThis(), name), ts.SyntaxKind.FirstAssignment, node.name))], true)));
        }
        var getAccessor = ts.createGetAccessor(undefined, node.modifiers, node.name, undefined, node.type, ts.createBlock([ts.createReturn(ts.createPropertyAccess(isStatic ? ts.createIdentifier(className) : ts.createThis(), name))], true));
        node.name = ts.createIdentifier(name);
        return [property, getAccessor, setAccessor].filter(function (val) { return !!val; });
    };
    // TODO: assert parameters and return type is isImplementationOfOverload
    ClassDeclarationMutator.prototype.mutateMethodDeclaration = function (node) {
        return this.factory.mutateFunctionBody(node);
    };
    ClassDeclarationMutator.prototype.getConstructor = function (members, create) {
        if (create === void 0) { create = true; }
        var index = members.findIndex(function (member) { return member.kind === ts.SyntaxKind.Constructor; });
        var exists = index !== -1;
        if (exists) {
            return members[index];
        }
        if (!create) {
            return null;
        }
        var extendsClause = util.getExtendsClause(this.node);
        var isExtending = !!extendsClause;
        var constructor = ts.createConstructor(undefined, undefined, isExtending
            ? [ts.createParameter(undefined, undefined, ts.createToken(ts.SyntaxKind.DotDotDotToken), 'args')]
            : undefined, ts.createBlock(isExtending
            ? [ts.createStatement(ts.createCall(ts.createSuper(), undefined, [ts.createSpread(ts.createIdentifier('args'))]))] : [], true));
        return constructor;
    };
    ClassDeclarationMutator.prototype.updateConstructor = function (members, constructor, statements) {
        var index = members.findIndex(function (member) { return member.kind === ts.SyntaxKind.Constructor; });
        var exists = index !== -1;
        constructor = this.map(ts.updateConstructor(constructor, constructor.decorators, constructor.modifiers, constructor.parameters, this.map(ts.updateBlock(constructor.body, statements), constructor.body)), constructor);
        if (exists) {
            members[index] = constructor;
        }
        else {
            members.unshift(constructor);
        }
        return members;
    };
    return ClassDeclarationMutator;
}(Mutator_1.Mutator));
exports.ClassDeclarationMutator = ClassDeclarationMutator;
