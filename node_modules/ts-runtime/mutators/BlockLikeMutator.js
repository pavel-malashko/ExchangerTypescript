"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var util = require("../util");
var Mutator_1 = require("./Mutator");
var BlockLikeMutator = /** @class */ (function (_super) {
    __extends(BlockLikeMutator, _super);
    function BlockLikeMutator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.kind = [
            ts.SyntaxKind.SourceFile,
            ts.SyntaxKind.Block,
            ts.SyntaxKind.ModuleBlock,
            ts.SyntaxKind.CaseClause,
            ts.SyntaxKind.DefaultClause
        ];
        return _this;
    }
    BlockLikeMutator.prototype.mutate = function (node) {
        var needsUpdate = false;
        var statements = [];
        for (var _i = 0, _a = node.statements; _i < _a.length; _i++) {
            var statement = _a[_i];
            if (util.isAmbientDeclaration(statement)) {
                continue;
            }
            var statementSubstitution = util.asArray(statement);
            switch (statement.kind) {
                case ts.SyntaxKind.FunctionDeclaration:
                    statementSubstitution = this.annotateFunctionDeclaration(statement);
                    needsUpdate = true;
                    break;
                case ts.SyntaxKind.ClassDeclaration:
                    if (util.hasTypeParameters(statement)) {
                        statementSubstitution = this.annotateClassDeclaration(statement);
                        needsUpdate = true;
                    }
                    break;
                case ts.SyntaxKind.EnumDeclaration:
                    statementSubstitution = this.annotateEnumDeclaration(statement);
                    needsUpdate = true;
                    break;
            }
            statements.push.apply(statements, statementSubstitution);
        }
        return needsUpdate ? this.updateBlock(node, statements) : node;
    };
    BlockLikeMutator.prototype.updateBlock = function (node, statements) {
        switch (node.kind) {
            case this.kind[0]:
                return this.map(ts.updateSourceFileNode(node, statements), node);
            case this.kind[1]:
                return this.map(ts.updateBlock(node, statements), node);
            case this.kind[2]:
                return this.map(ts.updateModuleBlock(node, statements), node);
            case this.kind[3]:
                return this.map(ts.updateCaseClause(node, node.expression, statements), node);
            case this.kind[4]:
                return this.map(ts.updateDefaultClause(node, statements), node);
            default:
                return node;
        }
    };
    BlockLikeMutator.prototype.annotateFunctionDeclaration = function (node) {
        if (this.options.noAnnotate) {
            return [node];
        }
        var annotation = ts.createStatement(this.factory.annotate([
            node.name,
            this.factory.functionReflection(node)
        ]));
        return [node, annotation];
    };
    BlockLikeMutator.prototype.annotateClassDeclaration = function (node) {
        var annotation = ts.createVariableStatement(undefined, this.factory.classTypeParameterSymbolDeclaration(node.name));
        return [annotation, node];
    };
    BlockLikeMutator.prototype.annotateEnumDeclaration = function (node) {
        var annotation = ts.createStatement(this.factory.annotate([
            node.name,
            this.factory.enumReflection(node)
        ]));
        return [node, annotation];
    };
    return BlockLikeMutator;
}(Mutator_1.Mutator));
exports.BlockLikeMutator = BlockLikeMutator;
