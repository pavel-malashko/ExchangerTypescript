import * as ts from 'typescript';
import { Factory } from './factory';
import { Options } from './options';
import { Scanner } from './scanner';
export declare class MutationContext {
    private _options;
    private _sourceFile;
    private _program;
    private _checker;
    private _host;
    private _scanner;
    private _skipNodes;
    private _factory;
    private _transformationContext;
    private _merged;
    private _entryFiles;
    private _commonDir;
    constructor(sourceFile: ts.SourceFile, options: Options, program: ts.Program, host: ts.CompilerHost, scanner: Scanner, entryFiles: string[], commonDir: string, context?: ts.TransformationContext);
    skip<T extends ts.Node>(node: T, recursive?: boolean, ...exclude: ts.Node[]): T;
    shouldSkip(node: ts.Node): boolean;
    dontSkip(node: ts.Node): boolean;
    isEntryFile(fileName: string): boolean;
    isImplementationOfOverload(node: ts.Node): node is ts.FunctionLikeDeclaration;
    isDeclared(node: ts.EntityName): boolean;
    wasDeclared(node: ts.EntityName): boolean;
    isAny(node: ts.Node): boolean;
    isSelfReference(node: ts.TypeReferenceNode): boolean;
    hasSelfReference(node: ts.Node): boolean;
    hasApparentSelfReference(node: ts.Node): boolean;
    hasProperty(node: ts.ClassDeclaration, name: string): boolean;
    getPropertyName(node: ts.ClassDeclaration, name: string): string;
    getIdentifier(text: string): string;
    getTypeDeclarationName(node: string | ts.Identifier): string;
    getReturnTypeDeclarationName(): string;
    getLibDeclarationName(): string;
    getTypeSymbolDeclarationName(node: string | ts.Identifier): string;
    getTypeSymbolDeclarationInitializer(node: string | ts.Identifier): string;
    getTypeParametersDeclarationName(): string;
    getMembers(node: ts.ClassDeclaration | ts.InterfaceDeclaration): (ts.TypeElement | ts.ClassElement)[];
    setMerged(symbol: ts.Symbol): Set<ts.Symbol>;
    wasMerged(symbol: ts.Symbol): boolean;
    sourceFile: ts.SourceFile;
    transformationContext: ts.TransformationContext;
    readonly compilerOptions: ts.CompilerOptions;
    readonly options: Options;
    readonly program: ts.Program;
    readonly checker: ts.TypeChecker;
    readonly host: ts.CompilerHost;
    readonly scanner: Scanner;
    readonly factory: Factory;
    readonly map: <T extends ts.Node>(alias: T, original: ts.Node) => T;
    readonly entryFiles: string[];
    readonly commonDir: string;
}
