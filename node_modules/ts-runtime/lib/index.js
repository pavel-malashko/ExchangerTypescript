"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var t = require("flow-runtime");
var voidType = t.void;
var typeOf = t.typeOf;
t.undef = function () {
    return voidType.bind(t)();
};
t.nostrict = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return t.union.apply(t, args.concat([t.null(), t.undef()]));
};
t.void = function () {
    return t.union(t.null(), t.undef());
};
t.n = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return t.nullable.apply(t, args);
};
t.enum = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return t.union.apply(t, args);
};
t.enumMember = function (arg) {
    return t.literal(arg);
};
t.enumRef = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return t.typeOf.apply(t, args);
};
t.typeOf = function (input, declaration) {
    if (declaration === void 0) { declaration = false; }
    if (declaration && typeof input === 'string') {
        input = t.get(input);
        if (input) {
            if (input.typeName === 'ClassDeclaration') {
                return t.Class(input);
            }
            return input;
        }
    }
    return typeOf.bind(t)(input);
};
exports.lib = t;
exports.default = t;
// const map: Map<string, any> = new Map();
// const intersect = t.intersect;
// const declare = t.declare;
// const ref = t.ref;
// const decorate = t.decorate;
// t.decorate = (type: any, shouldAssert?: boolean) => {
//   return (input: any, propertyName: any, descriptor: any) => {
//     const decorator = decorate.bind(t)(type, shouldAssert)(input, propertyName, descriptor);
//     if (descriptor) descriptor.writable = true;
//     input.writable = true;
//     Object.defineProperty(input, propertyName, decorator);
//   };
// }
//
// t.declare = (name: string, type: any) => {
//   map.set(name, type);
//   declare.bind(t)(name, type);
// }
//
// t.ref = (type: any, ...args: any[]) => {
//   if (typeof type === 'string') {
//     if (map.has(type)) {
//       type = map.get(type);
//     }
//   }
//
//   return ref.bind(t)(type, ...args);
// }
// t.intersect = (...args: any[]) => {
//   return intersect.bind(t)(...args).unwrap();
// }
//
// t.intersection = (...args: any[]) => {
//   return t.intersect(...args);
// }
