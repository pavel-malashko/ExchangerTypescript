{"version":3,"sources":["webpack://tsr/webpack/universalModuleDefinition","webpack://tsr/webpack/bootstrap","webpack://tsr/./src/lib/index.ts","webpack://tsr/../src/primitiveTypes.js","webpack://tsr/../../../node_modules/rollup-regenerator-runtime/regenerator/index.js","webpack://tsr/../src/errorReporting/makeJSONError.js","webpack://tsr/../src/cyclic.js","webpack://tsr/../src/Validation.js","webpack://tsr/../src/errorReporting/RuntimeTypeError.js","webpack://tsr/../src/errorReporting/makeTypeError.js","webpack://tsr/../src/makeError.js","webpack://tsr/../src/compareTypes.js","webpack://tsr/../src/types/Type.js","webpack://tsr/../src/types/AnyType.js","webpack://tsr/../src/errorMessages.js","webpack://tsr/../src/getErrorMessage.js","webpack://tsr/../src/types/TupleType.js","webpack://tsr/../src/types/ArrayType.js","webpack://tsr/../src/types/BooleanLiteralType.js","webpack://tsr/../src/types/BooleanType.js","webpack://tsr/../src/types/EmptyType.js","webpack://tsr/../src/types/ExistentialType.js","webpack://tsr/../src/types/TypeParameterApplication.js","webpack://tsr/../src/typeConstraints.js","webpack://tsr/../src/types/TypeAlias.js","webpack://tsr/../src/types/TypeParameter.js","webpack://tsr/../src/types/FlowIntoType.js","webpack://tsr/../src/types/FunctionTypeRestParam.js","webpack://tsr/../src/types/FunctionTypeParam.js","webpack://tsr/../src/types/FunctionTypeReturn.js","webpack://tsr/../src/symbols.js","webpack://tsr/../src/types/FunctionType.js","webpack://tsr/../src/types/GeneratorType.js","webpack://tsr/../src/types/TypeConstructor.js","webpack://tsr/../src/types/GenericType.js","webpack://tsr/../src/invariant.js","webpack://tsr/../src/types/NullLiteralType.js","webpack://tsr/../src/types/VoidType.js","webpack://tsr/../src/types/NullableType.js","webpack://tsr/../src/types/ObjectTypeProperty.js","webpack://tsr/../src/types/ObjectTypeIndexer.js","webpack://tsr/../src/types/ObjectTypeCallProperty.js","webpack://tsr/../src/declarations/Declaration.js","webpack://tsr/../src/declarations/VarDeclaration.js","webpack://tsr/../src/declarations/TypeDeclaration.js","webpack://tsr/../src/declarations/ModuleDeclaration.js","webpack://tsr/../src/declarations/ModuleExportsDeclaration.js","webpack://tsr/../src/declarations/ClassDeclaration.js","webpack://tsr/../src/types/PartialType.js","webpack://tsr/../src/declarations/ParameterizedClassDeclaration.js","webpack://tsr/../src/declarations/ExtendsDeclaration.js","webpack://tsr/../src/types/ObjectType.js","webpack://tsr/../src/types/IntersectionType.js","webpack://tsr/../src/types/MixedType.js","webpack://tsr/../src/types/NumericLiteralType.js","webpack://tsr/../src/types/NumberType.js","webpack://tsr/../src/types/ParameterizedTypeAlias.js","webpack://tsr/../src/types/ParameterizedFunctionType.js","webpack://tsr/../src/types/RefinementType.js","webpack://tsr/../src/types/StringLiteralType.js","webpack://tsr/../src/types/StringType.js","webpack://tsr/../src/types/SymbolLiteralType.js","webpack://tsr/../src/types/SymbolType.js","webpack://tsr/../src/types/ThisType.js","webpack://tsr/../src/types/TypeBox.js","webpack://tsr/../src/types/TypeReference.js","webpack://tsr/../src/types/TypeTDZ.js","webpack://tsr/../src/types/UnionType.js","webpack://tsr/../src/TypeInferrer.js","webpack://tsr/../src/errorReporting/makeWarningMessage.js","webpack://tsr/../src/makeUnion.js","webpack://tsr/../src/classDecorators.js","webpack://tsr/../src/annotateValue.js","webpack://tsr/../src/flowTypes/$DiffType.js","webpack://tsr/../src/flowTypes/$FlowFixMeType.js","webpack://tsr/../src/flowTypes/$KeysType.js","webpack://tsr/../src/flowTypes/$ObjMapiType.js","webpack://tsr/../src/flowTypes/$ObjMapType.js","webpack://tsr/../src/flowTypes/$PropertyType.js","webpack://tsr/../src/flowTypes/$ShapeType.js","webpack://tsr/../src/flowTypes/$SubType.js","webpack://tsr/../src/flowTypes/$SuperType.js","webpack://tsr/../src/flowTypes/$TupleMapType.js","webpack://tsr/../src/flowTypes/$ValuesType.js","webpack://tsr/../src/flowTypes/ClassType.js","webpack://tsr/../src/TypeContext.js","webpack://tsr/../src/makeReactPropTypes.js","webpack://tsr/../src/globalContext.js","webpack://tsr/../src/registerPrimitiveTypes.js","webpack://tsr/../src/registerBuiltins.js","webpack://tsr/../src/registerTypePredicates.js","webpack://tsr/../src/index.cjs.js","webpack://tsr/(webpack)/buildin/global.js","webpack://tsr/./node_modules/regenerator-runtime/runtime-module.js","webpack://tsr/./node_modules/regenerator-runtime/runtime.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","voidType","void","typeOf","undef","nostrict","args","_i","arguments","length","union","apply","concat","null","nullable","enum","enumMember","arg","literal","enumRef","input","declaration","typeName","Class","lib","default","primitiveTypes","_regeneratorRuntime","require","makeJSONError","validation","hasErrors","context","errors","_step","iterator","_iteratorNormalCompletion","_iterator","next","done","path","_ref2","message","expectedType","expected","toString","actual","resolvePath","field","stringifyPath","pointer","join","push","cyclicValidation","WeakMap","cyclicToString","WeakSet","inValidationCycle","type","tracked","weakSetHas","e","startValidationCycle","set","endValidationCycle","inToStringCycle","has","startToStringCycle","add","endToStringCycle","delete","weakset","weakSetAdd","weakSetDelete","validIdentifierOrAccessor","Validation","prefix","cyclic","this","matchPath","didClear","_step2","_iteratorNormalCompletion2","_iterator2","error","parts","Array","part","test","String","subject","Map","candidate","RuntimeTypeError","options","assign","_this","TypeError","delimiter","makeTypeError","collected","actualType","actualAsString","makeString","trim","_typeof","isArray","constructor","JSON","stringify","makeError","validate","compareTypes","a","b","result","TypeAlias","TypeParameter","TypeParameterApplication","TypeTDZ","unwrap","compareWith","FlowIntoType","AnyType","ExistentialType","MixedType","Type","Error","captureStackTrace","assert","possibleConstructorReturn","_temp","errorMessages","getErrorMessage","params","_len","_key","replace","TupleType","types","checkPredicate","accepts","inputTypes","isGreater","ArrayType","inCycle","startCycle","elementType","endCycle","output","BooleanLiteralType","BooleanType","EmptyType","typeInstances","parent","toConsumableArray","_parent","inner","hasProperty","getProperty","_ref3","_parent2","items","typeInstance","collectConstraintErrors","addConstraints","constraints","_subject$constraints","_len2","_key2","constraint","violation","constraintsAccept","_len3","_key3","hasConstraints","target","withDeclaration","properties","FlowIntoSymbol","bound","recorded","boundOrDefault","withBinding","id","defaultType","typeParameter","hasError","toJSON","FunctionTypeRestParam","FunctionTypeParam","optional","undefined","FunctionTypeReturn","ParentSymbol","NameRegistrySymbol","ModuleRegistrySymbol","CurrentModuleSymbol","TypeConstructorRegistrySymbol","InferrerSymbol","TypeSymbol","TypeParametersSymbol","TypePredicateRegistrySymbol","FunctionType","returnType","annotation","param","acceptsType","annotationParam","any","returnTypeResult","inputParams","inputParam","rest","paramsLength","argsLength","_len4","_key4","empty","GeneratorType","return","throw","isValid","yieldType","nextType","warnedInstances","TypeConstructor","emitWarningMessage","GenericType","impl","getAnnotation","isPrototypeOf","invariant","NullLiteralType","VoidType","NullableType","ObjectTypeProperty","static","isStatic","targetPath","isNullable","existsOn","ObjectTypeIndexer","keyResult","valueResult","ObjectTypeCallProperty","Declaration","VarDeclaration","TypeDeclaration","typeAlias","addConstraint","_typeAlias","_typeAlias2","_typeAlias3","_typeAlias4","_typeAlias5","ModuleDeclaration","moduleExports","exporting","prop","declarations","moduleName","slice","innerContext","import","body","lines","split","indent","ModuleExports","ClassDeclaration","shapeID","superClass","errorPath","propertyName","errorMessage","isSuperClassOf","current","superClassName","bodyProps","superProps","seen","seenStatic","props","PartialType","typeParameters","expand","ParameterizedClassDeclaration","getPartial","_len5","_key5","partial","bodyCreator","class","_len6","_key6","limit","Math","min","intersect","ExtendsDeclaration","collectErrorsWithIndexers","collectErrorsWithoutIndexers","collectErrorsExact","ObjectType","indexers","callProperties","exact","getIndexer","newProp","hasIndexer","indexer","acceptsKey","hasCallProperties","acceptsCallProperties","indexOf","acceptsValue","loop","acceptsWithIndexers","acceptsWithoutIndexers","some","acceptsExact","inputCallProperties","identicalCount","callProperty","j","inputCallProperty","compareTypeCallProperties","inputIndexers","inputProperties","inputProperty","inputIndexer","compareTypeWithIndexers","compareTypeWithoutIndexers","_context2","t2","_context5","t1","IntersectionType","getPropertyIndex","mergeProperties","source","typeProp","index","NumericLiteralType","NumberType","ParameterizedTypeAlias","identifier","typeCreator","_len7","_key7","ParameterizedFunctionType","_getPartial$type","getPartial$2","acceptsParams","acceptsReturn","_getPartial$type2","assertParams","assertReturn","function","RefinementType","StringLiteralType","StringType","SymbolLiteralType","SymbolType","ThisType","TypeBox","reveal","ref","mixed","warnedMissing","TypeReference","RevealedName","RevealedValue","getRevealed","container","existing","UnionType","normalized","TypeInferer","primitive","inferPrimitive","inferred","inferComplex","number","boolean","string","symbol","inferFunction","inferObject","fromCharCode","existential","fn","box","inferArray","handler","getTypeConstructor","inferTypeParameters","inferInternal","inferDict","numericIndexers","stringIndexers","isNaN","values","item","inferredType","array","mergeUnionTypes","aTypes","bTypes","bType","makePropertyDescriptor","typeSource","descriptor","shouldAssert","propertyPath","getClassName","originalSetter","resolveType","warn","augmentExistingAccessors","safeName","makePropertyName","className","initializer","config","writable","objectWithoutProperties","check","propertyToAccessor","receiver","annotateValue","$DiffType","aType","$FlowFixMeType","$KeysType","keys","$ObjMapiType","mapper","applied","invoke","_step3","_iteratorNormalCompletion3","_iterator3","$ObjMapType","$PropertyType","unwrapped","$ShapeType","$SubType","$SuperType","$TupleMapType","tuple","$ValuesType","checkGenericType","checkType","ClassType","instanceType","warnedInvalidReferences","TypeContext","TypeInferrer","inferrer","infer","propertyNames","fromParent","global","getPredicate","predicate","Boolean","_this2","annotate","nameRegistry","var","moduleRegistry","_ref","handlerRegistry","flowIntoTypeParameter","instancePrototype","getPrototypeOf","parentPrototype","parentClass","typeParametersPointer","createContext","currentModule","ModuleExportsDeclaration","head","tail","unshift","_body$properties","_len8","_key8","_len9","_key9","_len10","_key10","method","_len11","_key11","_target$callPropertie","_target$indexers","setProperty","_len12","_key12","_len13","_key13","merged","makeUnion","_len14","_key14","tdz","_len15","_key15","_target5","_validation$path","from","makeWarningMessage","objectType","propName","componentName","makeReactPropTypes","_len16","_key16","clauses","pop","pattern","_len17","_key17","tests","clause","wrappedIterator","_len18","_key18","_target$callPropertie2","_target$indexers2","_target$properties","_$PropertyType","globalContext","__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__","freeze","declareTypeConstructor","Date","mark","getTime","Promise","futureType","keyType","valueType","_ref4","keyTypes","valueTypes","_ref6","findKey","Set","_step4","_step5","_iteratorNormalCompletion5","_iterator5","_step6","_iterator6","_iteratorNormalCompletion6","setPredicate","then","globalContext$2","v","thing","defineProperties","g","Function","eval","self","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","inModule","runtime","wrap","GenStateSuspendedStart","GenStateSuspendedYield","GenStateExecuting","GenStateCompleted","ContinueSentinel","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","GeneratorFunctionPrototype","Generator","GeneratorFunction","displayName","isGeneratorFunction","genFun","ctor","setPrototypeOf","__proto__","awrap","__await","defineIteratorMethods","AsyncIterator","async","innerFn","outerFn","tryLocsList","iter","reverse","Context","reset","skipTempReset","prev","sent","_sent","delegate","tryEntries","forEach","resetTryEntry","charAt","stop","rootRecord","completion","rval","dispatchException","exception","handle","loc","caught","record","entry","tryLoc","hasCatch","hasFinally","catchLoc","finallyLoc","abrupt","finallyEntry","complete","afterLoc","finish","catch","thrown","delegateYield","iterable","resultName","nextLoc","protoGenerator","generator","_invoke","state","doneResult","delegateResult","maybeInvokeDelegate","tryCatch","makeInvokeMethod","obj","err","previousPromise","callInvokeWithMethodAndArg","resolve","reject","info","pushTryEntry","locs","iteratorMethod"],"mappings":"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","file":"ts-runtime.lib.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ts-runtime/lib\"] = factory();\n\telse\n\t\troot[\"tsr\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import * as t from 'flow-runtime';\n\nconst voidType = t.void;\nconst typeOf = t.typeOf;\n\nt.undef = () => {\n  return voidType.bind(t)();\n}\n\nt.nostrict = (...args: any[]) => {\n  return t.union(...args, t.null(), t.undef());\n}\n\nt.void = () => {\n  return t.union(t.null(), t.undef());\n}\n\nt.n = (...args: any[]) => {\n  return t.nullable(...args);\n}\n\nt.enum = (...args: any[]) => {\n  return t.union(...args);\n}\n\nt.enumMember = (arg: any) => {\n  return t.literal(arg);\n}\n\nt.enumRef = (...args: any[]) => {\n  return t.typeOf(...args);\n}\n\nt.typeOf = (input: any, declaration = false) => {\n  if (declaration && typeof input === 'string') {\n    input = t.get(input);\n\n    if (input) {\n      if (input.typeName === 'ClassDeclaration') {\n        return t.Class(input);\n      }\n\n      return input;\n    }\n  }\n\n  return typeOf.bind(t)(input);\n}\n\nexport const lib = t;\nexport default t;\n\n// const map: Map<string, any> = new Map();\n// const intersect = t.intersect;\n// const declare = t.declare;\n// const ref = t.ref;\n// const decorate = t.decorate;\n// t.decorate = (type: any, shouldAssert?: boolean) => {\n//   return (input: any, propertyName: any, descriptor: any) => {\n//     const decorator = decorate.bind(t)(type, shouldAssert)(input, propertyName, descriptor);\n//     if (descriptor) descriptor.writable = true;\n//     input.writable = true;\n//     Object.defineProperty(input, propertyName, decorator);\n//   };\n// }\n//\n// t.declare = (name: string, type: any) => {\n//   map.set(name, type);\n//   declare.bind(t)(name, type);\n// }\n//\n// t.ref = (type: any, ...args: any[]) => {\n//   if (typeof type === 'string') {\n//     if (map.has(type)) {\n//       type = map.get(type);\n//     }\n//   }\n//\n//   return ref.bind(t)(type, ...args);\n// }\n// t.intersect = (...args: any[]) => {\n//   return intersect.bind(t)(...args).unwrap();\n// }\n//\n// t.intersection = (...args: any[]) => {\n//   return t.intersect(...args);\n// }\n","/* @flow */\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nimport type {\n  Type,\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\n/**\n * Covers our builtin types and makes room for future ones.\n */\ntype PrimitiveTypes = {\n  null: NullLiteralType;\n  empty: EmptyType;\n  number: NumberType;\n  boolean: BooleanType;\n  string: StringType;\n  symbol: SymbolType;\n  any: AnyType;\n  mixed: MixedType;\n  void: VoidType;\n  existential: ExistentialType;\n\n  [name: string]: Type<any>;\n};\n\nconst primitiveTypes: any = {};\n\n(primitiveTypes: PrimitiveTypes);\n\nexport default primitiveTypes;","export default require(\"regenerator-runtime\");\n","/* @flow */\n\nimport {stringifyPath, resolvePath} from '../Validation';\nimport type Validation from '../Validation';\n\nexport default function makeJSONError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const errors = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : null;\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n    const field = stringifyPath(validation.path.concat(path));\n\n    const pointer = `/${path.join('/')}`;\n\n    errors.push({\n      pointer,\n      field,\n      message,\n      expected,\n      actual\n    });\n  }\n  return errors;\n}\n","/* @flow */\n\nimport type Type from './types/Type';\n\n// Tracks whether we're in validation of cyclic objects.\nconst cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\nconst cyclicToString = new WeakSet();\n\nexport function inValidationCycle (type: Type<any>, input: any): boolean {\n  try {\n    const tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n  catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nexport function startValidationCycle (type: Type<any>, input: any) {\n  let tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nexport function endValidationCycle (type: Type<any>, input: any) {\n  const tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nexport function inToStringCycle (type: Type<any>): boolean {\n  return cyclicToString.has(type);\n}\n\nexport function startToStringCycle (type: Type<any>) {\n  cyclicToString.add(type);\n}\n\nexport function endToStringCycle (type: Type<any>) {\n  cyclicToString.delete(type);\n}\n\n\nexport function weakSetHas <V: any> (weakset: WeakSet<V>, value: V): boolean {\n  try {\n    return weakset.has(value);\n  }\n  catch (e) {\n    return true;\n  }\n}\n\n\nexport function weakSetAdd <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.add(value);\n  }\n  catch (e) {}\n}\n\n\nexport function weakSetDelete <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.delete(value);\n  }\n  catch (e) {}\n}","/* @flow */\nimport makeJSONError from './errorReporting/makeJSONError';\n\nimport {weakSetHas, weakSetAdd, weakSetDelete} from './cyclic';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\nexport type IdentifierPath = Array<string | number>;\nexport type ErrorTuple = [IdentifierPath, string, Type<any>];\n\nexport type ValidationJSON<T> = {\n  input: T;\n  errors: Array<{\n    pointer: string;\n    message: string;\n    expected: Type<any>;\n    actual: Type<any>;\n  }>\n};\n\nconst validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\n\nexport default class Validation<T> {\n\n  context: TypeContext;\n\n  input: T;\n\n  path: string[] = [];\n\n  prefix: string = '';\n\n  errors: ErrorTuple[] = [];\n\n  // Tracks whether we're in validation of cyclic objects.\n  cyclic: WeakMap<Type<any>, WeakSet<any>> = new WeakMap();\n\n  constructor (context: TypeContext, input: T) {\n    this.context = context;\n    this.input = input;\n  }\n\n  inCycle (type: Type<any>, input: any): boolean {\n    const tracked = this.cyclic.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n\n  startCycle (type: Type<any>, input: any) {\n    let tracked = this.cyclic.get(type);\n    if (!tracked) {\n      tracked = new WeakSet();\n      this.cyclic.set(type, tracked);\n    }\n    weakSetAdd(tracked, input);\n  }\n\n  endCycle (type: Type<any>, input: any) {\n    const tracked = this.cyclic.get(type);\n    if (tracked) {\n      weakSetDelete(tracked, input);\n    }\n  }\n\n  hasErrors (path: ? IdentifierPath): boolean {\n    if (path) {\n      for (const [candidate] of this.errors) {\n        if (matchPath(path, candidate)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return this.errors.length > 0;\n    }\n  }\n\n  addError (path: IdentifierPath, expectedType: Type<any>, message: string): this {\n    this.errors.push([path, message, expectedType]);\n    return this;\n  }\n\n  clearError (path: ? IdentifierPath): boolean {\n    let didClear = false;\n    if (path) {\n      const errors = [];\n      for (const error of this.errors) {\n        if (matchPath(path, error[0])) {\n          didClear = true;\n        }\n        else {\n          errors.push(error);\n        }\n      }\n      this.errors = errors;\n    }\n    else {\n      didClear = this.errors.length > 0;\n      this.errors = [];\n    }\n    return didClear;\n  }\n\n  resolvePath (path: IdentifierPath): any {\n    return resolvePath(this.input, path);\n  }\n\n  toJSON (): * {\n    return makeJSONError(this);\n  }\n\n}\n\nexport function stringifyPath (path: IdentifierPath): string {\n  if (!path.length) {\n    return 'Value';\n  }\n  const {length} = path;\n  const parts = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    }\n    else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    }\n    else if (i > 0) {\n      parts[i] = `.${String(part)}`;\n    }\n    else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nexport function resolvePath (input: any, path: IdentifierPath): any {\n  let subject = input;\n  const {length} = path;\n  for (let i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    }\n    else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nexport function matchPath (path: IdentifierPath, candidate: IdentifierPath): boolean {\n  const {length} = path;\n  if (length > candidate.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n","/* @flow */\n\nimport type {ErrorTuple} from '../Validation';\n\nexport default class RuntimeTypeError extends TypeError {\n  name: string = \"RuntimeTypeError\";\n  errors: ?ErrorTuple[];\n  constructor(message: string, options?: {errors?: ErrorTuple[]}) {\n    super(message);\n    Object.assign(this, options);\n  }\n}","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nimport RuntimeTypeError from './RuntimeTypeError';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeTypeError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {prefix, input, context, errors} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = resolvePath(input, path);\n    const actualType = context.typeOf(actual).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n    const actualAsString = makeString(actual);\n\n    if (typeof actualAsString === 'string') {\n      collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual Value: ${actualAsString}\\n\\nActual Type: ${actualType}\\n`);\n    } else {\n      collected.push(\n        `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actualType}\\n`\n      );\n    }\n  }\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`, {errors});\n  }\n  else {\n    return new RuntimeTypeError(collected.join(delimiter), {errors});\n  }\n}\n\nfunction makeString(value: *) {\n  if (value === null) {\n    return 'null';\n  }\n  switch (typeof value) {\n    case 'string':\n      return `\"${value}\"`;\n    // @flowIssue\n    case 'symbol':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return String(value);\n    case 'function':\n      return;\n    default:\n      if (Array.isArray(value) || value.constructor == null || value.constructor === Object) {\n        try {\n          return JSON.stringify(value, null, 2);\n        }\n        catch (e) {\n          return;\n        }\n      }\n      return;\n  }\n}","/* @flow */\n\nimport type {Type} from './types';\nimport makeTypeError from './errorReporting/makeTypeError';\n\nexport default function makeError (expected: Type<any>, input: any): ? TypeError {\n  const {context} = expected;\n  const validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n","/* @flow */\n\nimport type Type from './types/Type';\n\nimport {\n  AnyType,\n  ExistentialType,\n  TypeParameter,\n  FlowIntoType,\n  MixedType,\n  TypeAlias,\n  TypeParameterApplication,\n  TypeTDZ\n} from './types';\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\nexport default function compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n  let result;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeParameterApplication || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  }\n  else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  }\n  else {\n    return result;\n  }\n}\n","/* @flow */\n\nimport makeError from '../makeError';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport Validation from '../Validation';\nimport type {ErrorTuple, IdentifierPath} from '../Validation';\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nexport default class Type <T> {\n  typeName: string = 'Type';\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    const validation = new Validation(this.context, input);\n    for (const error of this.errors(validation, [], input)) { // eslint-disable-line no-unused-vars\n      return false;\n    }\n    return true;\n  }\n\n  acceptsType (input: Type<any>): boolean {\n    if (compareTypes(this, input) === -1) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return -1;\n  }\n\n  assert <V: T> (input: V): V {\n    const error = makeError(this, input);\n    if (error) {\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(error, this.assert);\n      }\n      throw error;\n    }\n    return input;\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString () {\n    return '$Type';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class AnyType extends Type<any> {\n  typeName: string = 'AnyType';\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return 'any';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nconst errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be a promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exist on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nexport type ErrorKey = $Keys<typeof errorMessages>;\n\nexport default errorMessages;\n","/* @flow */\n\nimport errorMessages from './errorMessages';\nimport type {ErrorKey} from './errorMessages';\n\n\nexport default function getErrorMessage (key: ErrorKey, ...params: any[]): string {\n  const message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, (m, i) => String(params[i]));\n  }\n  else {\n    return message;\n  }\n}\n\n\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TupleType<T> extends Type {\n  typeName: string = 'TupleType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path.concat(i), input[i]);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n\n    if (!context.checkPredicate('Array', input) || input.length < length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof TupleType)) {\n      return -1;\n    }\n    const types = this.types;\n    const inputTypes = input.types;\n    if (inputTypes.length < types.length) {\n      return -1;\n    }\n    let isGreater = false;\n    for (let i = 0; i < types.length; i++) {\n      const result = compareTypes(types[i], inputTypes[i]);\n      if (result === 1) {\n        isGreater = true;\n      }\n      else if (result === -1) {\n        return -1;\n      }\n    }\n    if (types.length < inputTypes.length) {\n      return 0;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n\n  toString (): string {\n    return `[${this.types.join(', ')}]`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport TupleType from './TupleType';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\nexport default class ArrayType <T> extends Type {\n  typeName: string = 'ArrayType';\n  elementType: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n\n    for (let i = 0; i < length; i++) {\n      yield* elementType.errors(validation, path.concat(i), input[i]);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n    for (let i = 0; i < length; i++) {\n      if (!elementType.accepts(input[i])) {\n        endValidationCycle(this, input);\n        return false;\n      }\n    }\n    endValidationCycle(this, input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {elementType} = this;\n    if (input instanceof TupleType) {\n      const {types} = input;\n      for (let i = 0; i < types.length; i++) {\n        const result = compareTypes(elementType, types[i]);\n        if (result === -1) {\n          return -1;\n        }\n      }\n      return 1;\n    }\n    else if (input instanceof ArrayType) {\n      return compareTypes(elementType, input.elementType);\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {elementType} = this;\n    if (inToStringCycle(this)) {\n      if (typeof elementType.name === 'string') {\n        return `Array<$Cycle<${elementType.name}>>`;\n      }\n      else {\n        return `Array<$Cycle<Object>>`;\n      }\n    }\n    startToStringCycle(this);\n    const output = `Array<${elementType.toString()}>`;\n    endToStringCycle(this);\n    return output;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      elementType: this.elementType\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanLiteralType <T: boolean> extends Type {\n  typeName: string = 'BooleanLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== this.value) {\n      yield [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return this.value ? 'true' : 'false';\n  }\n\n  toJSON () {\n    return {\n      type: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport BooleanLiteralType from './BooleanLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanType extends Type {\n  typeName: string = 'BooleanType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'boolean') {\n      yield [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'boolean';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType) {\n      return 1;\n    }\n    else if (input instanceof BooleanType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'boolean';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class EmptyType extends Type {\n  typeName: string = 'EmptyType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n  }\n\n  accepts (input: any): boolean {\n    return false; // empty types accepts nothing.\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof EmptyType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'empty';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ExistentialType extends Type {\n  typeName: string = 'ExistentialType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return '*';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ApplicableType} from './';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\n/**\n * # TypeParameterApplication\n *\n */\nexport default class TypeParameterApplication<X, T> extends Type {\n  typeName: string = 'TypeParameterApplication';\n  parent: ApplicableType<T>;\n  typeInstances: Type<X>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {parent, typeInstances} = this;\n    yield* parent.errors(validation, path, input, ...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    const {parent, typeInstances} = this;\n    return parent.accepts(input, ...typeInstances);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return this.parent.compareWith(input, ...this.typeInstances);\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).hasProperty === 'function') {\n      return (inner: $FlowIgnore).hasProperty(name, ...this.typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).getProperty === 'function') {\n      return (inner: $FlowIgnore).getProperty(name, ...this.typeInstances);\n    }\n  }\n\n  unwrap () {\n    return this.parent.unwrap(...this.typeInstances);\n  }\n\n  toString (): string {\n    const {parent, typeInstances} = this;\n    const {name} = parent;\n    if (typeInstances.length) {\n      const items = [];\n      for (let i = 0; i < typeInstances.length; i++) {\n        const typeInstance = typeInstances[i];\n        items.push(typeInstance.toString());\n      }\n      return `${name}<${items.join(', ')}>`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeInstances: this.typeInstances\n    };\n  }\n}\n","/* @flow */\n\nimport type {\n  Type,\n  TypeConstraint\n} from './types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport type ConstrainableType<T> = Type<T> & {constraints: TypeConstraint[]};\n\n/**\n * Add constraints to the given subject type.\n */\nexport function addConstraints (subject: ConstrainableType<any>, ...constraints: TypeConstraint[]) {\n  subject.constraints.push(...constraints);\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\nexport function *collectConstraintErrors (subject: ConstrainableType<any>, validation: Validation<any>, path: IdentifierPath, ...input: any[]): Generator<ErrorTuple, void, void> {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    const violation = constraint(...input);\n    if (typeof violation === 'string') {\n      yield [path, violation, this];\n    }\n  }\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nexport function constraintsAccept (subject: ConstrainableType<any>, ...input: any[]): boolean {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    if (typeof constraint(...input) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class TypeAlias<T> extends Type {\n  typeName: string = 'TypeAlias';\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): TypeAlias<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  get properties () {\n    return this.type.properties;\n  }\n\n  get hasConstraints (): boolean {\n    return this.constraints.length > 0;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const {name, type} = this;\n    if (withDeclaration) {\n      return `type ${name} = ${type.toString()};`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport FlowIntoType from \"./FlowIntoType\";\nimport TypeAlias from './TypeAlias';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nconst FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\nexport default class TypeParameter<T> extends Type {\n  typeName: string = 'TypeParameter';\n  id: string;\n  bound: ? Type<T>;\n  default: ? Type<T>;\n\n  recorded: ? Type<T>;\n\n  // @flowIssue 252\n  [FlowIntoSymbol]: ? FlowIntoType = null;\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n\n    if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      yield* boundOrDefault.errors(validation, path, input);\n      return;\n    }\n    else if (recorded) {\n      // we've already recorded a value for this type parameter\n      yield* recorded.errors(validation, path, input);\n      return;\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasErrors = false;\n        for (const error of boundOrDefault.errors(validation, path, input)) {\n          hasErrors = true;\n          yield error;\n        }\n        if (hasErrors) {\n          return;\n        }\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n    if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      return boundOrDefault.accepts(input);\n    } else if (recorded) {\n      return recorded.accepts(input);\n    } else if (boundOrDefault) {\n      if (boundOrDefault.typeName === \"AnyType\" || boundOrDefault.typeName === \"ExistentialType\") {\n        return true;\n      } else if (!boundOrDefault.accepts(input)) {\n        return false;\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (input instanceof TypeParameter) {\n      // We don't need to check for `recorded` or `bound` fields\n      // because the input has already been unwrapped, so\n      // if we got a type parameter it must be totally generic and\n      // we treat it like Any.\n      return 1;\n    }\n    else if (recorded) {\n      return compareTypes(recorded, input);\n    }\n    else if (boundOrDefault) {\n      return compareTypes(boundOrDefault, input);\n    }\n    else {\n      // A generic type parameter accepts any input.\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (recorded) {\n      return recorded.unwrap();\n    }\n    else if (boundOrDefault) {\n      return boundOrDefault.unwrap();\n    }\n    else {\n      return this;\n    }\n  }\n\n  toString (withBinding?: boolean): string {\n    const {id, bound, default: defaultType} = this;\n    if (withBinding) {\n      if (defaultType) {\n        return `${id} = ${defaultType.toString()}`;\n      }\n      else if (bound) {\n        return `${id}: ${bound.toString()}`;\n      }\n    }\n    return id;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      bound: this.bound,\n      recorded: this.recorded\n    };\n  }\n}\n\nexport function flowIntoTypeParameter <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n  const existing: ? FlowIntoType<T> = (typeParameter: $FlowIssue<252>)[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  const target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  (typeParameter: $FlowIssue<252>)[FlowIntoSymbol] = target;\n  return target;\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\nexport default class FlowIntoType<T: any> extends Type {\n  typeName: string = 'FlowIntoType';\n\n  typeParameter: TypeParameter<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      yield* bound.errors(validation, path, input);\n      return;\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound) {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.accepts(input);\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound && !bound.accepts(input)) {\n        return false;\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return true;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return true;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!bound.accepts(input)) {\n        return false;\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.compareWith(input);\n    }\n    if (recorded) {\n      if (bound && compareTypes(bound, input) === -1) {\n        return -1;\n      }\n      const result = compareTypes(recorded, input);\n      if (result === 0) {\n        // our existing type already permits this value, there's nothing to do.\n        return 0;\n      }\n      // we need to make a union\n      typeParameter.recorded = context.union(recorded, input);\n      return 1;\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return 1;\n      }\n      const result = compareTypes(bound, input);\n      if (result === -1) {\n        return -1;\n      }\n    }\n\n    typeParameter.recorded = input;\n    return 0;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.typeParameter.unwrap();\n  }\n\n  toString (withBinding?: boolean): string {\n    return this.typeParameter.toString(withBinding);\n  }\n\n  toJSON () {\n    return this.typeParameter.toJSON();\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class FunctionTypeRestParam<T> extends Type {\n  typeName: string = 'FunctionTypeRestParam';\n  name: string;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `...${this.name}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\n\nexport default class FunctionTypeParam<T> extends Type {\n  typeName: string = 'FunctionTypeParam';\n  name: string;\n  optional: boolean;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return;\n    }\n    else {\n      yield* type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return true;\n    }\n    else {\n      return type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (): string {\n    const {optional, type} = this;\n    return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      optional: this.optional,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class FunctionTypeReturn<T> extends Type {\n  typeName: string = 'FunctionTypeReturn';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path.concat('[[Return Type]]'), input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeReturn) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  unwrap (): Type<T> {\n    return this.type;\n  }\n\n  toString (): string {\n    const {type} = this;\n    return type.toString();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nexport const ParentSymbol = Symbol('Parent');\nexport const NameRegistrySymbol = Symbol('NameRegistry');\nexport const ModuleRegistrySymbol = Symbol('ModuleRegistry');\nexport const CurrentModuleSymbol = Symbol('CurrentModule');\nexport const TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nexport const InferrerSymbol = Symbol('Inferrer');\nexport const TraverseValueSymbol = Symbol('TraverseValue');\nexport const TraverseTypeSymbol = Symbol('TraverseType');\nexport const TypeSymbol = Symbol('Type');\nexport const TypeParametersSymbol = Symbol('TypeParameters');\nexport const TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\nimport FunctionTypeReturn from './FunctionTypeReturn';\nimport EmptyType from './EmptyType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {TypeSymbol} from '../symbols';\n\nexport default class FunctionType<P, R> extends Type {\n  typeName: string = 'FunctionType';\n  params: FunctionTypeParam<P>[] = [];\n  rest: ? FunctionTypeRestParam<P>;\n  returnType: FunctionTypeReturn<R>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n      return;\n    }\n    const annotation = input[TypeSymbol];\n    const {returnType, params} = this;\n    if (annotation) {\n      if (!annotation.params) {\n        return;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        yield [\n          path,\n          getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()),\n          this\n        ];\n      }\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const {returnType, params} = this;\n    const annotation = input[TypeSymbol];\n    if (annotation) {\n      if (!annotation.params) {\n        return true;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          return false;\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          return false;\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        return false;\n      }\n      return true;\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof FunctionType)) {\n      return -1;\n    }\n    const returnType = this.returnType;\n    const inputReturnType = input.returnType;\n    let isGreater = false;\n    const returnTypeResult = compareTypes(returnType, inputReturnType);\n    if (returnTypeResult === -1) {\n      return -1;\n    }\n    else if (returnTypeResult === 1) {\n      isGreater = true;\n    }\n\n    const params = this.params;\n    const inputParams = input.params;\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n      if (inputParam == null) {\n        return -1;\n      }\n      const result = compareTypes(param, inputParam);\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.accepts(args[i])) {\n          return false;\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return false;\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.accepts(args[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  assertParams (...args: any[]): P[] {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        param.assert(args[i]);\n      }\n      else {\n        param.assert(undefined);\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        rest.assert(args[i]);\n      }\n    }\n\n    return args;\n  }\n\n  assertReturn <T> (input: any): T {\n    this.returnType.assert(input);\n    return input;\n  }\n\n  invoke (...args: Type<P>[]): Type<R> | EmptyType {\n    const {params, rest, context} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return context.empty();\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n    }\n\n    return this.returnType.type;\n  }\n\n  toString (): string {\n    const {params, rest, returnType} = this;\n    const args = [];\n    for (let i = 0; i < params.length; i++) {\n      args.push(params[i].toString());\n    }\n    if (rest) {\n      args.push(rest.toString());\n    }\n    return `(${args.join(', ')}) => ${returnType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      params: this.params,\n      rest: this.rest,\n      returnType: this.returnType\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GeneratorType<Y, R, N> extends Type {\n  typeName: string = 'GeneratorType';\n  yieldType: Type<Y>;\n  returnType: Type<R>;\n  nextType: Type<N>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const isValid = input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof GeneratorType)) {\n      const result = compareTypes(this.yieldType, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n    let isGreater = false;\n    let result = compareTypes(this.yieldType, input.yieldType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.returnType, input.returnType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.nextType, input.nextType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsYield (input: any): boolean {\n    return this.yieldType.accepts(input);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  acceptsNext (input: any): boolean {\n    return this.nextType.accepts(input);\n  }\n\n  assertYield (input: Y): Y {\n    return this.yieldType.assert(input);\n  }\n\n  assertReturn (input: R): R {\n    return this.returnType.assert(input);\n  }\n\n  assertNext (input: N): N {\n    return this.nextType.assert(input);\n  }\n\n  toString (): string {\n    const {yieldType, returnType, nextType} = this;\n    return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      yieldType: this.yieldType,\n      returnType: this.returnType,\n      nextType: this.nextType\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type {Constructor} from './';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeConstructor<T> extends Type {\n  typeName: string = 'TypeConstructor';\n  name: string;\n  impl: ? Constructor<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement accepts().`);\n      warnedInstances.add(this);\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement compareWith().`);\n      warnedInstances.add(this);\n    }\n    return -1;\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n\n  apply <P> (...typeInstances: Type<P>[]): TypeParameterApplication<P, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): TypeConstructor<T> {\n    return this;\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n\n}\n","/* @flow */\n\nimport TypeConstructor from \"./TypeConstructor\";\n\nimport type Type from \"./Type\";\nimport compareTypes from \"../compareTypes\";\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, { ErrorTuple, IdentifierPath } from \"../Validation\";\n\nexport default class GenericType extends TypeConstructor {\n  typeName: string = \"GenericType\";\n\n  *errors(\n    validation: Validation<any>,\n    path: IdentifierPath,\n    input: any\n  ): Generator<ErrorTuple, void, void> {\n    const { name, impl } = this;\n    if (!(input instanceof impl)) {\n      yield [path, getErrorMessage(\"ERR_EXPECT_INSTANCEOF\", name), this];\n    }\n  }\n\n  accepts<P>(input: any, ...typeInstances: Type<P>[]): boolean {\n    const { impl } = this;\n    return input instanceof impl;\n  }\n\n  compareWith<P>(input: Type<any>, ...typeInstances: Type<P>[]): -1 | 0 | 1 {\n    const { context, impl } = this;\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      const expected = annotation.unwrap(...typeInstances);\n      return compareTypes(input, expected);\n    } else if (\n      input instanceof GenericType &&\n      (input.impl === impl || (impl && impl.isPrototypeOf(input.impl)))\n    ) {\n      return 0;\n    } else {\n      return -1;\n    }\n  }\n\n  unwrap<P>(...typeInstances: Type<P>[]) {\n    const { context, impl } = this;\n    if (typeof impl !== \"function\") {\n      return this;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation != null) {\n      return (annotation.unwrap(...typeInstances): any);\n    } else {\n      return this;\n    }\n  }\n\n  inferTypeParameters<P>(input: any): Type<P>[] {\n    return [];\n  }\n}\n","/* @flow */\n\nexport default function invariant (input: any, message: string): void {\n  if (!input) {\n    const error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullLiteralType extends Type {\n  typeName: string = 'NullLiteralType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== null) {\n      yield [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === null;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'null';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class VoidType extends Type {\n  typeName: string = 'VoidType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== undefined) {\n      yield [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === undefined;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof VoidType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'void';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport NullLiteralType from './NullLiteralType';\nimport VoidType from './VoidType';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullableType<T> extends Type<T> {\n  typeName: string = 'NullableType';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input != null) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (input == null) {\n      return true;\n    }\n    else {\n      return this.type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType || input instanceof VoidType) {\n      return 1;\n    }\n    else if (input instanceof NullableType) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (): string {\n    return `? ${this.type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport NullableType from './NullableType';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ObjectTypeProperty<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeProperty';\n  key: K;\n  value: Type<V>;\n  optional: boolean;\n  // @flowIgnore\n  'static': boolean = false;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): ObjectTypeProperty<K, V> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n  \n  /**\n   * Determine whether the property is nullable.\n   */\n  isNullable(): boolean {\n    return this.value instanceof NullableType;\n  }\n  \n  /**\n   * Determine whether the property exists on the given input or its prototype chain.\n   */\n  existsOn(input: Object): boolean {\n    // @flowIgnore\n    const {key, static: isStatic} = this;\n    return key in (isStatic ? input.constructor : input) === true;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        if (!optional) {\n          yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        }\n        return;\n      }\n      targetPath.push(key);\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n      targetPath = path.concat(key);\n    }\n    if (optional && target === undefined) {\n      return;\n    }\n    if (this.isNullable() && !this.existsOn(input)) {\n      yield [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n      return;\n    }\n    let hasErrors = false;\n    for (const error of value.errors(validation, targetPath, target)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, targetPath, target);\n    }\n  }\n\n  accepts (input: Object): boolean {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return optional ? true : false;\n      }\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n    }\n    \n    if (optional && target === undefined) {\n      return true;\n    }\n    \n    if (this.isNullable() && !this.existsOn(input)) {\n      return false;\n    }\n    \n    if (!value.accepts(target)) {\n      return false;\n    }\n    else {\n      return constraintsAccept(this, target);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeProperty)) {\n      return -1;\n    }\n    else if (input.key !== this.key) {\n      return -1;\n    }\n    else {\n      return compareTypes(this.value, input.value);\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    let key = this.key;\n    // @flowIssue 252\n    if (typeof key === 'symbol') {\n      key = `[${key.toString()}]`;\n    }\n    if (this.static) {\n      return `static ${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n    else {\n      return `${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      key: this.key,\n      value: this.value,\n      optional: this.optional\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport ObjectTypeProperty from './ObjectTypeProperty';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeIndexer<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeIndexer';\n  id: string;\n  key: Type<K>;\n  value: Type<V>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, key: any, value: any): Generator<ErrorTuple, void, void> {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n\n    yield* this.key.errors(validation, path.concat('[[Key]]'), key);\n    yield* this.value.errors(validation, path.concat(key), value);\n  }\n\n  accepts (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  acceptsKey (key: any): boolean {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n    return this.key.accepts(key);\n  }\n\n  acceptsValue (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ObjectTypeProperty) {\n      if (!this.key.accepts(input.key)) {\n        return -1;\n      }\n      else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n    else if (!(input instanceof ObjectTypeIndexer)) {\n      return -1;\n    }\n\n    const keyResult = compareTypes(this.key, input.key);\n    if (keyResult === -1) {\n      return -1;\n    }\n    const valueResult = compareTypes(this.value, input.value);\n    if (valueResult === -1) {\n      return -1;\n    }\n\n    if (keyResult === 0 && valueResult === 0) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      key: this.key,\n      value: this.value\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeCallProperty<T: Function> extends Type {\n  typeName: string = 'ObjectTypeCallProperty';\n  value: Type<T>;\n  // @flowIgnore\n  'static': boolean = false;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        return;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n      targetPath = path;\n    }\n    yield* value.errors(validation, targetPath, target);\n  }\n\n  accepts (input: any): boolean {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return false;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n    }\n    return value.accepts(target);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeCallProperty)) {\n      return -1;\n    }\n    return compareTypes(this.value, input.value);\n  }\n\n  unwrap (): Type<T> {\n    return this.value.unwrap();\n  }\n\n\n  toString (): string {\n    if (this.static) {\n      return `static ${this.value.toString()};`;\n    }\n    else {\n      return this.value.toString();\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\n\nexport default class Declaration extends Type {\n  name: string;\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {Type, TypeConstraint} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class VarDeclaration<T> extends Declaration {\n  typeName: string = 'VarDeclaration';\n\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): VarDeclaration<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare var ${this.name}: ${this.type.toString()};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {\n  Type,\n  TypeAlias,\n  ParameterizedTypeAlias,\n  TypeConstraint,\n  TypeParameterApplication,\n  ObjectTypeProperty\n} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TypeDeclaration<T> extends Declaration {\n  typeName: string = 'TypeDeclaration';\n\n  get type (): Type<T> {\n    return this.typeAlias.type;\n  }\n\n  typeAlias: TypeAlias<T> | ParameterizedTypeAlias<T>;\n\n  addConstraint (...constraints: TypeConstraint[]): TypeDeclaration<T> {\n    this.typeAlias.addConstraint(...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.typeAlias.errors(validation, path, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    return this.typeAlias.apply(...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    return this.typeAlias.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.typeAlias, input);\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    return this.typeAlias.hasProperty(name, ...typeInstances);\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    return this.typeAlias.getProperty(name, ...typeInstances);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return this.typeAlias.unwrap(...typeInstances);\n  }\n\n  toString (): string {\n    return `declare ${this.typeAlias.toString(true)};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\nimport type ModuleExportsDeclaration from './ModuleExportsDeclaration';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type DeclarationDict = {\n  [name: string]: Type<any>;\n};\n\nexport type ModuleDeclarationDict = {\n  [name: string]: ModuleDeclaration;\n};\n\nimport {NameRegistrySymbol, ModuleRegistrySymbol} from '../symbols';\n\nexport default class ModuleDeclaration extends Declaration {\n  typeName: string = 'ModuleDeclaration';\n\n\n  name: string;\n  innerContext: TypeContext;\n  moduleExports: ? ModuleExportsDeclaration<any>;\n\n  get moduleType (): 'commonjs' | 'es6' {\n    if (this.moduleExports) {\n      return 'commonjs';\n    }\n    else {\n      return 'es6';\n    }\n  }\n\n  get isCommonJS (): boolean {\n    return this.moduleExports ? true : false;\n  }\n\n  get isES6 (): boolean {\n    return this.moduleExports ? false : true;\n  }\n\n  get declarations (): DeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[NameRegistrySymbol];\n  }\n\n  get modules (): ModuleDeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[ModuleRegistrySymbol];\n  }\n\n  get (name: string): ? Type<any> {\n    const {moduleExports} = this;\n    if (moduleExports) {\n      const exporting = moduleExports.unwrap();\n      if (typeof exporting.getProperty === 'function') {\n        const prop = exporting.getProperty(name);\n        if (prop) {\n          return prop.unwrap();\n        }\n      }\n    }\n    else {\n      const declaration = this.declarations[name];\n      if (declaration) {\n        return declaration.unwrap();\n      }\n    }\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // Can't validate a module directly.\n    // @todo should this throw?\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    if (/^\\.\\//.test(moduleName)) {\n      moduleName = `${this.name}${moduleName.slice(1)}`;\n    }\n    return this.innerContext.import(moduleName);\n  }\n\n  toString (): string {\n\n    const {name, declarations, modules, moduleExports} = this;\n    const body = [];\n    for (const name in declarations) { // eslint-disable-line guard-for-in\n      const declaration = declarations[name];\n      body.push(declaration.toString(true));\n    }\n    if (modules) {\n      for (const name in modules) { // eslint-disable-line guard-for-in\n        const module = modules[name];\n        body.push(module.toString());\n      }\n    }\n    if (moduleExports) {\n      body.push(moduleExports.toString());\n    }\n    return `declare module \"${name}\" {\\n${indent(body.join('\\n\\n'))}}`;\n  }\n}\n\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ModuleExports<T> extends Declaration {\n  typeName: string = 'ModuleExports';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare module.exports: ${this.type.toString()};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport getErrorMessage from \"../getErrorMessage\";\nimport compareTypes from '../compareTypes';\n\nimport type ParameterizedClassDeclaration from './ParameterizedClassDeclaration';\n\nimport type {Type, ObjectType} from '../types';\n\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ClassDeclaration<O: {}> extends Declaration {\n  typeName: string = 'ClassDeclaration';\n\n  name: string;\n  superClass: ? Type<any>;\n  body: ObjectType<O>;\n\n  shapeID: Symbol = Symbol();\n\n  get properties (): Array<*> {\n    const {body, superClass} = this;\n    if (superClass == null) {\n      return body.properties;\n    }\n    const bodyProps = body.properties;\n    const superProps = (superClass.unwrap(): $FlowFixme).properties;\n    if (superProps == null) {\n      return bodyProps;\n    }\n    const seen = {};\n    const seenStatic = {};\n    const props = [];\n    for (let i = 0; i < superProps.length; i++) {\n      const prop = superProps[i];\n      props.push(prop);\n      if (prop.static) {\n        seenStatic[prop.key] = i;\n      }\n      else {\n        seen[prop.key] = i;\n      }\n    }\n    for (let i = 0; i < bodyProps.length; i++) {\n      const prop = bodyProps[i];\n      if (seen[prop.key]) {\n        props[i] = prop;\n      }\n      else {\n        props.push(prop);\n      }\n    }\n    return props;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n      return;\n    }\n    if (superClass) {\n      for (const [errorPath, errorMessage, expectedType] of superClass.errors(validation, path, input)) {\n        const propertyName = errorPath[path.length];\n        if (body.getProperty(propertyName)) {\n          continue;\n        }\n        else {\n          yield [errorPath, errorMessage, expectedType];\n        }\n      }\n    }\n    yield* body.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    else if (superClass && !superClass.accepts(input)) {\n      return false;\n    }\n    else if (!body.accepts(input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ClassDeclaration) {\n      if (input === this) {\n        return 0;\n      }\n      else if (this.isSuperClassOf(input)) {\n        return 1;\n      }\n      else {\n        return -1;\n      }\n    }\n    return compareTypes(this.body, input);\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<O>, any> {\n    const {body, superClass} = this;\n    const prop = body.getProperty(key);\n    if (prop) {\n      return prop;\n    }\n    else if (superClass && typeof superClass.getProperty === 'function') {\n      return superClass.getProperty(key);\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {body, superClass} = this;\n    if (body.hasProperty(key)) {\n      return true;\n    }\n    else if (superClass && typeof superClass.hasProperty === 'function') {\n      return superClass.hasProperty(key);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether this class declaration represents a super class of\n   * the given type.\n   */\n  isSuperClassOf <X: {}> (candidate: ClassDeclaration<X> | ParameterizedClassDeclaration<*, X>) {\n    const {body, shapeID} = this;\n    let current = candidate;\n\n    while (current != null) {\n      if (current === this || current === body || current.shapeID === shapeID) {\n        return true;\n      }\n      if (current instanceof ClassDeclaration) {\n        current = current.superClass;\n      }\n      else {\n        current = current.unwrap();\n      }\n    }\n    return false;\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {name, superClass, body} = this;\n    if (withDeclaration) {\n      const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n      return `declare class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n    }\n    else {\n      return name;\n    }\n  }\n}\n","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\nimport TypeParameterApplication from './TypeParameterApplication';\n\nimport {collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class PartialType<X, T> extends Type {\n  typeName: string = 'PartialType';\n  name: string;\n  type: Type<T>;\n  typeParameters: TypeParameter<X>[] = [];\n  constraints: ? TypeConstraint[];\n\n  typeParameter (id: string, bound?: Type<X>, defaultType?: Type<X>): TypeParameter<X> {\n    const target = new TypeParameter(this.context);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    this.typeParameters.push(target);\n    return target;\n  }\n\n  apply (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {constraints, type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors && constraints) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {constraints, type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (constraints && !constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (expand?: boolean): string {\n    const {type} = this;\n    return type.toString(expand);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeParameters: this.typeParameters,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport PartialType from '../types/PartialType';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport type {Type, TypeParameter} from '../types';\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ClassBodyCreator} from './';\n\n\n\nexport default class ParameterizedClassDeclaration<X, O: Object> extends Declaration {\n  typeName: string = 'ParameterizedClassDeclaration';\n  bodyCreator: ClassBodyCreator<X, O>;\n  name: string;\n\n  shapeID: Symbol = Symbol();\n\n  get superClass (): ? Type<$Supertype<O>> {\n    return getPartial(this).type.superClass;\n  }\n\n  get body (): ? Type<O> {\n    return getPartial(this).type.body;\n  }\n\n  get properties(): Property<*, *>[] {\n    return getPartial(this).type.properties;\n  }\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return getPartial(this).compareWith(input);\n  }\n\n  unwrap (...typeInstances: Type<any>[]): Type<O> {\n    return getPartial(this, ...typeInstances).type;\n  }\n\n  isSuperClassOf (candidate: *) {\n    return getPartial(this).type.isSuperClassOf(candidate);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    if (!withDeclaration) {\n      return this.name;\n    }\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return partial.toString(true);\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    const {superClass, body} = type;\n    const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n    return `declare class ${this.name}<${items.join(', ')}>${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n  }\n\n  toJSON () {\n    return getPartial(this).toJSON();\n  }\n}\n\nfunction getPartial <X, O: Object> (parent: ParameterizedClassDeclaration<X, O>, ...typeInstances: Type<any>[]): PartialType<O> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class(parent.name, ...body);\n  }\n  else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  (partial.type: $FlowFixme).shapeID = parent.shapeID;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ExtendsDeclaration<T> extends Declaration {\n  typeName: string = 'ExtendsDeclaration';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {type} = this;\n    if (withDeclaration) {\n      return `extends ${type.toString()}`;\n    }\n    else {\n      return type.toString();\n    }\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport ObjectTypeProperty from './ObjectTypeProperty';\nimport ObjectTypeIndexer from './ObjectTypeIndexer';\nimport ObjectTypeCallProperty from './ObjectTypeCallProperty';\n\nimport {ClassDeclaration, ParameterizedClassDeclaration} from '../declarations';\n\nexport type Property<K: string | number, V>\n = ObjectTypeProperty<K, V>\n | ObjectTypeIndexer<K, V>\n ;\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\n\nexport default class ObjectType<T: {}> extends Type {\n  typeName: string = 'ObjectType';\n  properties: ObjectTypeProperty<$Keys<T>, any>[] = [];\n  indexers: ObjectTypeIndexer<any, any>[] = [];\n  callProperties: ObjectTypeCallProperty<any>[] = [];\n  exact: boolean = false;\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<T>, any> {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return property;\n      }\n    }\n    return this.getIndexer(key);\n  }\n\n  setProperty (key: string | number, value: Type<*>, optional: boolean = false) {\n    const { context, properties } = this;\n    const { length } = properties;\n    const newProp = new ObjectTypeProperty(context);\n    newProp.key = key;\n    newProp.value = value;\n    newProp.optional = optional;\n\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        properties[i] = newProp;\n        return;\n      }\n    }\n    properties.push(newProp);\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return true;\n      }\n    }\n    return this.hasIndexer(key);\n  }\n\n\n  /**\n   * Get an indexer with which matches the given key type.\n   */\n  getIndexer <K: string | number> (key: K): ? ObjectTypeIndexer<K, any> {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return indexer;\n      }\n    }\n  }\n\n  /**\n   * Determine whether an indexer exists which matches the given key type.\n   */\n  hasIndexer (key: string | number): boolean {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input === null) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n      }\n    }\n    else if (typeof input !== 'object') {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n\n\n    if (this.indexers.length > 0) {\n      if (input instanceof Object && Array.isArray(input)) {\n        yield[path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      yield* collectErrorsWithIndexers(this, validation, path, input);\n    }\n    else {\n      yield* collectErrorsWithoutIndexers(this, validation, path, input);\n    }\n    if (this.exact) {\n      yield* collectErrorsExact(this, validation, path, input);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    if (input === null) {\n      return false;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        return false;\n      }\n    }\n    else if (typeof input !== 'object') {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = acceptsWithIndexers(this, input);\n    }\n    else {\n      result = acceptsWithoutIndexers(this, input);\n    }\n    if (result && this.exact) {\n      result = acceptsExact(this, input);\n    }\n    endValidationCycle(this, input);\n    return result;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n      return -1;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    let isGreater = false;\n    if (hasCallProperties) {\n      const result = compareTypeCallProperties(this, (input: $FlowFixme));\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = compareTypeWithIndexers(this, (input: $FlowFixme));\n    }\n    else {\n      result = compareTypeWithoutIndexers(this, (input: $FlowFixme));\n    }\n\n    if (result === -1) {\n      return -1;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return result;\n    }\n  }\n\n  toString (): string {\n    const {callProperties, properties, indexers} = this;\n    if (inToStringCycle(this)) {\n      return '$Cycle<Object>';\n    }\n    startToStringCycle(this);\n    const body = [];\n    for (let i = 0; i < callProperties.length; i++) {\n      body.push(callProperties[i].toString());\n    }\n    for (let i = 0; i < properties.length; i++) {\n      body.push(properties[i].toString());\n    }\n    for (let i = 0; i < indexers.length; i++) {\n      body.push(indexers[i].toString());\n    }\n    endToStringCycle(this);\n    if (this.exact) {\n      return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n    }\n    else {\n      return `{\\n${indent(body.join('\\n'))}\\n}`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      callProperties: this.callProperties,\n      properties: this.properties,\n      indexers: this.indexers,\n      exact: this.exact\n    };\n  }\n}\n\nfunction acceptsCallProperties (type: ObjectType<any>, input: any): boolean {\n  const {callProperties} = type;\n  for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nfunction compareTypeCallProperties (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {callProperties} = type;\n  const inputCallProperties = input.callProperties;\n  let identicalCount = 0;\n  loop: for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n\n    for (let j = 0; j < inputCallProperties.length; j++) {\n      const inputCallProperty = inputCallProperties[j];\n      const result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      }\n      else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  }\n  else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {indexers, properties} = type;\n  const inputIndexers = input.indexers;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (let i = 0; i < indexers.length; i++) {\n    const indexer = indexers[i];\n    for (let j = 0; j < inputIndexers.length; j++) {\n      const inputIndexer = inputIndexers[j];\n      const result = compareTypes(indexer, inputIndexer);\n      if (result === 1) {\n        isGreater = true;\n        continue loop;\n      }\n      else if (result === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction acceptsWithoutIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction acceptsExact (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (const key in input) { // eslint-disable-line guard-for-in\n    if (!properties.some(property => property.key === key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {properties} = type;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction *collectErrorsWithIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    yield [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n  }\n}\n\n\nfunction *collectErrorsWithoutIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n  }\n}\n\n\nfunction *collectErrorsExact (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (const key in input) { // eslint-disable-line guard-for-in\n    if (!properties.some(property => property.key === key)) {\n      yield [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n    }\n  }\n}\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\n\nimport ObjectType from './ObjectType';\nimport type {Property} from './ObjectType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class IntersectionType<T: {}> extends Type {\n  typeName: string = 'IntersectionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path, input);\n    }\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty <K: string | number> (key: K): ? Property<K, any> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = length - 1; i >= 0; i--) {\n      const type = types[i];\n      if (typeof type.getProperty === 'function') {\n        const prop = type.getProperty(key);\n        if (prop) {\n          return prop;\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    let identicalCount = 0;\n    if (input instanceof IntersectionType) {\n      const inputTypes = input.types;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const result = compareTypes(type, input);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 0) {\n          identicalCount++;\n        }\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n  }\n\n  unwrap (): ObjectType<T> {\n    const callProperties = [];\n    const properties = [];\n    const indexers = [];\n    const {types, context} = this;\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      invariant(type instanceof ObjectType, 'Can only intersect object types');\n      callProperties.push(...type.callProperties);\n      indexers.push(...type.indexers);\n      mergeProperties(properties, type.properties);\n    }\n    return (context: any).object(\n      ...callProperties,\n      ...properties,\n      ...indexers\n    );\n  }\n\n  toString (): string {\n    return this.types.join(' & ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\nfunction getPropertyIndex <K: string | number, V> (name: K, properties: ObjectTypeProperty<*, V>[]): number {\n  for (let i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties <K: string | number, V> (target: ObjectTypeProperty<K, V>[], source: ObjectTypeProperty<K, V>[]): ObjectTypeProperty<K, V>[] {\n  for (let i = 0; i < source.length; i++) {\n    const typeProp = source[i];\n    const index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    }\n    else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class MixedType extends Type {\n  typeName: string = 'MixedType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  toString (): string {\n    return 'mixed';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumericLiteralType<T: number> extends Type {\n  typeName: string = 'NumericLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumericLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return `${this.value}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport NumericLiteralType from './NumericLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumberType extends Type {\n  typeName: string = 'NumberType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'number') {\n      yield [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'number';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumberType) {\n      return 0;\n    }\n    else if (input instanceof NumericLiteralType) {\n      return 1;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'number';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeCreator} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport TypeAlias from './TypeAlias';\nimport PartialType from './PartialType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport {constraintsAccept} from '../typeConstraints';\n\n\nexport default class ParameterizedTypeAlias <T: Type> extends TypeAlias {\n  typeName: string = 'ParameterizedTypeAlias';\n\n  typeCreator: TypeCreator<T>;\n\n  get properties () {\n    return getPartial(this).type.properties;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    const partial = getPartial(this, ...typeInstances);\n    if (!partial.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(getPartial(this), input);\n    }\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name, ...typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name, ...typeInstances);\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const partial = getPartial(this);\n    const {typeParameters} = partial;\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n\n    const {name} = this;\n    const identifier = typeParameters.length > 0\n                     ? `${name}<${items.join(', ')}>`\n                     : name\n                     ;\n\n    if (withDeclaration) {\n      return `type ${identifier} = ${partial.toString()};`;\n    }\n    else {\n      return identifier;\n    }\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <T> (parent: ParameterizedTypeAlias<T>, ...typeInstances: Type<any>[]): PartialType<T> {\n\n  const {typeCreator, context, name} = parent;\n  const partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport PartialType from './PartialType';\nimport type FunctionTypeParam from './FunctionTypeParam';\nimport type FunctionTypeRestParam from './FunctionTypeRestParam';\nimport type FunctionTypeReturn from './FunctionTypeReturn';\nimport type TypeParameter from './TypeParameter';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type FunctionBodyCreator <P, R> = (partial: PartialType<(...params: P[]) => R>) => Array<FunctionTypeParam<P> | FunctionTypeRestParam<P> | FunctionTypeReturn<R>>;\n\n\nexport default class ParameterizedFunctionType <X, P: any, R: any> extends Type {\n  typeName: string = 'ParameterizedFunctionType';\n  bodyCreator: FunctionBodyCreator<P, R>;\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  get params (): FunctionTypeParam<P>[] {\n    return getPartial(this).type.params;\n  }\n\n  get rest (): ? FunctionTypeRestParam<P> {\n    return getPartial(this).type.rest;\n  }\n\n  get returnType (): Type<R> {\n    return getPartial(this).type.returnType;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getPartial(this), input);\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    return getPartial(this).type.acceptsParams(...args);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return getPartial(this).type.acceptsReturn(input);\n  }\n\n  assertParams <T> (...args: T[]): T[] {\n    return getPartial(this).type.assertParams(...args);\n  }\n\n  assertReturn <T> (input: T): T {\n    return getPartial(this).type.assertReturn(input);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<(...params: P[]) => R | any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (): string {\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return type.toString();\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    return `<${items.join(', ')}> ${type.toString()}`;\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <X, P, R> (parent: ParameterizedFunctionType<X, P, R>, ...typeInstances: Type<any>[]): PartialType<(...params: P[]) => R> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  partial.type = context.function(...body);\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n","\nimport Type from './Type';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class RefinementType<T> extends Type {\n  typeName: string = 'RefinementType';\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): RefinementType<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `$Refinment<${type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringLiteralType<T: string> extends Type {\n  typeName: string = 'StringLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return JSON.stringify(this.value);\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport StringLiteralType from './StringLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringType extends Type {\n  typeName: string = 'StringType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'string') {\n      yield [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'string';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType) {\n      return 1;\n    }\n    else if (input instanceof StringType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'string';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from '../getErrorMessage';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolLiteralType<T: Symbol> extends Type {\n  typeName: string = 'SymbolLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return `typeof ${String(this.value)}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport SymbolLiteralType from './SymbolLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolType extends Type {\n  typeName: string = 'SymbolType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIssue 252\n    if (typeof input !== 'symbol') {\n      yield [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'symbol';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType) {\n      return 1;\n    }\n    else if (input instanceof SymbolType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'Symbol';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport getErrorMessage from \"../getErrorMessage\";\n\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\nexport default class ThisType<T> extends Type {\n  typeName: string = 'ThisType';\n\n  recorded: ? T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {recorded} = this;\n    if (input === recorded) {\n      return;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return;\n    }\n    else if (recorded != null) {\n      yield [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {recorded} = this;\n    if (input === recorded) {\n      return true;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return true;\n    }\n    else if (recorded != null) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ThisType)) {\n      return -1;\n    }\n    else if (input.recorded && this.recorded) {\n      return input.recorded === this.recorded ? 0 : -1;\n    }\n    else if (this.recorded) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (withBinding?: boolean): string {\n    return 'this';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeBox<T: any> extends Type {\n  typeName: string = 'TypeBox';\n\n  reveal: TypeRevealer<T>;\n\n  get name (): ? string {\n    return (this.type: any).name;\n  }\n\n  get type (): Type<T> {\n    const {reveal} = this;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(this)) {\n        this.context.emitWarningMessage('Failed to reveal boxed type.');\n        warnedInstances.add(this);\n      }\n      return this.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return this.context.ref(type);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this.type;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return this.type.toString();\n  }\n\n  toJSON () {\n    return this.type.toJSON();\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport compareTypes from '../compareTypes';\n\nconst warnedMissing = {};\n\nexport default class TypeReference<T: any> extends Type {\n  typeName: string = 'TypeReference';\n  name: string;\n\n  get type (): Type<T> {\n    const {context, name} = this;\n    const type = context.get(name);\n    if (!type) {\n      if (!warnedMissing[name]) {\n        context.emitWarningMessage(`Cannot resolve type: ${name}`);\n        warnedMissing[name] = true;\n      }\n      return (context.any(): any);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return (this.type.unwrap(): any);\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nconst RevealedName = Symbol('RevealedName');\nconst RevealedValue = Symbol('RevealedValue');\n\nexport default class TypeTDZ<T: any> extends Type {\n  typeName: string = 'TypeTDZ';\n\n  reveal: TypeRevealer<T>;\n\n  // @flowIssue 252\n  [RevealedName]: ? string = undefined;\n\n  // @flowIssue 252\n  [RevealedValue]: ? Type<T> = undefined;\n\n  get name (): ? string {\n    let name = (this: any)[RevealedName];\n    if (!name) {\n      name = (getRevealed(this): any).name;\n    }\n    return name;\n  }\n\n  set name (value: string) {\n    (this: any)[RevealedName] = value;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* getRevealed(this).errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return getRevealed(this).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getRevealed(this), input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = getRevealed(this);\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return getRevealed(this).unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    return getRevealed(this).toString();\n  }\n\n  toJSON () {\n    return getRevealed(this).toJSON();\n  }\n}\n\nfunction getRevealed <T: any> (container: TypeTDZ<T>): Type<T> {\n  const existing = (container: $FlowIssue<252>)[RevealedValue];\n  if (existing) {\n    return existing;\n  }\n  else {\n    const {reveal} = container;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(container)) {\n        const name = (container: any)[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage(`Failed to reveal type called \"${name}\" in Temporal Dead Zone.`);\n        }\n        else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances.add(container);\n      }\n      return container.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport compareTypes from '../compareTypes';\n\nexport default class UnionType<T> extends Type {\n  typeName: string = 'UnionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return;\n      }\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    if (input instanceof UnionType) {\n      const inputTypes = input.types;\n      let identicalCount = 0;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n\n      if (identicalCount === types.length) {\n        return 0;\n      }\n      else {\n        return 1;\n      }\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (compareTypes(type, input) >= 0) {\n          return 1;\n        }\n      }\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {types} = this;\n    const normalized = new Array(types.length);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i];\n      if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n        normalized[i] = `(${type.toString()})`;\n      }\n      else {\n        normalized[i] = type.toString();\n      }\n    }\n    return normalized.join(' | ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nimport type {\n  Type,\n  ArrayType,\n  ObjectType\n} from './types';\n\ntype Inferred = Map<Object, Type<any>>;\n\nexport class TypeInferer {\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  infer <T> (input: T): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    const inferred = new Map();\n    return this.inferComplex(input, inferred);\n  }\n\n  inferInternal <T> (input: T, inferred: Inferred): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    return this.inferComplex(input, inferred);\n  }\n\n  inferPrimitive <T> (input: T): ? Type<T> {\n    const {context} = this;\n    if (input === null) {\n      return (context.null(): any);\n    }\n    else if (input === undefined) {\n      return (context.void(): any);\n    }\n    else if (typeof input === 'number') {\n      return (context.number(): any);\n    }\n    else if (typeof input === 'boolean') {\n      return (context.boolean(): any);\n    }\n    else if (typeof input === 'string') {\n      return (context.string(): any);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return context.symbol((input: any));\n    }\n    else {\n      return undefined;\n    }\n  }\n\n  inferComplex <T> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n\n    if (typeof input === 'function') {\n      return (this.inferFunction(input, inferred): any);\n    }\n    else if (input !== null && typeof input === 'object') {\n      return (this.inferObject(input, inferred): any);\n    }\n    else {\n      return (context.any(): any);\n    }\n  }\n\n  inferFunction <T: Function> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n    const {length} = input;\n    const body = new Array(length + 1);\n    for (let i = 0; i < length; i++) {\n      body[i] = context.param(\n        String.fromCharCode(97 + i),\n        context.existential()\n      );\n    }\n    body[length] = context.return(context.existential());\n    return (context.fn(...body): any);\n  }\n\n  inferObject <T: Object> (input: T, inferred: Inferred): Type<T> {\n    const existing = inferred.get(input);\n    if (existing) {\n      return existing;\n    }\n    const {context} = this;\n    let type;\n\n    // Temporarily create a box for this type to catch cyclical references.\n    // Nested references to this object will receive the boxed type.\n    const box = context.box(() => type);\n    inferred.set(input, box);\n\n    if (context.checkPredicate('Array', input)) {\n      type = this.inferArray((input: any), inferred);\n    }\n    else if (!(input instanceof Object)) {\n      type = this.inferDict(input, inferred);\n    }\n    else if (input.constructor !== Object) {\n      const handler = context.getTypeConstructor(input.constructor);\n      if (handler) {\n        const typeParameters = handler.inferTypeParameters(input);\n        type = handler.apply(...typeParameters);\n      }\n      else {\n        type = context.ref(input.constructor);\n      }\n    }\n    else {\n      const body = [];\n      for (const key in input) { // eslint-disable-line\n        const value = input[key];\n        body.push(context.property(key, this.inferInternal(value, inferred)));\n      }\n      type = context.object(...body);\n    }\n\n    // Overwrite the box with the real value.\n    inferred.set(input, type);\n    return (type: any);\n  }\n\n  inferDict <T: Object> (input: T, inferred: Inferred): ObjectType<T> {\n    const numericIndexers = [];\n    const stringIndexers = [];\n    loop: for (const key in input) { // eslint-disable-line\n      const value = input[key];\n      const types = isNaN(+key) ? stringIndexers : numericIndexers;\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (type.accepts(value)) {\n          continue loop;\n        }\n      }\n      types.push(this.inferInternal(value, inferred));\n    }\n\n    const {context} = this;\n    const body = [];\n    if (numericIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          numericIndexers[0]\n        )\n      );\n    }\n    else if (numericIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          context.union(...numericIndexers)\n        )\n      );\n    }\n\n    if (stringIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          stringIndexers[0]\n        )\n      );\n    }\n    else if (stringIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          context.union(...stringIndexers)\n        )\n      );\n    }\n\n    return context.object(...body);\n  }\n\n  inferArray <T> (input: T[], inferred: Inferred): ArrayType<T> {\n    const {context} = this;\n    const types = [];\n    const values = [];\n    const {length} = input;\n    loop: for (let i = 0; i < length; i++) {\n      const item = input[i];\n      const inferredType = this.inferInternal(item, inferred);\n      for (let j = 0; j < types.length; j++) {\n        const type = types[j];\n        if (type.accepts(item) && inferredType.accepts(values[j])) {\n          continue loop;\n        }\n      }\n      types.push(inferredType);\n      values.push(item);\n    }\n    if (types.length === 0) {\n      return (context.array(context.any()): any);\n    }\n    else if (types.length === 1) {\n      return context.array(types[0]);\n    }\n    else {\n      return context.array(context.union(...types));\n    }\n  }\n\n}\n\nexport default TypeInferer;","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeWarningMessage <T> (validation: Validation<T>): ? string {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  return `Warning: ${collected.join(delimiter)}`;\n}\n","/* @flow */\n\nimport UnionType from './types/UnionType';\nimport compareTypes from './compareTypes';\n\nimport AnyType from './types/AnyType';\nimport MixedType from './types/MixedType';\nimport ExistentialType from './types/ExistentialType';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\n\nexport default function makeUnion <T> (context: TypeContext, types: Type<T>[]): Type<T> {\n  const length = types.length;\n  const merged = [];\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return (type: $FlowFixme);\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    }\n    else {\n      merged.push(type);\n    }\n  }\n  const union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes (aTypes: Type<any>[], bTypes: Type<any>[]): void {\n  loop: for (let i = 0; i < bTypes.length; i++) {\n    const bType = bTypes[i];\n    for (let j = 0; j < aTypes.length; j++) {\n      const aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}","/* @flow */\n\nimport type Type from './types/Type';\n\ntype ValueDescriptor<T> = {\n  writable: boolean;\n  initializer?: () => T;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\ntype AccessorDescriptor<T> = {\n  get: () => ? T;\n  set: (value: T) => void;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\nexport type Descriptor<T>\n = AccessorDescriptor<T>\n | ValueDescriptor<T>\n ;\n\ntype TypeSource<T>\n = (() => Type<T>)\n | Type<T>\n ;\n\nexport function makePropertyDescriptor <O: {} | Function, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: Descriptor<T>, shouldAssert: boolean): ? Descriptor<T> {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, (descriptor: $FlowIssue<AccessorDescriptor<T>>), shouldAssert);\n  }\n  else {\n    return propertyToAccessor(typeSource, input, propertyName, (descriptor: $FlowIssue<ValueDescriptor<T>>), shouldAssert);\n  }\n}\n\nfunction makePropertyName (name: string): string {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName (input: Function | Object): string {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  }\n  else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  }\n  else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType <T> (receiver: any, typeSource: TypeSource<T>): Type<T> {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  }\n  else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: ValueDescriptor<T>, shouldAssert: boolean): AccessorDescriptor<T> {\n  const safeName = makePropertyName(propertyName);\n  const className = getClassName(input);\n  const {initializer, writable, ...config} = descriptor; // eslint-disable-line no-unused-vars\n\n  const propertyPath = [className, propertyName];\n\n  return {\n    ...config,\n    type: 'accessor',\n    get (): ? T {\n      if (safeName in this) {\n        return (this: any)[safeName];\n      }\n      else if (initializer) {\n        const type = resolveType(this, typeSource);\n        const value = initializer.call(this);\n        const context = type.context;\n        context.check(type, value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n        return value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set (value: T): void {\n      const type = resolveType(this, typeSource);\n      const context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      }\n      else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  };\n}\n\nfunction augmentExistingAccessors <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: AccessorDescriptor<T>, shouldAssert: boolean) {\n\n  const className = getClassName(input);\n  const propertyPath = [className, propertyName];\n\n  const originalSetter = descriptor.set;\n\n  descriptor.set = function set (value: T): void {\n    const type = resolveType(this, typeSource);\n    const context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    }\n    else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n\n}\n\n","/* @flow */\n\nimport Type from './types/Type';\n\nimport {TypeSymbol} from './symbols';\n\nexport type Decorator<T> = (input: T) => T;\n\ndeclare function annotateValue <T> (type: Type<T>): Decorator<T>;\ndeclare function annotateValue <T> (input: T, type: Type<T>): T; // eslint-disable-line no-redeclare\n\nexport default function annotateValue (input, type?) { // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  }\n  else {\n    const type = input;\n    return (input) => {\n      input[TypeSymbol] = type;\n      return input;\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nexport default class $DiffType<A: {}, B: {}> extends Type<$Diff<A, B>> {\n  typeName: string = '$DiffType';\n\n  aType: Type<A>;\n  bType: Type<B>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      yield* property.errors(validation, path.concat(property.key), input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      if (!property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Diff<A, B>> {\n    let {aType, bType} = this;\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    const args = [];\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      args.push(property);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      aType: this.aType,\n      bType: this.bType\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $FlowFixMeType extends Type<any> {\n  typeName: string = '$FlowFixMeType';\n\n  *errors (validation: Validation<any>, input: any, path: IdentifierPath = []): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  unwrap (): Type<any> {\n    return this;\n  }\n\n  toString (): string {\n    return '$FlowFixMe';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $KeysType<T: {}> extends Type<$Keys<T>> {\n  typeName: string = '$KeysType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return;\n      }\n    }\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      keys[i] = properties[i].key;\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Keys<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      keys[i] = context.literal(property.key);\n    }\n    return this.context.union(...keys);\n  }\n\n  toString (): string {\n    return `$Keys<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys and values in an object.\n\nexport default class $ObjMapiType<O: {}, M: Mapper> extends Type<$ObjMapi<O, M>> {\n  typeName: string = '$ObjMapiType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMapi<O, M>> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key), prop.value)\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys in an object.\n\nexport default class $ObjMapType<O: {}, M: Mapper> extends Type<$ObjMap<O, M>> {\n  typeName: string = '$ObjMapType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMap<O, M>> {\n\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key))\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The type of the named object property\n\nexport default class $PropertyType<O: {}, P: string | number | Symbol> extends Type {\n  typeName: string = '$PropertyType';\n\n  object: Type<O>;\n\n  property: P;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.unwrap().errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.unwrap().accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<*> {\n    const {object, property} = this;\n    const unwrapped = object.unwrap();\n    invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n    return unwrapped.getProperty(property).unwrap();\n  }\n\n  toString (): string {\n    return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      property: this.property\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nexport default class $ShapeType<T> extends Type<$Shape<T>> {\n  typeName: string = '$ShapeType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {type} = this;\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property) {\n        continue;\n      }\n      yield* property.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {type} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property || !property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Shape<T>> {\n    let {type} = this;\n    type = type.unwrap();\n    const context = this.context;\n    invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n    const properties = type.properties;\n    const args = new Array(properties.length);\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      args[i] = context.property(property.key, property.value, true);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Shape<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $SubType<T> extends Type<$Subtype<T>> {\n  typeName: string = '$SubType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(input, path);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Subtype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Subtype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any, but at least T.\n\nexport default class $SuperType<T> extends Type<$Supertype<T>> {\n  typeName: string = '$SuperType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Supertype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Supertype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport TupleType from '../types/TupleType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the values in a tuple.\n\nexport default class $TupleMapType<T: [], M: Mapper> extends Type<$TupleMap<T, M>> {\n  typeName: string = '$TupleMapType';\n\n  tuple: Type<T>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const expected = applied.invoke(type);\n      const value = input[i];\n      yield* expected.errors(validation, path.concat(i), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      if (!applied.invoke(type).accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$TupleMap<T, M>> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n    const args = [];\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(applied.invoke(type).unwrap().unwrap());\n    }\n\n    return context.tuple(...args);\n  }\n\n  toString (): string {\n    return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      tuple: this.tuple,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $ValuesType<T: {}> extends Type<$Values<T>> {\n  typeName: string = '$ValuesType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.value.accepts(input)) {\n        return;\n      }\n    }\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      values[i] = properties[i].value.toString();\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', values.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.value.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Values<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      values[i] = property.value;\n    }\n    return context.union(...values);\n  }\n\n  toString (): string {\n    return `$Values<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport GenericType from '../types/GenericType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nfunction checkGenericType (context: TypeContext, expected: GenericType, input: Function) {\n  const {impl} = expected;\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  }\n  else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  const annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  }\n  else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType (context: TypeContext, expected: Type<*>, input: Function) {\n  const annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    const result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\n\nexport default class ClassType<T> extends Type {\n  typeName: string = 'ClassType';\n\n  instanceType: Type<*>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n      return;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    const isValid = (\n      expectedType instanceof GenericType\n      ? checkGenericType(context, expectedType, input)\n      : checkType(context, expectedType, input)\n    );\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    if (expectedType instanceof GenericType) {\n      return checkGenericType(context, expectedType, input);\n    }\n    else {\n      return checkType(context, expectedType, input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {instanceType} = this;\n    if (input instanceof ClassType) {\n      return compareTypes(instanceType, input.instanceType);\n    }\n    return -1;\n  }\n\n  toString (): string {\n    return `Class<${this.instanceType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      instanceType: this.instanceType\n    };\n  }\n}","/* @flow */\n\nimport TypeInferrer from './TypeInferrer';\nimport primitiveTypes from './primitiveTypes';\nimport invariant from './invariant';\n\nimport Validation from './Validation';\n\nimport makeReactPropTypes from './makeReactPropTypes';\n\nimport makeJSONError from './errorReporting/makeJSONError';\nimport makeTypeError from './errorReporting/makeTypeError';\nimport makeWarningMessage from './errorReporting/makeWarningMessage';\n\nimport makeUnion from './makeUnion';\nimport compareTypes from './compareTypes';\nimport {makePropertyDescriptor} from './classDecorators';\n\nimport {flowIntoTypeParameter} from './types/TypeParameter';\n\nimport annotateValue from './annotateValue';\n\nimport type {PropTypeDict} from './makeReactPropTypes';\nimport type {IdentifierPath, ErrorTuple} from './Validation';\n\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType\n} from './types';\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport {\n  $DiffType,\n  $FlowFixMeType,\n  $KeysType,\n  $ObjMapiType,\n  $ObjMapType,\n  $PropertyType as _$PropertyType,\n  $ShapeType,\n  $SubType,\n  $SuperType,\n  $TupleMapType,\n  $ValuesType,\n  ClassType\n} from './flowTypes';\n\nimport {\n  ParentSymbol,\n  NameRegistrySymbol,\n  ModuleRegistrySymbol,\n  CurrentModuleSymbol,\n  TypeConstructorRegistrySymbol,\n  TypeParametersSymbol,\n  InferrerSymbol,\n  TypePredicateRegistrySymbol,\n  TypeSymbol\n} from './symbols';\n\nimport type {\n  TypeConstraint,\n  TypeCreator,\n  TypeRevealer,\n  FunctionBodyCreator,\n  ApplicableType,\n  ValidFunctionBody,\n  ObjectPropertyDict,\n  ValidObjectBody\n} from './types';\n\nimport type {\n  ClassBodyCreator,\n  ValidClassBody\n} from './declarations';\n\nexport type TypeConstructorConfig = {\n  name: string;\n  impl?: Function;\n  typeName: string;\n  compareWith?: (Type<any>) => -1 | 0 | 1;\n  errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void>;\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean;\n  inferTypeParameters (input: any): Type<any>[];\n};\n\nexport type TypePredicate = (input: any) => boolean;\n\ntype NameRegistry = {\n  [name: string]: Type<any> | Class<TypeConstructor<any>>;\n};\n\ntype TypePredicateRegistry = {\n  [name: string]: TypePredicate;\n};\n\ntype ModuleRegistry = {\n  [name: string]: ModuleDeclaration;\n};\n\ntype TypeConstructorRegistry = Map<Function, Class<TypeConstructor<any>>>;\n\nexport type MatchClause<P, R> = (...params: P[]) => R;\nexport type PatternMatcher<P, R> = (...params: P[]) => R;\n\nexport type CheckMode\n  = 'assert'\n  | 'warn'\n  ;\n\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nconst warnedInvalidReferences: WeakSet<any> = new WeakSet();\n\nexport default class TypeContext {\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n  mode: CheckMode = 'assert';\n\n  // @flowIssue 252\n  [ParentSymbol]: ? TypeContext;\n\n  // @flowIssue 252\n  [NameRegistrySymbol]: NameRegistry = {};\n\n  // @flowIssue 252\n  [TypePredicateRegistrySymbol]: TypePredicateRegistry = {};\n\n  // @flowIssue 252\n  [TypeConstructorRegistrySymbol]: TypeConstructorRegistry = new Map();\n\n  // @flowIssue 252\n  [InferrerSymbol]: TypeInferrer = new TypeInferrer(this);\n\n  // @flowIssue 252\n  [ModuleRegistrySymbol]: ModuleRegistry = {};\n\n  // @flowIssue 252\n  [CurrentModuleSymbol]: ? ModuleDeclaration;\n\n  get TypeParametersSymbol (): typeof TypeParametersSymbol {\n    return TypeParametersSymbol;\n  }\n\n\n  makeJSONError <T> (validation: Validation<T>): ? Array<Object> {\n    return makeJSONError(validation);\n  }\n\n  makeTypeError <T> (validation: Validation<T>): ? TypeError {\n    return makeTypeError(validation);\n  }\n\n  createContext (): TypeContext {\n    const context = new TypeContext();\n    // @flowIssue 252\n    context[ParentSymbol] = this;\n    return context;\n  }\n\n  typeOf <T> (input: T): Type<T> {\n\n    const annotation = this.getAnnotation(input);\n    if (annotation) {\n      if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n        return this.Class(annotation);\n      }\n      return annotation;\n    }\n    // @flowIssue 252\n    const inferrer = this[InferrerSymbol];\n    (inferrer: TypeInferrer);\n\n    return inferrer.infer(input);\n  }\n\n  compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n    return compareTypes(a, b);\n  }\n\n  get (name: string, ...propertyNames: string[]): ? Type<any> {\n    // @flowIssue 252\n    const item = this[NameRegistrySymbol][name];\n    if (item != null) {\n      let current = typeof item === 'function'\n                  ? new item(this)\n                  : item\n                  ;\n      for (let i = 0; i < propertyNames.length; i++) {\n        const propertyName = propertyNames[i];\n        if (typeof current.getProperty !== 'function') {\n          return;\n        }\n        current = current.getProperty(propertyName);\n        if (!current) {\n          return;\n        }\n        current = current.unwrap();\n      }\n      return current;\n    }\n    // @flowIssue 252\n    const parent = this[ParentSymbol];\n    if (parent) {\n      const fromParent = parent.get(name, ...propertyNames);\n      if (fromParent) {\n        return fromParent;\n      }\n    }\n\n    // if we got this far, see if we have a global type with this name.\n    if (typeof global[name] === 'function') {\n      const target = new GenericType(this);\n      target.name = name;\n      target.impl = global[name];\n      // @flowIssue 252\n      this[NameRegistrySymbol][name] = target;\n      return target;\n    }\n  }\n\n  /**\n   * Get the predicate for a given type name.\n   * e.g. `t.getPredicate('Array')`.\n   */\n  getPredicate (name: string): ? TypePredicate {\n    const item: ? TypePredicate = (this: any)[TypePredicateRegistrySymbol][name];\n    if (item) {\n      return item;\n    }\n    const parent: ? TypeContext = (this: any)[ParentSymbol];\n    if (parent) {\n      return parent.getPredicate(name);\n    }\n  }\n\n  /**\n   * Set the predicate for a given type name.\n   * This can be used to customise the behaviour of things like Array\n   * detection or allowing Thenables in place of the global Promise.\n   */\n  setPredicate (name: string, predicate: TypePredicate) {\n    (this: any)[TypePredicateRegistrySymbol][name] = predicate;\n  }\n\n  /**\n   * Check the given value against the named predicate.\n   * Returns false if no such predicate exists.\n   * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n   */\n  checkPredicate (name: string, input: any): boolean {\n    const predicate = this.getPredicate(name);\n    if (predicate) {\n      return predicate(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns a decorator for a function or object with the given type.\n   */\n  decorate (type: (() => Type<any>) | Type<any>, shouldAssert?: boolean): * {\n    if (shouldAssert == null) {\n      shouldAssert = this.mode === 'assert';\n    }\n    return (input: Object | Function, propertyName?: string, descriptor?: Object): * => {\n      if (descriptor && typeof propertyName === 'string') {\n        return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n      }\n      else {\n        invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n        return this.annotate(input, type);\n      }\n    };\n  }\n\n  /**\n   * Annotates an object or function with the given type.\n   * If a type is specified as the sole argument, returns a\n   * function which can decorate classes or functions with the given type.\n   */\n  annotate <T> (input: Type<T> | T, type?: Type<T>) {\n    if (type === undefined) {\n      return annotateValue(input);\n    }\n    else {\n      return annotateValue(input, type);\n    }\n  }\n\n  getAnnotation <T> (input: T): ? Type<T> {\n    if ((input !== null && typeof input === 'object') || typeof input === 'function') {\n      // @flowIssue 252\n      return input[TypeSymbol];\n    }\n  }\n\n  hasAnnotation (input: any): boolean {\n    if (input == null) {\n      return false;\n    }\n    else {\n      return input[TypeSymbol] ? true : false;\n    }\n  }\n\n  setAnnotation <T: Object | Function> (input: T, type: Type<T>): T {\n    input[TypeSymbol] = type;\n    return input;\n  }\n\n  type <T> (name: string, type: Type<T> | TypeCreator<Type<T>>): TypeAlias<T> | ParameterizedTypeAlias<T> {\n    if (typeof type === 'function') {\n      const target = new ParameterizedTypeAlias(this);\n      target.name = name;\n      target.typeCreator = type;\n      return target;\n    }\n    else {\n      const target = new TypeAlias(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }\n\n  declare <T: any, D: ModuleDeclaration | TypeDeclaration<T> | VarDeclaration<T> | ClassDeclaration<T>> (name: string | D, type?: Type<T> | TypeCreator<Type<T>>): D | TypeDeclaration<T> {\n\n    if (name instanceof Declaration) {\n      type = name;\n      name = type.name;\n    }\n    else if (name instanceof TypeAlias) {\n      type = name;\n      name = type.name;\n    }\n    if (typeof type === 'function') {\n      type = this.type(name, type);\n    }\n    if (type instanceof ModuleDeclaration) {\n      const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n      moduleRegistry[name] = type;\n      return type;\n    }\n    else {\n      invariant(typeof name === 'string', 'Name must be a string');\n      invariant(type instanceof Type, 'Type must be supplied to declaration');\n      const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n      if (type instanceof Declaration) {\n        nameRegistry[name] = type;\n        return type;\n      }\n      else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n        const target = new TypeDeclaration(this);\n        target.name = name;\n        target.typeAlias = type;\n        nameRegistry[name] = target;\n        return target;\n      }\n      else {\n        const target = this.var(name, type);\n        nameRegistry[name] = target;\n        return target;\n      }\n    }\n  }\n\n  *declarations (): Generator<[string, Type<any> | TypeConstructor<any>], void, void> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n    for (const key in nameRegistry) { // eslint-disable-line guard-for-in\n      yield [key, nameRegistry[key]];\n    }\n  }\n\n  *modules (): Generator<ModuleDeclaration, void, void> {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    for (const key in moduleRegistry) { // eslint-disable-line guard-for-in\n      yield moduleRegistry[key];\n    }\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    if (moduleRegistry[moduleName]) {\n      return moduleRegistry[moduleName];\n    }\n    const [head] = moduleName.split('/');\n    const module = moduleRegistry[head];\n    if (module) {\n      return module.import(moduleName);\n    }\n    const parent = (this: $FlowIssue<252>)[ParentSymbol];\n    if (parent) {\n      return parent.import(moduleName);\n    }\n  }\n\n  declareTypeConstructor ({name, impl, typeName, errors, accepts, inferTypeParameters, compareWith}: TypeConstructorConfig): TypeConstructor<any> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n    if (nameRegistry[name]) {\n      this.emitWarningMessage(`Redeclaring type: ${name}, this may be unintended.`);\n    }\n\n    const target = new TypeConstructor(this);\n    target.name = name;\n    target.typeName = typeName;\n    target.impl = impl;\n    target.errors = errors;\n    target.accepts = accepts;\n    target.inferTypeParameters = inferTypeParameters;\n    if (typeof compareWith === 'function') {\n      target.compareWith = compareWith;\n    }\n\n    nameRegistry[name] = target;\n\n    if (typeof impl === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      if (handlerRegistry.has(impl)) {\n        this.emitWarningMessage(`A type handler already exists for the given implementation of ${name}.`);\n      }\n      handlerRegistry.set(impl, target);\n    }\n    return target;\n  }\n\n  getTypeConstructor (impl: Function): ? TypeConstructor<any> {\n    // @flowIssue 252\n    const handlerRegistry = this[TypeConstructorRegistrySymbol];\n    (handlerRegistry: TypeConstructorRegistry);\n\n    return handlerRegistry.get(impl);\n  }\n\n  literal <T: void | null | boolean | number | string | Symbol> (input: T): Type<T> {\n    if (input === undefined) {\n      return this.void();\n    }\n    else if (input === null) {\n      return this.null();\n    }\n    else if (typeof input === 'boolean') {\n      return this.boolean(input);\n    }\n    else if (typeof input === 'number') {\n      return this.number(input);\n    }\n    else if (typeof input === 'string') {\n      return this.string(input);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return this.symbol(input);\n    }\n    else {\n      return this.typeOf(input);\n    }\n  }\n\n  null (): NullLiteralType {\n    return primitiveTypes.null;\n  }\n\n  nullable <T> (type: Type<T>): NullableType<? T> {\n    const target = new NullableType(this);\n    target.type = type;\n    return target;\n  }\n\n  existential (): ExistentialType {\n    return primitiveTypes.existential;\n  }\n\n\n  empty (): EmptyType {\n    return primitiveTypes.empty;\n  }\n\n  any (): AnyType {\n    return primitiveTypes.any;\n  }\n\n  mixed (): MixedType {\n    return primitiveTypes.mixed;\n  }\n\n  void (): VoidType {\n    return primitiveTypes.void;\n  }\n\n  this <T> (input?: T): ThisType<T> {\n    const target = new ThisType(this);\n    if (input !== undefined) {\n      target.recorded = input;\n    }\n    return target;\n  }\n\n  number <T: number> (input?: T): NumberType | NumericLiteralType<T> {\n    if (input !== undefined) {\n      const target = new NumericLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.number;\n    }\n  }\n\n  boolean <T: boolean> (input?: T): BooleanType | BooleanLiteralType<T> {\n    if (input !== undefined) {\n      const target = new BooleanLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.boolean;\n    }\n  }\n\n  string <T: string> (input?: T): StringType | StringLiteralType<T> {\n    if (input !== undefined) {\n      const target = new StringLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.string;\n    }\n  }\n\n  symbol <T: Symbol> (input?: T): SymbolType | SymbolLiteralType<T> {\n    if (input !== undefined) {\n      const target = new SymbolLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.symbol;\n    }\n  }\n\n  typeParameter <T> (id: string, bound?: Type<T>, defaultType?: Type<T>): TypeParameter<T> {\n    const target = new TypeParameter(this);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    return target;\n  }\n\n  flowInto <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n    return flowIntoTypeParameter(typeParameter);\n  }\n\n  /**\n   * Bind the type parameters for the parent class of the given instance.\n   */\n  bindTypeParameters <T: {}> (subject: T, ...typeInstances: Type<any>[]): T {\n    const instancePrototype = Object.getPrototypeOf(subject);\n    // @flowIssue\n    const parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n    // @flowIssue\n    const parentClass = parentPrototype && parentPrototype.constructor;\n\n    if (!parentClass) {\n      this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n      return subject;\n    }\n    // @flowIssue 252\n    const typeParametersPointer = parentClass[TypeParametersSymbol];\n\n    if (typeParametersPointer) {\n      const typeParameters = subject[typeParametersPointer];\n      const keys = Object.keys(typeParameters);\n      const length = Math.min(keys.length, typeInstances.length);\n      for (let i = 0; i < length; i++) {\n        const typeParam = typeParameters[keys[i]];\n        typeParam.bound = typeInstances[i];\n      }\n    }\n    return subject;\n  }\n\n  module (name: string, body: (context: TypeContext) => any): ModuleDeclaration {\n    const target = new ModuleDeclaration(this);\n    target.name = name;\n    const innerContext = this.createContext();\n    // @flowIssue 252\n    innerContext[ParentSymbol] = this;\n    // @flowIssue 252\n    innerContext[CurrentModuleSymbol] = target;\n\n    target.innerContext = innerContext;\n    body(innerContext);\n    return target;\n  }\n\n  moduleExports <T> (type: Type<T>): ModuleExportsDeclaration<T> {\n    const currentModule: ModuleDeclaration = (this: $FlowIssue<252>)[CurrentModuleSymbol];\n    if (!currentModule) {\n      throw new Error('Cannot declare module.exports outside of a module.');\n    }\n    const target = new ModuleExportsDeclaration(this);\n    target.type = type;\n    currentModule.moduleExports = target;\n    return target;\n  }\n\n  var <T> (name: string, type: Type<T>): VarDeclaration<T> {\n    const target = new VarDeclaration(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  class <X, O: {}> (name: string, head?: ClassBodyCreator<X, O> | ValidClassBody<X, O>, ...tail: Array<ValidClassBody<X, O>>): ClassDeclaration<O> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedClassDeclaration(this);\n      target.name = name;\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new ClassDeclaration(this);\n    target.name = name;\n    if (head != null) {\n      tail.unshift(head);\n    }\n    const {length} = tail;\n    const properties = [];\n    let body;\n\n    for (let i = 0; i < length; i++) {\n      const item = tail[i];\n      if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n        properties.push(item);\n      }\n      else if (item instanceof ObjectType) {\n        invariant(!body, 'Class body must only be declared once.');\n        body = item;\n      }\n      else if (item instanceof ExtendsDeclaration) {\n        invariant(!target.superClass, 'Classes can only have one super class.');\n        target.superClass = item;\n      }\n      else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n        for (const propertyName in item) { // eslint-disable-line\n          properties.push(this.property(propertyName, (item: any)[propertyName]));\n        }\n      }\n      else {\n        throw new Error('ClassDeclaration cannot contain the given type directly.');\n      }\n    }\n    if (!body) {\n      body = new ObjectType(this);\n    }\n    if (properties.length) {\n      body.properties.push(...properties);\n    }\n    target.body = body;\n    return target;\n  }\n\n  extends <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): ExtendsDeclaration<T> {\n    const target = new ExtendsDeclaration(this);\n    target.type = this.ref(subject, ...typeInstances);\n    return target;\n  }\n\n  fn <X, P, R> (head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    return this.function(head, ...tail);\n  }\n\n  function <X, P, R> (head: ? FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedFunctionType(this);\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new FunctionType(this);\n    if (head != null) {\n      tail.unshift(head);\n      const {length} = tail;\n      for (let i = 0; i < length; i++) {\n        const item = tail[i];\n        if (item instanceof FunctionTypeParam) {\n          target.params.push(item);\n        }\n        else if (item instanceof FunctionTypeRestParam) {\n          target.rest = item;\n        }\n        else if (item instanceof FunctionTypeReturn) {\n          target.returnType = item;\n        }\n        else {\n          throw new Error('FunctionType cannot contain the given type directly.');\n        }\n      }\n    }\n    if (!target.returnType) {\n      target.returnType = this.any();\n    }\n    return target;\n  }\n\n  param <T> (name: string, type: Type<T>, optional: boolean = false): FunctionTypeParam<T> {\n    const target = new FunctionTypeParam(this);\n    target.name = name;\n    target.type = type;\n    target.optional = optional;\n    return target;\n  }\n\n  rest <T> (name: string, type: Type<T>): FunctionTypeRestParam<T> {\n    const target = new FunctionTypeRestParam(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  return <T> (type: Type<T>): FunctionTypeReturn<T> {\n    const target =  new FunctionTypeReturn(this);\n    target.type = type;\n    return target;\n  }\n\n  generator <Y, R, N> (yieldType: Type<Y>, returnType?: Type<R>, nextType?: Type<N>): GeneratorType<Y, R, N> {\n    const target = new GeneratorType(this);\n    target.yieldType = yieldType;\n    target.returnType = returnType || this.any();\n    target.nextType = nextType || this.any();\n    return target;\n  }\n\n  object <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n      for (const propertyName in head) { // eslint-disable-line\n        target.properties.push(this.property(propertyName, head[propertyName]));\n      }\n    }\n    else {\n      let body;\n      if (head) {\n        body = [head, ...tail];\n      }\n      else {\n        body = tail;\n      }\n      const {length} = body;\n      for (let i = 0; i < length; i++) {\n        const item = body[i];\n        if (item instanceof ObjectTypeProperty) {\n          target.properties.push(item);\n        }\n        else if (item instanceof ObjectTypeIndexer) {\n          target.indexers.push(item);\n        }\n        else if (item instanceof ObjectTypeCallProperty) {\n          target.callProperties.push(item);\n        }\n        else {\n          throw new Error('ObjectType cannot contain the given type directly.');\n        }\n      }\n    }\n    return target;\n  }\n\n  exactObject <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const object = this.object(head, ...tail);\n    object.exact = true;\n    return object;\n  }\n\n  callProperty <T> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const target = new ObjectTypeCallProperty(this);\n    target.value = value;\n    return target;\n  }\n\n  property <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const target = new ObjectTypeProperty(this);\n    target.key = key;\n    if (value instanceof Type) {\n      target.value = value;\n    }\n    else {\n      target.value = this.object(value);\n    }\n    target.optional = optional;\n    return target;\n  }\n\n  indexer <K, V> (id: string, key: Type<K>, value: Type<V>): ObjectTypeIndexer<K, V> {\n    const target = new ObjectTypeIndexer(this);\n    target.id = id;\n    target.key = key;\n    target.value = value;\n    return target;\n  }\n\n  method <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const target = new ObjectTypeProperty(this);\n    target.key = name;\n    target.value = this.function(head, ...tail);\n    return target;\n  }\n\n  staticCallProperty <T: Function> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const prop = this.callProperty(value);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticProperty <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const prop = this.property(key, value, optional);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticMethod <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const prop = this.method(name, head, ...tail);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  spread <T> (...types: Type<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      if (Array.isArray(type.callProperties)) {\n        target.callProperties.push(...type.callProperties);\n      }\n      if (Array.isArray(type.indexers)) {\n        target.indexers.push(...type.indexers);\n      }\n      if (Array.isArray(type.properties)) {\n        for (let j = 0; j < type.properties.length; j++) {\n          const prop = type.properties[j];\n          invariant(prop instanceof ObjectTypeProperty);\n          target.setProperty(prop.key, prop.value, prop.optional);\n        }\n      }\n    }\n    return target;\n  }\n\n  tuple <T> (...types: Type<T>[]): TupleType<any> {\n    const target = new TupleType(this);\n    target.types = types;\n    return target;\n  }\n\n  array <T> (elementType?: Type<T>): ArrayType<T> {\n    const target = new ArrayType(this);\n    target.elementType = elementType || this.any();\n    return target;\n  }\n\n  union <T> (...types: Type<T>[]): Type<T> {\n    return makeUnion(this, types);\n  }\n\n  intersect <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    const target = new IntersectionType(this);\n    target.types = types;\n    return target;\n  }\n\n  intersection <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    return this.intersect(...types);\n  }\n\n  box <T> (reveal: TypeRevealer<T>): TypeBox<T> {\n    const box = new TypeBox(this);\n    box.reveal = reveal;\n    return box;\n  }\n\n  tdz <T> (reveal: TypeRevealer<T>, name?: string): TypeTDZ<T> {\n    const tdz = new TypeTDZ(this);\n    tdz.reveal = reveal;\n    tdz.name = name;\n    return tdz;\n  }\n\n  ref <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): Type<T | any> {\n    let target;\n    if (typeof subject === 'string') {\n      // try and eagerly resolve the reference\n      target = this.get(subject);\n      if (!target) {\n        // defer dereferencing for now\n        target = new TypeReference(this);\n        target.name = subject;\n      }\n    }\n    else if (typeof subject === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      // see if we have a dedicated TypeConstructor for this.\n      target = handlerRegistry.get(subject);\n\n      if (!target) {\n        // just use a generic type handler.\n        target = new GenericType(this);\n        target.impl = subject;\n        target.name = subject.name;\n      }\n\n    }\n    else if (subject instanceof Type) {\n      target = subject;\n    }\n    else {\n      if (subject == null || typeof subject !== 'object') {\n        this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n      }\n      else if (!warnedInvalidReferences.has(subject)) {\n        this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n        warnedInvalidReferences.add(subject);\n      }\n      return this.any();\n    }\n\n    if (typeInstances.length) {\n      invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n      return target.apply(...typeInstances);\n    }\n    else {\n      return target;\n    }\n  }\n\n  validate <T> (type: Type<T>, input: any, prefix: string = '', path?: string[]): Validation<T> {\n    const validation = new Validation(this, input);\n    if (path) {\n      validation.path.push(...path);\n    }\n    else if (typeof type.name === 'string') {\n      validation.path.push(type.name);\n    }\n    validation.prefix = prefix;\n    validation.errors = Array.from(type.errors(validation, [], input));\n    return validation;\n  }\n\n  check <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    if (this.mode === 'assert') {\n      return this.assert(type, input, prefix, path);\n    }\n    else {\n      return this.warn(type, input, prefix, path);\n    }\n  }\n\n  assert <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const error = this.makeTypeError(validation);\n    if (error) {\n      throw error;\n    }\n    return input;\n  }\n\n  warn <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const message = makeWarningMessage(validation);\n    if (typeof message === 'string') {\n      this.emitWarningMessage(message);\n    }\n    return input;\n  }\n\n  /**\n   * Emits a warning message, using `console.warn()` by default.\n   */\n  emitWarningMessage (message: string): void {\n    console.warn('flow-runtime:', message);\n  }\n\n  propTypes <T: {}> (type: Type<T>): PropTypeDict<T> {\n    return makeReactPropTypes((type.unwrap(): $FlowIgnore));\n  }\n\n  match <P, R> (...args: Array<P | MatchClause<P, R>>): R {\n    const clauses: any = args.pop();\n    if (!Array.isArray(clauses)) {\n      throw new Error('Invalid pattern, last argument must be an array.');\n    }\n    (clauses: MatchClause<P, R>[]);\n    const pattern = this.pattern(...clauses);\n    return pattern(...args);\n  }\n\n  pattern <P, R> (...clauses: MatchClause<P, R>[]): PatternMatcher<P, R> {\n    const {length} = clauses;\n    const tests: Array<true | FunctionType<P, R> | ParameterizedFunctionType<any, P, R>> = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const clause = clauses[i];\n      const annotation = this.getAnnotation(clause);\n      if (!annotation) {\n        if (i !== length - 1) {\n          throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n        }\n        tests[i] = true;\n      }\n      else {\n        invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n        tests[i] = annotation;\n      }\n    }\n    return (...args: P[]): R => {\n      for (let i = 0; i < tests.length; i++) {\n        const test = tests[i];\n        const clause = clauses[i];\n        if (test === true) {\n          return clause(...args);\n        }\n        else if (test.acceptsParams(...args)) {\n          return clause(...args);\n        }\n      }\n      const error = new TypeError('Value did not match any of the candidates.');\n      error.name = 'RuntimeTypeError';\n      throw error;\n    };\n  }\n\n  wrapIterator <T> (type: Type<T>): (input: Iterable<T>) => Generator<T, void, void> {\n    const t = this;\n    return function* wrappedIterator (input: Iterable<T>): Generator<T, void, void> {\n      for (const item of input) {\n        yield t.check(type, item);\n      }\n    };\n  }\n\n  refinement <T> (type: Type<T>, ...constraints: TypeConstraint[]): RefinementType<T> {\n    const target = new RefinementType(this);\n    target.type = type;\n    target.addConstraint(...constraints);\n    return target;\n  }\n\n  $exact <T> (type: Type<T>): ObjectType<T> {\n    const target = new ObjectType(this);\n    type = type.unwrap();\n    if (Array.isArray(type.callProperties)) {\n      target.callProperties.push(...type.callProperties);\n    }\n    if (Array.isArray(type.indexers)) {\n      target.indexers.push(...type.indexers);\n    }\n    if (Array.isArray(type.properties)) {\n      target.properties.push(...type.properties);\n    }\n    target.exact = true;\n    return target;\n  }\n\n  $diff <A: {}, B: {}> (aType: Type<A>, bType: Type<B>): $DiffType<A, B> {\n    const target = new $DiffType(this);\n    target.aType = aType;\n    target.bType = bType;\n    return target;\n  }\n\n  $flowFixMe (): $FlowFixMeType {\n    return new $FlowFixMeType(this);\n  }\n\n  $keys <T: {}> (type: Type<T>): $KeysType<T> {\n    const target = new $KeysType(this);\n    target.type = type;\n    return target;\n  }\n\n  $objMap <O: {}, K: $Keys<O>, M: (k: K) => any> (object: Type<O>, mapper: Type<M>): $ObjMapType<O, M> {\n    const target = new $ObjMapType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $objMapi <O: {}, K: $Keys<O>, M: (k: K, v: any) => any> (object: Type<O>, mapper: Type<M>): $ObjMapiType<O, M> {\n    const target = new $ObjMapiType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $propertyType <O: {}, P: string | number | Symbol> (object: Type<O>, property: P | Type<P>): _$PropertyType<O, P> {\n    const target = new _$PropertyType(this);\n    target.object = object;\n    if (property instanceof Type) {\n      const unwrapped = property.unwrap();\n      target.property = (unwrapped: any).value;\n    }\n    else {\n      target.property = property;\n    }\n    return target;\n  }\n\n  $shape <T: {}> (type: Type<T>): $ShapeType<T> {\n    const target = new $ShapeType(this);\n    target.type = type;\n    return target;\n  }\n\n  $subtype <T: {}> (type: Type<T>): $SubType<T> {\n    const target = new $SubType(this);\n    target.type = type;\n    return target;\n  }\n\n  $supertype <T: {}> (type: Type<T>): $SuperType<T> {\n    const target = new $SuperType(this);\n    target.type = type;\n    return target;\n  }\n\n  $tupleMap <T: [], M: (v: *) => *> (tuple: Type<T>, mapper: Type<M>): $TupleMapType<T, M> {\n    const target = new $TupleMapType(this);\n    target.tuple = tuple;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $values <T: {}> (type: Type<T>): $ValuesType<T> {\n    const target = new $ValuesType(this);\n    target.type = type;\n    return target;\n  }\n\n  Class <T: {}> (instanceType: Type<T>): ClassType<T> {\n    const target = new ClassType(this);\n    target.instanceType = instanceType;\n    return target;\n  }\n}\n\n","/* @flow */\n\nimport makeError from './makeError';\n\nimport type ObjectType from './types/ObjectType';\n\nexport type PropType<T: {}> = (props: T, propName: string, componentName: string) => ? Error;\n\nexport type PropTypeDict<T: {}> = $ObjMap<T, <V>(v: V) => PropType<V>>;\n\nexport default function makeReactPropTypes <T: {}> (objectType: ObjectType<T>): PropTypeDict<T> {\n  const output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n  for (const property of objectType.properties) {\n    output[property.key] = (props, propName, componentName) => {\n      return makeError(property, props);\n    };\n  }\n  return output;\n}","/* @flow */\n\nimport registerPrimitiveTypes from './registerPrimitiveTypes';\nimport registerBuiltinTypeConstructors from './registerBuiltins';\nimport registerTypePredicates from './registerTypePredicates';\n\nimport TypeContext from './TypeContext';\n\nlet globalContext;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n}\nelse {\n  globalContext = new TypeContext();\n  registerPrimitiveTypes(globalContext);\n  registerBuiltinTypeConstructors(globalContext);\n  registerTypePredicates(globalContext);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext;\n  }\n}\n\n\nexport default globalContext;","/* @flow */\n\nimport primitiveTypes from './primitiveTypes';\n\nimport type TypeContext from './TypeContext';\n\nimport {\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\nexport default function registerPrimitiveTypes (t: TypeContext): TypeContext {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}","/* @flow */\nimport getErrorMessage from './getErrorMessage';\n\nimport invariant from './invariant';\n\nimport {Type} from './types';\n\nimport type TypeContext from './TypeContext';\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport default function registerBuiltinTypeConstructors (t: TypeContext): TypeContext {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n      if (!(input instanceof Date)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n      }\n      else if (isNaN(input.getTime())) {\n        yield [path, getErrorMessage('ERR_INVALID_DATE'), this];\n      }\n    },\n    accepts (input): boolean {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    compareWith(input) {\n      if (input.typeName === 'DateType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Date): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, futureType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(futureType, 'Must specify type parameter for Promise.');\n      const {context} = this;\n      if (!context.checkPredicate('Promise', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n      }\n    },\n    accepts (input): boolean {\n      const {context} = this;\n      return context.checkPredicate('Promise', input);\n    },\n    compareWith(input) {\n      if (input.typeName === 'PromiseType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: any): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, keyType?: Type<any>, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(keyType, 'Must specify two type parameters for Map.');\n      invariant(valueType, 'Must specify two type parameters for Map.');\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n        return;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key)) {\n          yield [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n        }\n\n        yield* valueType.errors(validation, path.concat(key), value);\n      }\n    },\n    accepts (input, keyType: Type<any>, valueType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key) || !valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'MapType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Map<*, *>): Type<any>[] {\n      const keyTypes = [];\n      const valueTypes = [];\n      loop: for (const [key, value] of input) {\n        findKey: {\n          for (let i = 0; i < keyTypes.length; i++) {\n            const type = keyTypes[i];\n            if (type.accepts(key)) {\n              break findKey;\n            }\n          }\n          keyTypes.push(t.typeOf(key));\n        }\n\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      const typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(valueType, 'Must specify type parameter for Set.');\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n        return;\n      }\n      for (const value of input) {\n        yield* valueType.errors(validation, path, value);\n      }\n    },\n    accepts (input, valueType) {\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      for (const value of input) {\n        if (!valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'SetType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Set<*>): Type<any>[] {\n      const valueTypes = [];\n      loop: for (const value of input) {\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      }\n      else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      }\n      else {\n        return [t.union(...valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nexport default function registerTypePredicates (context: TypeContext) {\n  context.setPredicate('Array', (input: any) => Array.isArray(input));\n  context.setPredicate('Map', (input: any) => input instanceof Map);\n  context.setPredicate('Set', (input: any) => input instanceof Set);\n  context.setPredicate('Promise', (input: any) => {\n    if (input instanceof Promise) {\n      return true;\n    } else {\n      return input !== null\n        && (typeof input === 'object' || typeof input === 'function')\n        && typeof input.then === 'function'\n        ;\n    }\n  });\n}\n","/* @flow */\n\nimport globalContext from './globalContext';\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  PartialType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType,\n  TypeParameterApplication\n} from './types';\n\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport TypeContext from './TypeContext';\n\nfunction v (thing) {\n  return { value: thing }\n}\n\nif (typeof global !== 'undefined' && global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== globalContext) {\n  Object.defineProperties(globalContext, {\n    TypeContext: v(TypeContext),\n    Type: v(Type),\n    TypeBox: v(TypeBox),\n    TypeParameter: v(TypeParameter),\n    TypeReference: v(TypeReference),\n    TypeTDZ: v(TypeTDZ),\n    ParameterizedTypeAlias: v(ParameterizedTypeAlias),\n    TypeAlias: v(TypeAlias),\n    TypeConstructor: v(TypeConstructor),\n    GenericType: v(GenericType),\n    NullLiteralType: v(NullLiteralType),\n    NumberType: v(NumberType),\n    NumericLiteralType: v(NumericLiteralType),\n    BooleanType: v(BooleanType),\n    BooleanLiteralType: v(BooleanLiteralType),\n    SymbolType: v(SymbolType),\n    SymbolLiteralType: v(SymbolLiteralType),\n    StringType: v(StringType),\n    StringLiteralType: v(StringLiteralType),\n    ArrayType: v(ArrayType),\n    ObjectType: v(ObjectType),\n    ObjectTypeCallProperty: v(ObjectTypeCallProperty),\n    ObjectTypeIndexer: v(ObjectTypeIndexer),\n    ObjectTypeProperty: v(ObjectTypeProperty),\n    FunctionType: v(FunctionType),\n    FunctionTypeParam: v(FunctionTypeParam),\n    FunctionTypeRestParam: v(FunctionTypeRestParam),\n    FunctionTypeReturn: v(FunctionTypeReturn),\n    ParameterizedFunctionType: v(ParameterizedFunctionType),\n    PartialType: v(PartialType),\n    RefinementType: v(RefinementType),\n    TypeParameterApplication: v(TypeParameterApplication),\n    GeneratorType: v(GeneratorType),\n    ExistentialType: v(ExistentialType),\n    FlowIntoType: v(FlowIntoType),\n    AnyType: v(AnyType),\n    MixedType: v(MixedType),\n    EmptyType: v(EmptyType),\n    NullableType: v(NullableType),\n    ThisType: v(ThisType),\n    TupleType: v(TupleType),\n    UnionType: v(UnionType),\n    IntersectionType: v(IntersectionType),\n    VoidType: v(VoidType),\n    Declaration: v(Declaration),\n    VarDeclaration: v(VarDeclaration),\n    TypeDeclaration: v(TypeDeclaration),\n    ModuleDeclaration: v(ModuleDeclaration),\n    ModuleExportsDeclaration: v(ModuleExportsDeclaration),\n    ClassDeclaration: v(ClassDeclaration),\n    ParameterizedClassDeclaration: v(ParameterizedClassDeclaration),\n    ExtendsDeclaration: v(ExtendsDeclaration),\n  })\n}\n\nexport default globalContext;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() {\n  return this || (typeof self === \"object\" && self);\n})() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() {\n    return this || (typeof self === \"object\" && self);\n  })() || Function(\"return this\")()\n);\n"],"sourceRoot":""}