{"version":3,"sources":["webpack://tsr/webpack/universalModuleDefinition","webpack://tsr/webpack/bootstrap","webpack://tsr/./src/lib/index.ts","webpack://tsr/../src/primitiveTypes.js","webpack://tsr/../../../node_modules/rollup-regenerator-runtime/regenerator/index.js","webpack://tsr/../src/errorReporting/makeJSONError.js","webpack://tsr/../src/cyclic.js","webpack://tsr/../src/Validation.js","webpack://tsr/../src/errorReporting/RuntimeTypeError.js","webpack://tsr/../src/errorReporting/makeTypeError.js","webpack://tsr/../src/makeError.js","webpack://tsr/../src/compareTypes.js","webpack://tsr/../src/types/Type.js","webpack://tsr/../src/types/AnyType.js","webpack://tsr/../src/errorMessages.js","webpack://tsr/../src/getErrorMessage.js","webpack://tsr/../src/types/TupleType.js","webpack://tsr/../src/types/ArrayType.js","webpack://tsr/../src/types/BooleanLiteralType.js","webpack://tsr/../src/types/BooleanType.js","webpack://tsr/../src/types/EmptyType.js","webpack://tsr/../src/types/ExistentialType.js","webpack://tsr/../src/types/TypeParameterApplication.js","webpack://tsr/../src/typeConstraints.js","webpack://tsr/../src/types/TypeAlias.js","webpack://tsr/../src/types/TypeParameter.js","webpack://tsr/../src/types/FlowIntoType.js","webpack://tsr/../src/types/FunctionTypeRestParam.js","webpack://tsr/../src/types/FunctionTypeParam.js","webpack://tsr/../src/types/FunctionTypeReturn.js","webpack://tsr/../src/symbols.js","webpack://tsr/../src/types/FunctionType.js","webpack://tsr/../src/types/GeneratorType.js","webpack://tsr/../src/types/TypeConstructor.js","webpack://tsr/../src/types/GenericType.js","webpack://tsr/../src/invariant.js","webpack://tsr/../src/types/NullLiteralType.js","webpack://tsr/../src/types/VoidType.js","webpack://tsr/../src/types/NullableType.js","webpack://tsr/../src/types/ObjectTypeProperty.js","webpack://tsr/../src/types/ObjectTypeIndexer.js","webpack://tsr/../src/types/ObjectTypeCallProperty.js","webpack://tsr/../src/declarations/Declaration.js","webpack://tsr/../src/declarations/VarDeclaration.js","webpack://tsr/../src/declarations/TypeDeclaration.js","webpack://tsr/../src/declarations/ModuleDeclaration.js","webpack://tsr/../src/declarations/ModuleExportsDeclaration.js","webpack://tsr/../src/declarations/ClassDeclaration.js","webpack://tsr/../src/types/PartialType.js","webpack://tsr/../src/declarations/ParameterizedClassDeclaration.js","webpack://tsr/../src/declarations/ExtendsDeclaration.js","webpack://tsr/../src/types/ObjectType.js","webpack://tsr/../src/types/IntersectionType.js","webpack://tsr/../src/types/MixedType.js","webpack://tsr/../src/types/NumericLiteralType.js","webpack://tsr/../src/types/NumberType.js","webpack://tsr/../src/types/ParameterizedTypeAlias.js","webpack://tsr/../src/types/ParameterizedFunctionType.js","webpack://tsr/../src/types/RefinementType.js","webpack://tsr/../src/types/StringLiteralType.js","webpack://tsr/../src/types/StringType.js","webpack://tsr/../src/types/SymbolLiteralType.js","webpack://tsr/../src/types/SymbolType.js","webpack://tsr/../src/types/ThisType.js","webpack://tsr/../src/types/TypeBox.js","webpack://tsr/../src/types/TypeReference.js","webpack://tsr/../src/types/TypeTDZ.js","webpack://tsr/../src/types/UnionType.js","webpack://tsr/../src/TypeInferrer.js","webpack://tsr/../src/makeUnion.js","webpack://tsr/../src/classDecorators.js","webpack://tsr/../src/annotateValue.js","webpack://tsr/../src/flowTypes/$DiffType.js","webpack://tsr/../src/flowTypes/$FlowFixMeType.js","webpack://tsr/../src/flowTypes/$KeysType.js","webpack://tsr/../src/flowTypes/$ObjMapiType.js","webpack://tsr/../src/flowTypes/$ObjMapType.js","webpack://tsr/../src/flowTypes/$PropertyType.js","webpack://tsr/../src/flowTypes/$ShapeType.js","webpack://tsr/../src/flowTypes/$SubType.js","webpack://tsr/../src/flowTypes/$SuperType.js","webpack://tsr/../src/flowTypes/$TupleMapType.js","webpack://tsr/../src/flowTypes/$ValuesType.js","webpack://tsr/../src/flowTypes/ClassType.js","webpack://tsr/../src/TypeContext.js","webpack://tsr/../src/errorReporting/makeWarningMessage.js","webpack://tsr/../src/makeReactPropTypes.js","webpack://tsr/../src/globalContext.js","webpack://tsr/../src/registerPrimitiveTypes.js","webpack://tsr/../src/registerBuiltins.js","webpack://tsr/../src/registerTypePredicates.js","webpack://tsr/../src/index.cjs.js","webpack://tsr/(webpack)/buildin/global.js","webpack://tsr/./node_modules/regenerator-runtime/runtime-module.js","webpack://tsr/./node_modules/regenerator-runtime/runtime.js"],"names":["root","factory","exports","module","define","amd","tsr","window","e","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","voidType","void","typeOf","undef","nostrict","args","_i","arguments","length","union","apply","concat","null","nullable","enum","enumMember","arg","literal","enumRef","input","declaration","typeName","Class","lib","primitiveTypes","_regeneratorRuntime","require","a","iterator","constructor","TypeError","configurable","writable","u","assign","setPrototypeOf","__proto__","indexOf","ReferenceError","f","Array","isArray","next","done","push","return","y","from","makeJSONError","validation","hasErrors","context","errors","_step","_iteratorNormalCompletion","_iterator","path","_ref2","message","expectedType","expected","toString","actual","resolvePath","field","stringifyPath","pointer","join","cyclicValidation","WeakMap","cyclicToString","WeakSet","inValidationCycle","type","tracked","weakSetHas","startValidationCycle","set","endValidationCycle","inToStringCycle","has","startToStringCycle","add","endToStringCycle","delete","weakset","weakSetAdd","weakSetDelete","validIdentifierOrAccessor","Validation","prefix","this","cyclic","matchPath","didClear","_step2","_iteratorNormalCompletion2","_iterator2","error","parts","part","test","String","subject","Map","candidate","RuntimeTypeError","options","_this","delimiter","makeTypeError","collected","actualType","actualAsString","makeString","trim","_typeof","JSON","stringify","makeError","validate","compareTypes","b","result","TypeAlias","TypeParameter","TypeParameterApplication","TypeTDZ","unwrap","compareWith","FlowIntoType","AnyType","ExistentialType","MixedType","Type","Error","captureStackTrace","assert","possibleConstructorReturn","_temp","errorMessages","ERR_EXPECT_ARRAY","ERR_EXPECT_TRUE","ERR_EXPECT_FALSE","ERR_EXPECT_BOOLEAN","ERR_EXPECT_EMPTY","ERR_EXPECT_EXACT_VALUE","ERR_EXPECT_CALLABLE","ERR_EXPECT_CLASS","ERR_EXPECT_FUNCTION","ERR_EXPECT_GENERATOR","ERR_EXPECT_ITERABLE","ERR_EXPECT_ARGUMENT","ERR_EXPECT_RETURN","ERR_EXPECT_N_ARGUMENTS","ERR_EXPECT_INSTANCEOF","ERR_EXPECT_KEY_TYPE","ERR_EXPECT_NULL","ERR_EXPECT_NUMBER","ERR_EXPECT_OBJECT","ERR_EXPECT_PROMISE","ERR_EXPECT_STRING","ERR_EXPECT_SYMBOL","ERR_EXPECT_THIS","ERR_EXPECT_VOID","ERR_INVALID_DATE","ERR_MISSING_PROPERTY","ERR_NO_INDEXER","ERR_NO_UNION","ERR_UNKNOWN_KEY","getErrorMessage","params","_len","_key","replace","TupleType","types","checkPredicate","stop","accepts","inputTypes","isGreater","ArrayType","inCycle","abrupt","startCycle","elementType","endCycle","output","x","BooleanLiteralType","BooleanType","EmptyType","typeInstances","parent","toConsumableArray","_parent","inner","hasProperty","getProperty","_ref3","_parent2","items","typeInstance","collectConstraintErrors","addConstraints","constraints","_subject$constraints","_len2","_key2","constraint","violation","constraintsAccept","_len3","_key3","prev","hasConstraints","target","withDeclaration","properties","FlowIntoSymbol","bound","recorded","boundOrDefault","withBinding","id","defaultType","typeParameter","h","t1","catch","finish","hasError","g","t2","toJSON","FunctionTypeRestParam","FunctionTypeParam","optional","undefined","FunctionTypeReturn","ParentSymbol","NameRegistrySymbol","ModuleRegistrySymbol","CurrentModuleSymbol","TypeConstructorRegistrySymbol","InferrerSymbol","TypeSymbol","TypeParametersSymbol","TypePredicateRegistrySymbol","FunctionType","returnType","annotation","param","acceptsType","annotationParam","any","returnTypeResult","inputParams","inputParam","rest","paramsLength","argsLength","_len4","_key4","empty","GeneratorType","throw","isValid","yieldType","nextType","warnedInstances","TypeConstructor","emitWarningMessage","ve","GenericType","impl","getAnnotation","isPrototypeOf","invariant","NullLiteralType","VoidType","NullableType","delegateYield","ObjectTypeProperty","static","mark","isStatic","targetPath","isNullable","existsOn","v","k","ObjectTypeIndexer","keyResult","valueResult","ObjectTypeCallProperty","Declaration","VarDeclaration","TypeDeclaration","typeAlias","addConstraint","_typeAlias","_typeAlias2","_typeAlias3","_typeAlias4","_typeAlias5","ModuleDeclaration","moduleExports","exporting","prop","declarations","moduleName","slice","innerContext","import","body","lines","split","ModuleExports","ClassDeclaration","shapeID","superClass","errorPath","propertyName","errorMessage","isSuperClassOf","current","superClassName","bodyProps","superProps","seen","seenStatic","props","PartialType","typeParameters","expand","ParameterizedClassDeclaration","getPartial","_len5","_key5","partial","bodyCreator","class","_len6","_key6","limit","Math","min","intersect","ExtendsDeclaration","collectErrorsWithIndexers","collectErrorsWithoutIndexers","collectErrorsExact","ObjectType","indexers","callProperties","exact","getIndexer","newProp","hasIndexer","indexer","acceptsKey","hasCallProperties","acceptsCallProperties","acceptsValue","loop","some","inputCallProperties","identicalCount","callProperty","j","inputCallProperty","inputIndexers","inputProperties","inputProperty","inputIndexer","indent","_context2","Me","_context5","Le","IntersectionType","getPropertyIndex","mergeProperties","source","typeProp","index","NumericLiteralType","NumberType","ParameterizedTypeAlias","identifier","typeCreator","_len7","_key7","ParameterizedFunctionType","_getPartial$type","getPartial$2","acceptsParams","acceptsReturn","_getPartial$type2","assertParams","assertReturn","function","RefinementType","StringLiteralType","StringType","SymbolLiteralType","SymbolType","ThisType","TypeBox","reveal","ref","ot","mixed","warnedMissing","TypeReference","RevealedName","RevealedValue","getRevealed","container","existing","pt","UnionType","normalized","TypeInferer","primitive","inferPrimitive","inferred","inferComplex","number","boolean","string","symbol","inferFunction","inferObject","fromCharCode","existential","fn","box","inferArray","handler","getTypeConstructor","inferTypeParameters","inferInternal","inferDict","numericIndexers","stringIndexers","isNaN","values","item","inferredType","array","mergeUnionTypes","aTypes","bTypes","bType","getClassName","resolveType","receiver","typeSource","annotateValue","$DiffType","aType","$FlowFixMeType","$KeysType","keys","$ObjMapiType","mapper","applied","invoke","_step3","_iteratorNormalCompletion3","_iterator3","$ObjMapType","$PropertyType","unwrapped","$ShapeType","t0","$SubType","$SuperType","$TupleMapType","tuple","$ValuesType","checkGenericType","checkType","ClassType","instanceType","warnedInvalidReferences","TypeContext","TypeInferrer","infer","propertyNames","fromParent","global","getPredicate","predicate","shouldAssert","descriptor","propertyPath","originalSetter","warn","safeName","className","initializer","config","objectWithoutProperties","check","makePropertyDescriptor","Boolean","_this2","annotate","de","nameRegistry","var","moduleRegistry","_ref","handlerRegistry","instancePrototype","getPrototypeOf","parentPrototype","parentClass","typeParametersPointer","createContext","currentModule","ModuleExportsDeclaration","head","tail","unshift","_body$properties","_len8","_key8","_len9","_key9","_len10","_key10","method","_len11","_key11","_target$callPropertie","_target$indexers","setProperty","_len12","_key12","_len13","_key13","merged","_len14","_key14","tdz","Lt","_len15","_key15","_target5","_validation$path","objectType","propName","componentName","_len16","_key16","clauses","pop","pattern","_len17","_key17","tests","clause","wrappedIterator","_len18","_key18","_target$callPropertie2","_target$indexers2","_target$properties","_$PropertyType","globalContext","__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__","freeze","declareTypeConstructor","Date","getTime","Promise","futureType","keyType","valueType","_ref4","keyTypes","valueTypes","_ref6","findKey","Set","_step4","_step5","_iteratorNormalCompletion5","_iterator5","_step6","_iterator6","_iteratorNormalCompletion6","setPredicate","then","globalContext$2","thing","defineProperties","Function","eval","self","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","Op","hasOwn","$Symbol","iteratorSymbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","inModule","runtime","wrap","GenStateSuspendedStart","GenStateSuspendedYield","GenStateExecuting","GenStateCompleted","ContinueSentinel","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","GeneratorFunctionPrototype","Generator","GeneratorFunction","displayName","isGeneratorFunction","genFun","ctor","awrap","__await","defineIteratorMethods","AsyncIterator","async","innerFn","outerFn","tryLocsList","iter","reverse","Context","reset","skipTempReset","sent","_sent","delegate","tryEntries","forEach","resetTryEntry","charAt","rootRecord","completion","rval","dispatchException","exception","handle","loc","caught","record","entry","tryLoc","hasCatch","hasFinally","catchLoc","finallyLoc","finallyEntry","complete","afterLoc","thrown","iterable","resultName","nextLoc","protoGenerator","generator","_invoke","state","doneResult","delegateResult","maybeInvokeDelegate","tryCatch","obj","err","previousPromise","callInvokeWithMethodAndArg","resolve","reject","info","pushTryEntry","locs","iteratorMethod"],"mappings":"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","file":"ts-runtime.lib.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ts-runtime/lib\"] = factory();\n\telse\n\t\troot[\"tsr\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import * as t from 'flow-runtime';\n\nconst voidType = t.void;\nconst typeOf = t.typeOf;\n\nt.undef = () => {\n  return voidType.bind(t)();\n}\n\nt.nostrict = (...args: any[]) => {\n  return t.union(...args, t.null(), t.undef());\n}\n\nt.void = () => {\n  return t.union(t.null(), t.undef());\n}\n\nt.n = (...args: any[]) => {\n  return t.nullable(...args);\n}\n\nt.enum = (...args: any[]) => {\n  return t.union(...args);\n}\n\nt.enumMember = (arg: any) => {\n  return t.literal(arg);\n}\n\nt.enumRef = (...args: any[]) => {\n  return t.typeOf(...args);\n}\n\nt.typeOf = (input: any, declaration = false) => {\n  if (declaration && typeof input === 'string') {\n    input = t.get(input);\n\n    if (input) {\n      if (input.typeName === 'ClassDeclaration') {\n        return t.Class(input);\n      }\n\n      return input;\n    }\n  }\n\n  return typeOf.bind(t)(input);\n}\n\nexport const lib = t;\nexport default t;\n\n// const map: Map<string, any> = new Map();\n// const intersect = t.intersect;\n// const declare = t.declare;\n// const ref = t.ref;\n// const decorate = t.decorate;\n// t.decorate = (type: any, shouldAssert?: boolean) => {\n//   return (input: any, propertyName: any, descriptor: any) => {\n//     const decorator = decorate.bind(t)(type, shouldAssert)(input, propertyName, descriptor);\n//     if (descriptor) descriptor.writable = true;\n//     input.writable = true;\n//     Object.defineProperty(input, propertyName, decorator);\n//   };\n// }\n//\n// t.declare = (name: string, type: any) => {\n//   map.set(name, type);\n//   declare.bind(t)(name, type);\n// }\n//\n// t.ref = (type: any, ...args: any[]) => {\n//   if (typeof type === 'string') {\n//     if (map.has(type)) {\n//       type = map.get(type);\n//     }\n//   }\n//\n//   return ref.bind(t)(type, ...args);\n// }\n// t.intersect = (...args: any[]) => {\n//   return intersect.bind(t)(...args).unwrap();\n// }\n//\n// t.intersection = (...args: any[]) => {\n//   return t.intersect(...args);\n// }\n","/* @flow */\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nimport type {\n  Type,\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\n/**\n * Covers our builtin types and makes room for future ones.\n */\ntype PrimitiveTypes = {\n  null: NullLiteralType;\n  empty: EmptyType;\n  number: NumberType;\n  boolean: BooleanType;\n  string: StringType;\n  symbol: SymbolType;\n  any: AnyType;\n  mixed: MixedType;\n  void: VoidType;\n  existential: ExistentialType;\n\n  [name: string]: Type<any>;\n};\n\nconst primitiveTypes: any = {};\n\n(primitiveTypes: PrimitiveTypes);\n\nexport default primitiveTypes;","export default require(\"regenerator-runtime\");\n","/* @flow */\n\nimport {stringifyPath, resolvePath} from '../Validation';\nimport type Validation from '../Validation';\n\nexport default function makeJSONError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const errors = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : null;\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n    const field = stringifyPath(validation.path.concat(path));\n\n    const pointer = `/${path.join('/')}`;\n\n    errors.push({\n      pointer,\n      field,\n      message,\n      expected,\n      actual\n    });\n  }\n  return errors;\n}\n","/* @flow */\n\nimport type Type from './types/Type';\n\n// Tracks whether we're in validation of cyclic objects.\nconst cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\nconst cyclicToString = new WeakSet();\n\nexport function inValidationCycle (type: Type<any>, input: any): boolean {\n  try {\n    const tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n  catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nexport function startValidationCycle (type: Type<any>, input: any) {\n  let tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nexport function endValidationCycle (type: Type<any>, input: any) {\n  const tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nexport function inToStringCycle (type: Type<any>): boolean {\n  return cyclicToString.has(type);\n}\n\nexport function startToStringCycle (type: Type<any>) {\n  cyclicToString.add(type);\n}\n\nexport function endToStringCycle (type: Type<any>) {\n  cyclicToString.delete(type);\n}\n\n\nexport function weakSetHas <V: any> (weakset: WeakSet<V>, value: V): boolean {\n  try {\n    return weakset.has(value);\n  }\n  catch (e) {\n    return true;\n  }\n}\n\n\nexport function weakSetAdd <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.add(value);\n  }\n  catch (e) {}\n}\n\n\nexport function weakSetDelete <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.delete(value);\n  }\n  catch (e) {}\n}","/* @flow */\nimport makeJSONError from './errorReporting/makeJSONError';\n\nimport {weakSetHas, weakSetAdd, weakSetDelete} from './cyclic';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\nexport type IdentifierPath = Array<string | number>;\nexport type ErrorTuple = [IdentifierPath, string, Type<any>];\n\nexport type ValidationJSON<T> = {\n  input: T;\n  errors: Array<{\n    pointer: string;\n    message: string;\n    expected: Type<any>;\n    actual: Type<any>;\n  }>\n};\n\nconst validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\n\nexport default class Validation<T> {\n\n  context: TypeContext;\n\n  input: T;\n\n  path: string[] = [];\n\n  prefix: string = '';\n\n  errors: ErrorTuple[] = [];\n\n  // Tracks whether we're in validation of cyclic objects.\n  cyclic: WeakMap<Type<any>, WeakSet<any>> = new WeakMap();\n\n  constructor (context: TypeContext, input: T) {\n    this.context = context;\n    this.input = input;\n  }\n\n  inCycle (type: Type<any>, input: any): boolean {\n    const tracked = this.cyclic.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n\n  startCycle (type: Type<any>, input: any) {\n    let tracked = this.cyclic.get(type);\n    if (!tracked) {\n      tracked = new WeakSet();\n      this.cyclic.set(type, tracked);\n    }\n    weakSetAdd(tracked, input);\n  }\n\n  endCycle (type: Type<any>, input: any) {\n    const tracked = this.cyclic.get(type);\n    if (tracked) {\n      weakSetDelete(tracked, input);\n    }\n  }\n\n  hasErrors (path: ? IdentifierPath): boolean {\n    if (path) {\n      for (const [candidate] of this.errors) {\n        if (matchPath(path, candidate)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return this.errors.length > 0;\n    }\n  }\n\n  addError (path: IdentifierPath, expectedType: Type<any>, message: string): this {\n    this.errors.push([path, message, expectedType]);\n    return this;\n  }\n\n  clearError (path: ? IdentifierPath): boolean {\n    let didClear = false;\n    if (path) {\n      const errors = [];\n      for (const error of this.errors) {\n        if (matchPath(path, error[0])) {\n          didClear = true;\n        }\n        else {\n          errors.push(error);\n        }\n      }\n      this.errors = errors;\n    }\n    else {\n      didClear = this.errors.length > 0;\n      this.errors = [];\n    }\n    return didClear;\n  }\n\n  resolvePath (path: IdentifierPath): any {\n    return resolvePath(this.input, path);\n  }\n\n  toJSON (): * {\n    return makeJSONError(this);\n  }\n\n}\n\nexport function stringifyPath (path: IdentifierPath): string {\n  if (!path.length) {\n    return 'Value';\n  }\n  const {length} = path;\n  const parts = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    }\n    else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    }\n    else if (i > 0) {\n      parts[i] = `.${String(part)}`;\n    }\n    else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nexport function resolvePath (input: any, path: IdentifierPath): any {\n  let subject = input;\n  const {length} = path;\n  for (let i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    }\n    else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nexport function matchPath (path: IdentifierPath, candidate: IdentifierPath): boolean {\n  const {length} = path;\n  if (length > candidate.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n","/* @flow */\n\nimport type {ErrorTuple} from '../Validation';\n\nexport default class RuntimeTypeError extends TypeError {\n  name: string = \"RuntimeTypeError\";\n  errors: ?ErrorTuple[];\n  constructor(message: string, options?: {errors?: ErrorTuple[]}) {\n    super(message);\n    Object.assign(this, options);\n  }\n}","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nimport RuntimeTypeError from './RuntimeTypeError';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeTypeError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {prefix, input, context, errors} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = resolvePath(input, path);\n    const actualType = context.typeOf(actual).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n    const actualAsString = makeString(actual);\n\n    if (typeof actualAsString === 'string') {\n      collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual Value: ${actualAsString}\\n\\nActual Type: ${actualType}\\n`);\n    } else {\n      collected.push(\n        `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actualType}\\n`\n      );\n    }\n  }\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`, {errors});\n  }\n  else {\n    return new RuntimeTypeError(collected.join(delimiter), {errors});\n  }\n}\n\nfunction makeString(value: *) {\n  if (value === null) {\n    return 'null';\n  }\n  switch (typeof value) {\n    case 'string':\n      return `\"${value}\"`;\n    // @flowIssue\n    case 'symbol':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return String(value);\n    case 'function':\n      return;\n    default:\n      if (Array.isArray(value) || value.constructor == null || value.constructor === Object) {\n        try {\n          return JSON.stringify(value, null, 2);\n        }\n        catch (e) {\n          return;\n        }\n      }\n      return;\n  }\n}","/* @flow */\n\nimport type {Type} from './types';\nimport makeTypeError from './errorReporting/makeTypeError';\n\nexport default function makeError (expected: Type<any>, input: any): ? TypeError {\n  const {context} = expected;\n  const validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n","/* @flow */\n\nimport type Type from './types/Type';\n\nimport {\n  AnyType,\n  ExistentialType,\n  TypeParameter,\n  FlowIntoType,\n  MixedType,\n  TypeAlias,\n  TypeParameterApplication,\n  TypeTDZ\n} from './types';\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\nexport default function compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n  let result;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeParameterApplication || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  }\n  else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  }\n  else {\n    return result;\n  }\n}\n","/* @flow */\n\nimport makeError from '../makeError';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport Validation from '../Validation';\nimport type {ErrorTuple, IdentifierPath} from '../Validation';\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nexport default class Type <T> {\n  typeName: string = 'Type';\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    const validation = new Validation(this.context, input);\n    for (const error of this.errors(validation, [], input)) { // eslint-disable-line no-unused-vars\n      return false;\n    }\n    return true;\n  }\n\n  acceptsType (input: Type<any>): boolean {\n    if (compareTypes(this, input) === -1) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return -1;\n  }\n\n  assert <V: T> (input: V): V {\n    const error = makeError(this, input);\n    if (error) {\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(error, this.assert);\n      }\n      throw error;\n    }\n    return input;\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString () {\n    return '$Type';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class AnyType extends Type<any> {\n  typeName: string = 'AnyType';\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return 'any';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nconst errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be a promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exist on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nexport type ErrorKey = $Keys<typeof errorMessages>;\n\nexport default errorMessages;\n","/* @flow */\n\nimport errorMessages from './errorMessages';\nimport type {ErrorKey} from './errorMessages';\n\n\nexport default function getErrorMessage (key: ErrorKey, ...params: any[]): string {\n  const message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, (m, i) => String(params[i]));\n  }\n  else {\n    return message;\n  }\n}\n\n\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TupleType<T> extends Type {\n  typeName: string = 'TupleType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path.concat(i), input[i]);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n\n    if (!context.checkPredicate('Array', input) || input.length < length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof TupleType)) {\n      return -1;\n    }\n    const types = this.types;\n    const inputTypes = input.types;\n    if (inputTypes.length < types.length) {\n      return -1;\n    }\n    let isGreater = false;\n    for (let i = 0; i < types.length; i++) {\n      const result = compareTypes(types[i], inputTypes[i]);\n      if (result === 1) {\n        isGreater = true;\n      }\n      else if (result === -1) {\n        return -1;\n      }\n    }\n    if (types.length < inputTypes.length) {\n      return 0;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n\n  toString (): string {\n    return `[${this.types.join(', ')}]`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport TupleType from './TupleType';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\nexport default class ArrayType <T> extends Type {\n  typeName: string = 'ArrayType';\n  elementType: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n\n    for (let i = 0; i < length; i++) {\n      yield* elementType.errors(validation, path.concat(i), input[i]);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n    for (let i = 0; i < length; i++) {\n      if (!elementType.accepts(input[i])) {\n        endValidationCycle(this, input);\n        return false;\n      }\n    }\n    endValidationCycle(this, input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {elementType} = this;\n    if (input instanceof TupleType) {\n      const {types} = input;\n      for (let i = 0; i < types.length; i++) {\n        const result = compareTypes(elementType, types[i]);\n        if (result === -1) {\n          return -1;\n        }\n      }\n      return 1;\n    }\n    else if (input instanceof ArrayType) {\n      return compareTypes(elementType, input.elementType);\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {elementType} = this;\n    if (inToStringCycle(this)) {\n      if (typeof elementType.name === 'string') {\n        return `Array<$Cycle<${elementType.name}>>`;\n      }\n      else {\n        return `Array<$Cycle<Object>>`;\n      }\n    }\n    startToStringCycle(this);\n    const output = `Array<${elementType.toString()}>`;\n    endToStringCycle(this);\n    return output;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      elementType: this.elementType\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanLiteralType <T: boolean> extends Type {\n  typeName: string = 'BooleanLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== this.value) {\n      yield [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return this.value ? 'true' : 'false';\n  }\n\n  toJSON () {\n    return {\n      type: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport BooleanLiteralType from './BooleanLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanType extends Type {\n  typeName: string = 'BooleanType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'boolean') {\n      yield [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'boolean';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType) {\n      return 1;\n    }\n    else if (input instanceof BooleanType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'boolean';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class EmptyType extends Type {\n  typeName: string = 'EmptyType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n  }\n\n  accepts (input: any): boolean {\n    return false; // empty types accepts nothing.\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof EmptyType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'empty';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ExistentialType extends Type {\n  typeName: string = 'ExistentialType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return '*';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ApplicableType} from './';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\n/**\n * # TypeParameterApplication\n *\n */\nexport default class TypeParameterApplication<X, T> extends Type {\n  typeName: string = 'TypeParameterApplication';\n  parent: ApplicableType<T>;\n  typeInstances: Type<X>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {parent, typeInstances} = this;\n    yield* parent.errors(validation, path, input, ...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    const {parent, typeInstances} = this;\n    return parent.accepts(input, ...typeInstances);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return this.parent.compareWith(input, ...this.typeInstances);\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).hasProperty === 'function') {\n      return (inner: $FlowIgnore).hasProperty(name, ...this.typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).getProperty === 'function') {\n      return (inner: $FlowIgnore).getProperty(name, ...this.typeInstances);\n    }\n  }\n\n  unwrap () {\n    return this.parent.unwrap(...this.typeInstances);\n  }\n\n  toString (): string {\n    const {parent, typeInstances} = this;\n    const {name} = parent;\n    if (typeInstances.length) {\n      const items = [];\n      for (let i = 0; i < typeInstances.length; i++) {\n        const typeInstance = typeInstances[i];\n        items.push(typeInstance.toString());\n      }\n      return `${name}<${items.join(', ')}>`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeInstances: this.typeInstances\n    };\n  }\n}\n","/* @flow */\n\nimport type {\n  Type,\n  TypeConstraint\n} from './types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport type ConstrainableType<T> = Type<T> & {constraints: TypeConstraint[]};\n\n/**\n * Add constraints to the given subject type.\n */\nexport function addConstraints (subject: ConstrainableType<any>, ...constraints: TypeConstraint[]) {\n  subject.constraints.push(...constraints);\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\nexport function *collectConstraintErrors (subject: ConstrainableType<any>, validation: Validation<any>, path: IdentifierPath, ...input: any[]): Generator<ErrorTuple, void, void> {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    const violation = constraint(...input);\n    if (typeof violation === 'string') {\n      yield [path, violation, this];\n    }\n  }\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nexport function constraintsAccept (subject: ConstrainableType<any>, ...input: any[]): boolean {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    if (typeof constraint(...input) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class TypeAlias<T> extends Type {\n  typeName: string = 'TypeAlias';\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): TypeAlias<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  get properties () {\n    return this.type.properties;\n  }\n\n  get hasConstraints (): boolean {\n    return this.constraints.length > 0;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const {name, type} = this;\n    if (withDeclaration) {\n      return `type ${name} = ${type.toString()};`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport FlowIntoType from \"./FlowIntoType\";\nimport TypeAlias from './TypeAlias';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nconst FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\nexport default class TypeParameter<T> extends Type {\n  typeName: string = 'TypeParameter';\n  id: string;\n  bound: ? Type<T>;\n  default: ? Type<T>;\n\n  recorded: ? Type<T>;\n\n  // @flowIssue 252\n  [FlowIntoSymbol]: ? FlowIntoType = null;\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n\n    if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      yield* boundOrDefault.errors(validation, path, input);\n      return;\n    }\n    else if (recorded) {\n      // we've already recorded a value for this type parameter\n      yield* recorded.errors(validation, path, input);\n      return;\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasErrors = false;\n        for (const error of boundOrDefault.errors(validation, path, input)) {\n          hasErrors = true;\n          yield error;\n        }\n        if (hasErrors) {\n          return;\n        }\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n    if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      return boundOrDefault.accepts(input);\n    } else if (recorded) {\n      return recorded.accepts(input);\n    } else if (boundOrDefault) {\n      if (boundOrDefault.typeName === \"AnyType\" || boundOrDefault.typeName === \"ExistentialType\") {\n        return true;\n      } else if (!boundOrDefault.accepts(input)) {\n        return false;\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (input instanceof TypeParameter) {\n      // We don't need to check for `recorded` or `bound` fields\n      // because the input has already been unwrapped, so\n      // if we got a type parameter it must be totally generic and\n      // we treat it like Any.\n      return 1;\n    }\n    else if (recorded) {\n      return compareTypes(recorded, input);\n    }\n    else if (boundOrDefault) {\n      return compareTypes(boundOrDefault, input);\n    }\n    else {\n      // A generic type parameter accepts any input.\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (recorded) {\n      return recorded.unwrap();\n    }\n    else if (boundOrDefault) {\n      return boundOrDefault.unwrap();\n    }\n    else {\n      return this;\n    }\n  }\n\n  toString (withBinding?: boolean): string {\n    const {id, bound, default: defaultType} = this;\n    if (withBinding) {\n      if (defaultType) {\n        return `${id} = ${defaultType.toString()}`;\n      }\n      else if (bound) {\n        return `${id}: ${bound.toString()}`;\n      }\n    }\n    return id;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      bound: this.bound,\n      recorded: this.recorded\n    };\n  }\n}\n\nexport function flowIntoTypeParameter <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n  const existing: ? FlowIntoType<T> = (typeParameter: $FlowIssue<252>)[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  const target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  (typeParameter: $FlowIssue<252>)[FlowIntoSymbol] = target;\n  return target;\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\nexport default class FlowIntoType<T: any> extends Type {\n  typeName: string = 'FlowIntoType';\n\n  typeParameter: TypeParameter<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      yield* bound.errors(validation, path, input);\n      return;\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound) {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.accepts(input);\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound && !bound.accepts(input)) {\n        return false;\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return true;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return true;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!bound.accepts(input)) {\n        return false;\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.compareWith(input);\n    }\n    if (recorded) {\n      if (bound && compareTypes(bound, input) === -1) {\n        return -1;\n      }\n      const result = compareTypes(recorded, input);\n      if (result === 0) {\n        // our existing type already permits this value, there's nothing to do.\n        return 0;\n      }\n      // we need to make a union\n      typeParameter.recorded = context.union(recorded, input);\n      return 1;\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return 1;\n      }\n      const result = compareTypes(bound, input);\n      if (result === -1) {\n        return -1;\n      }\n    }\n\n    typeParameter.recorded = input;\n    return 0;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.typeParameter.unwrap();\n  }\n\n  toString (withBinding?: boolean): string {\n    return this.typeParameter.toString(withBinding);\n  }\n\n  toJSON () {\n    return this.typeParameter.toJSON();\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class FunctionTypeRestParam<T> extends Type {\n  typeName: string = 'FunctionTypeRestParam';\n  name: string;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `...${this.name}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\n\nexport default class FunctionTypeParam<T> extends Type {\n  typeName: string = 'FunctionTypeParam';\n  name: string;\n  optional: boolean;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return;\n    }\n    else {\n      yield* type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return true;\n    }\n    else {\n      return type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (): string {\n    const {optional, type} = this;\n    return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      optional: this.optional,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class FunctionTypeReturn<T> extends Type {\n  typeName: string = 'FunctionTypeReturn';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path.concat('[[Return Type]]'), input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeReturn) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  unwrap (): Type<T> {\n    return this.type;\n  }\n\n  toString (): string {\n    const {type} = this;\n    return type.toString();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nexport const ParentSymbol = Symbol('Parent');\nexport const NameRegistrySymbol = Symbol('NameRegistry');\nexport const ModuleRegistrySymbol = Symbol('ModuleRegistry');\nexport const CurrentModuleSymbol = Symbol('CurrentModule');\nexport const TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nexport const InferrerSymbol = Symbol('Inferrer');\nexport const TraverseValueSymbol = Symbol('TraverseValue');\nexport const TraverseTypeSymbol = Symbol('TraverseType');\nexport const TypeSymbol = Symbol('Type');\nexport const TypeParametersSymbol = Symbol('TypeParameters');\nexport const TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\nimport FunctionTypeReturn from './FunctionTypeReturn';\nimport EmptyType from './EmptyType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {TypeSymbol} from '../symbols';\n\nexport default class FunctionType<P, R> extends Type {\n  typeName: string = 'FunctionType';\n  params: FunctionTypeParam<P>[] = [];\n  rest: ? FunctionTypeRestParam<P>;\n  returnType: FunctionTypeReturn<R>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n      return;\n    }\n    const annotation = input[TypeSymbol];\n    const {returnType, params} = this;\n    if (annotation) {\n      if (!annotation.params) {\n        return;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        yield [\n          path,\n          getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()),\n          this\n        ];\n      }\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const {returnType, params} = this;\n    const annotation = input[TypeSymbol];\n    if (annotation) {\n      if (!annotation.params) {\n        return true;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          return false;\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          return false;\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        return false;\n      }\n      return true;\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof FunctionType)) {\n      return -1;\n    }\n    const returnType = this.returnType;\n    const inputReturnType = input.returnType;\n    let isGreater = false;\n    const returnTypeResult = compareTypes(returnType, inputReturnType);\n    if (returnTypeResult === -1) {\n      return -1;\n    }\n    else if (returnTypeResult === 1) {\n      isGreater = true;\n    }\n\n    const params = this.params;\n    const inputParams = input.params;\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n      if (inputParam == null) {\n        return -1;\n      }\n      const result = compareTypes(param, inputParam);\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.accepts(args[i])) {\n          return false;\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return false;\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.accepts(args[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  assertParams (...args: any[]): P[] {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        param.assert(args[i]);\n      }\n      else {\n        param.assert(undefined);\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        rest.assert(args[i]);\n      }\n    }\n\n    return args;\n  }\n\n  assertReturn <T> (input: any): T {\n    this.returnType.assert(input);\n    return input;\n  }\n\n  invoke (...args: Type<P>[]): Type<R> | EmptyType {\n    const {params, rest, context} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return context.empty();\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n    }\n\n    return this.returnType.type;\n  }\n\n  toString (): string {\n    const {params, rest, returnType} = this;\n    const args = [];\n    for (let i = 0; i < params.length; i++) {\n      args.push(params[i].toString());\n    }\n    if (rest) {\n      args.push(rest.toString());\n    }\n    return `(${args.join(', ')}) => ${returnType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      params: this.params,\n      rest: this.rest,\n      returnType: this.returnType\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GeneratorType<Y, R, N> extends Type {\n  typeName: string = 'GeneratorType';\n  yieldType: Type<Y>;\n  returnType: Type<R>;\n  nextType: Type<N>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const isValid = input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof GeneratorType)) {\n      const result = compareTypes(this.yieldType, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n    let isGreater = false;\n    let result = compareTypes(this.yieldType, input.yieldType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.returnType, input.returnType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.nextType, input.nextType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsYield (input: any): boolean {\n    return this.yieldType.accepts(input);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  acceptsNext (input: any): boolean {\n    return this.nextType.accepts(input);\n  }\n\n  assertYield (input: Y): Y {\n    return this.yieldType.assert(input);\n  }\n\n  assertReturn (input: R): R {\n    return this.returnType.assert(input);\n  }\n\n  assertNext (input: N): N {\n    return this.nextType.assert(input);\n  }\n\n  toString (): string {\n    const {yieldType, returnType, nextType} = this;\n    return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      yieldType: this.yieldType,\n      returnType: this.returnType,\n      nextType: this.nextType\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type {Constructor} from './';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeConstructor<T> extends Type {\n  typeName: string = 'TypeConstructor';\n  name: string;\n  impl: ? Constructor<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement accepts().`);\n      warnedInstances.add(this);\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement compareWith().`);\n      warnedInstances.add(this);\n    }\n    return -1;\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n\n  apply <P> (...typeInstances: Type<P>[]): TypeParameterApplication<P, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): TypeConstructor<T> {\n    return this;\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n\n}\n","/* @flow */\n\nimport TypeConstructor from \"./TypeConstructor\";\n\nimport type Type from \"./Type\";\nimport compareTypes from \"../compareTypes\";\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, { ErrorTuple, IdentifierPath } from \"../Validation\";\n\nexport default class GenericType extends TypeConstructor {\n  typeName: string = \"GenericType\";\n\n  *errors(\n    validation: Validation<any>,\n    path: IdentifierPath,\n    input: any\n  ): Generator<ErrorTuple, void, void> {\n    const { name, impl } = this;\n    if (!(input instanceof impl)) {\n      yield [path, getErrorMessage(\"ERR_EXPECT_INSTANCEOF\", name), this];\n    }\n  }\n\n  accepts<P>(input: any, ...typeInstances: Type<P>[]): boolean {\n    const { impl } = this;\n    return input instanceof impl;\n  }\n\n  compareWith<P>(input: Type<any>, ...typeInstances: Type<P>[]): -1 | 0 | 1 {\n    const { context, impl } = this;\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      const expected = annotation.unwrap(...typeInstances);\n      return compareTypes(input, expected);\n    } else if (\n      input instanceof GenericType &&\n      (input.impl === impl || (impl && impl.isPrototypeOf(input.impl)))\n    ) {\n      return 0;\n    } else {\n      return -1;\n    }\n  }\n\n  unwrap<P>(...typeInstances: Type<P>[]) {\n    const { context, impl } = this;\n    if (typeof impl !== \"function\") {\n      return this;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation != null) {\n      return (annotation.unwrap(...typeInstances): any);\n    } else {\n      return this;\n    }\n  }\n\n  inferTypeParameters<P>(input: any): Type<P>[] {\n    return [];\n  }\n}\n","/* @flow */\n\nexport default function invariant (input: any, message: string): void {\n  if (!input) {\n    const error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullLiteralType extends Type {\n  typeName: string = 'NullLiteralType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== null) {\n      yield [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === null;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'null';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class VoidType extends Type {\n  typeName: string = 'VoidType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== undefined) {\n      yield [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === undefined;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof VoidType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'void';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport NullLiteralType from './NullLiteralType';\nimport VoidType from './VoidType';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullableType<T> extends Type<T> {\n  typeName: string = 'NullableType';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input != null) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (input == null) {\n      return true;\n    }\n    else {\n      return this.type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType || input instanceof VoidType) {\n      return 1;\n    }\n    else if (input instanceof NullableType) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (): string {\n    return `? ${this.type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport NullableType from './NullableType';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ObjectTypeProperty<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeProperty';\n  key: K;\n  value: Type<V>;\n  optional: boolean;\n  // @flowIgnore\n  'static': boolean = false;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): ObjectTypeProperty<K, V> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n  \n  /**\n   * Determine whether the property is nullable.\n   */\n  isNullable(): boolean {\n    return this.value instanceof NullableType;\n  }\n  \n  /**\n   * Determine whether the property exists on the given input or its prototype chain.\n   */\n  existsOn(input: Object): boolean {\n    // @flowIgnore\n    const {key, static: isStatic} = this;\n    return key in (isStatic ? input.constructor : input) === true;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        if (!optional) {\n          yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        }\n        return;\n      }\n      targetPath.push(key);\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n      targetPath = path.concat(key);\n    }\n    if (optional && target === undefined) {\n      return;\n    }\n    if (this.isNullable() && !this.existsOn(input)) {\n      yield [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n      return;\n    }\n    let hasErrors = false;\n    for (const error of value.errors(validation, targetPath, target)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, targetPath, target);\n    }\n  }\n\n  accepts (input: Object): boolean {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return optional ? true : false;\n      }\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n    }\n    \n    if (optional && target === undefined) {\n      return true;\n    }\n    \n    if (this.isNullable() && !this.existsOn(input)) {\n      return false;\n    }\n    \n    if (!value.accepts(target)) {\n      return false;\n    }\n    else {\n      return constraintsAccept(this, target);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeProperty)) {\n      return -1;\n    }\n    else if (input.key !== this.key) {\n      return -1;\n    }\n    else {\n      return compareTypes(this.value, input.value);\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    let key = this.key;\n    // @flowIssue 252\n    if (typeof key === 'symbol') {\n      key = `[${key.toString()}]`;\n    }\n    if (this.static) {\n      return `static ${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n    else {\n      return `${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      key: this.key,\n      value: this.value,\n      optional: this.optional\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport ObjectTypeProperty from './ObjectTypeProperty';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeIndexer<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeIndexer';\n  id: string;\n  key: Type<K>;\n  value: Type<V>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, key: any, value: any): Generator<ErrorTuple, void, void> {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n\n    yield* this.key.errors(validation, path.concat('[[Key]]'), key);\n    yield* this.value.errors(validation, path.concat(key), value);\n  }\n\n  accepts (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  acceptsKey (key: any): boolean {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n    return this.key.accepts(key);\n  }\n\n  acceptsValue (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ObjectTypeProperty) {\n      if (!this.key.accepts(input.key)) {\n        return -1;\n      }\n      else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n    else if (!(input instanceof ObjectTypeIndexer)) {\n      return -1;\n    }\n\n    const keyResult = compareTypes(this.key, input.key);\n    if (keyResult === -1) {\n      return -1;\n    }\n    const valueResult = compareTypes(this.value, input.value);\n    if (valueResult === -1) {\n      return -1;\n    }\n\n    if (keyResult === 0 && valueResult === 0) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      key: this.key,\n      value: this.value\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeCallProperty<T: Function> extends Type {\n  typeName: string = 'ObjectTypeCallProperty';\n  value: Type<T>;\n  // @flowIgnore\n  'static': boolean = false;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        return;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n      targetPath = path;\n    }\n    yield* value.errors(validation, targetPath, target);\n  }\n\n  accepts (input: any): boolean {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return false;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n    }\n    return value.accepts(target);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeCallProperty)) {\n      return -1;\n    }\n    return compareTypes(this.value, input.value);\n  }\n\n  unwrap (): Type<T> {\n    return this.value.unwrap();\n  }\n\n\n  toString (): string {\n    if (this.static) {\n      return `static ${this.value.toString()};`;\n    }\n    else {\n      return this.value.toString();\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\n\nexport default class Declaration extends Type {\n  name: string;\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {Type, TypeConstraint} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class VarDeclaration<T> extends Declaration {\n  typeName: string = 'VarDeclaration';\n\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): VarDeclaration<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare var ${this.name}: ${this.type.toString()};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {\n  Type,\n  TypeAlias,\n  ParameterizedTypeAlias,\n  TypeConstraint,\n  TypeParameterApplication,\n  ObjectTypeProperty\n} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TypeDeclaration<T> extends Declaration {\n  typeName: string = 'TypeDeclaration';\n\n  get type (): Type<T> {\n    return this.typeAlias.type;\n  }\n\n  typeAlias: TypeAlias<T> | ParameterizedTypeAlias<T>;\n\n  addConstraint (...constraints: TypeConstraint[]): TypeDeclaration<T> {\n    this.typeAlias.addConstraint(...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.typeAlias.errors(validation, path, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    return this.typeAlias.apply(...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    return this.typeAlias.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.typeAlias, input);\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    return this.typeAlias.hasProperty(name, ...typeInstances);\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    return this.typeAlias.getProperty(name, ...typeInstances);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return this.typeAlias.unwrap(...typeInstances);\n  }\n\n  toString (): string {\n    return `declare ${this.typeAlias.toString(true)};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\nimport type ModuleExportsDeclaration from './ModuleExportsDeclaration';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type DeclarationDict = {\n  [name: string]: Type<any>;\n};\n\nexport type ModuleDeclarationDict = {\n  [name: string]: ModuleDeclaration;\n};\n\nimport {NameRegistrySymbol, ModuleRegistrySymbol} from '../symbols';\n\nexport default class ModuleDeclaration extends Declaration {\n  typeName: string = 'ModuleDeclaration';\n\n\n  name: string;\n  innerContext: TypeContext;\n  moduleExports: ? ModuleExportsDeclaration<any>;\n\n  get moduleType (): 'commonjs' | 'es6' {\n    if (this.moduleExports) {\n      return 'commonjs';\n    }\n    else {\n      return 'es6';\n    }\n  }\n\n  get isCommonJS (): boolean {\n    return this.moduleExports ? true : false;\n  }\n\n  get isES6 (): boolean {\n    return this.moduleExports ? false : true;\n  }\n\n  get declarations (): DeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[NameRegistrySymbol];\n  }\n\n  get modules (): ModuleDeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[ModuleRegistrySymbol];\n  }\n\n  get (name: string): ? Type<any> {\n    const {moduleExports} = this;\n    if (moduleExports) {\n      const exporting = moduleExports.unwrap();\n      if (typeof exporting.getProperty === 'function') {\n        const prop = exporting.getProperty(name);\n        if (prop) {\n          return prop.unwrap();\n        }\n      }\n    }\n    else {\n      const declaration = this.declarations[name];\n      if (declaration) {\n        return declaration.unwrap();\n      }\n    }\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // Can't validate a module directly.\n    // @todo should this throw?\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    if (/^\\.\\//.test(moduleName)) {\n      moduleName = `${this.name}${moduleName.slice(1)}`;\n    }\n    return this.innerContext.import(moduleName);\n  }\n\n  toString (): string {\n\n    const {name, declarations, modules, moduleExports} = this;\n    const body = [];\n    for (const name in declarations) { // eslint-disable-line guard-for-in\n      const declaration = declarations[name];\n      body.push(declaration.toString(true));\n    }\n    if (modules) {\n      for (const name in modules) { // eslint-disable-line guard-for-in\n        const module = modules[name];\n        body.push(module.toString());\n      }\n    }\n    if (moduleExports) {\n      body.push(moduleExports.toString());\n    }\n    return `declare module \"${name}\" {\\n${indent(body.join('\\n\\n'))}}`;\n  }\n}\n\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ModuleExports<T> extends Declaration {\n  typeName: string = 'ModuleExports';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare module.exports: ${this.type.toString()};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport getErrorMessage from \"../getErrorMessage\";\nimport compareTypes from '../compareTypes';\n\nimport type ParameterizedClassDeclaration from './ParameterizedClassDeclaration';\n\nimport type {Type, ObjectType} from '../types';\n\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ClassDeclaration<O: {}> extends Declaration {\n  typeName: string = 'ClassDeclaration';\n\n  name: string;\n  superClass: ? Type<any>;\n  body: ObjectType<O>;\n\n  shapeID: Symbol = Symbol();\n\n  get properties (): Array<*> {\n    const {body, superClass} = this;\n    if (superClass == null) {\n      return body.properties;\n    }\n    const bodyProps = body.properties;\n    const superProps = (superClass.unwrap(): $FlowFixme).properties;\n    if (superProps == null) {\n      return bodyProps;\n    }\n    const seen = {};\n    const seenStatic = {};\n    const props = [];\n    for (let i = 0; i < superProps.length; i++) {\n      const prop = superProps[i];\n      props.push(prop);\n      if (prop.static) {\n        seenStatic[prop.key] = i;\n      }\n      else {\n        seen[prop.key] = i;\n      }\n    }\n    for (let i = 0; i < bodyProps.length; i++) {\n      const prop = bodyProps[i];\n      if (seen[prop.key]) {\n        props[i] = prop;\n      }\n      else {\n        props.push(prop);\n      }\n    }\n    return props;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n      return;\n    }\n    if (superClass) {\n      for (const [errorPath, errorMessage, expectedType] of superClass.errors(validation, path, input)) {\n        const propertyName = errorPath[path.length];\n        if (body.getProperty(propertyName)) {\n          continue;\n        }\n        else {\n          yield [errorPath, errorMessage, expectedType];\n        }\n      }\n    }\n    yield* body.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    else if (superClass && !superClass.accepts(input)) {\n      return false;\n    }\n    else if (!body.accepts(input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ClassDeclaration) {\n      if (input === this) {\n        return 0;\n      }\n      else if (this.isSuperClassOf(input)) {\n        return 1;\n      }\n      else {\n        return -1;\n      }\n    }\n    return compareTypes(this.body, input);\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<O>, any> {\n    const {body, superClass} = this;\n    const prop = body.getProperty(key);\n    if (prop) {\n      return prop;\n    }\n    else if (superClass && typeof superClass.getProperty === 'function') {\n      return superClass.getProperty(key);\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {body, superClass} = this;\n    if (body.hasProperty(key)) {\n      return true;\n    }\n    else if (superClass && typeof superClass.hasProperty === 'function') {\n      return superClass.hasProperty(key);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether this class declaration represents a super class of\n   * the given type.\n   */\n  isSuperClassOf <X: {}> (candidate: ClassDeclaration<X> | ParameterizedClassDeclaration<*, X>) {\n    const {body, shapeID} = this;\n    let current = candidate;\n\n    while (current != null) {\n      if (current === this || current === body || current.shapeID === shapeID) {\n        return true;\n      }\n      if (current instanceof ClassDeclaration) {\n        current = current.superClass;\n      }\n      else {\n        current = current.unwrap();\n      }\n    }\n    return false;\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {name, superClass, body} = this;\n    if (withDeclaration) {\n      const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n      return `declare class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n    }\n    else {\n      return name;\n    }\n  }\n}\n","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\nimport TypeParameterApplication from './TypeParameterApplication';\n\nimport {collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class PartialType<X, T> extends Type {\n  typeName: string = 'PartialType';\n  name: string;\n  type: Type<T>;\n  typeParameters: TypeParameter<X>[] = [];\n  constraints: ? TypeConstraint[];\n\n  typeParameter (id: string, bound?: Type<X>, defaultType?: Type<X>): TypeParameter<X> {\n    const target = new TypeParameter(this.context);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    this.typeParameters.push(target);\n    return target;\n  }\n\n  apply (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {constraints, type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors && constraints) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {constraints, type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (constraints && !constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (expand?: boolean): string {\n    const {type} = this;\n    return type.toString(expand);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeParameters: this.typeParameters,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport PartialType from '../types/PartialType';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport type {Type, TypeParameter} from '../types';\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ClassBodyCreator} from './';\n\n\n\nexport default class ParameterizedClassDeclaration<X, O: Object> extends Declaration {\n  typeName: string = 'ParameterizedClassDeclaration';\n  bodyCreator: ClassBodyCreator<X, O>;\n  name: string;\n\n  shapeID: Symbol = Symbol();\n\n  get superClass (): ? Type<$Supertype<O>> {\n    return getPartial(this).type.superClass;\n  }\n\n  get body (): ? Type<O> {\n    return getPartial(this).type.body;\n  }\n\n  get properties(): Property<*, *>[] {\n    return getPartial(this).type.properties;\n  }\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return getPartial(this).compareWith(input);\n  }\n\n  unwrap (...typeInstances: Type<any>[]): Type<O> {\n    return getPartial(this, ...typeInstances).type;\n  }\n\n  isSuperClassOf (candidate: *) {\n    return getPartial(this).type.isSuperClassOf(candidate);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    if (!withDeclaration) {\n      return this.name;\n    }\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return partial.toString(true);\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    const {superClass, body} = type;\n    const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n    return `declare class ${this.name}<${items.join(', ')}>${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n  }\n\n  toJSON () {\n    return getPartial(this).toJSON();\n  }\n}\n\nfunction getPartial <X, O: Object> (parent: ParameterizedClassDeclaration<X, O>, ...typeInstances: Type<any>[]): PartialType<O> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class(parent.name, ...body);\n  }\n  else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  (partial.type: $FlowFixme).shapeID = parent.shapeID;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ExtendsDeclaration<T> extends Declaration {\n  typeName: string = 'ExtendsDeclaration';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {type} = this;\n    if (withDeclaration) {\n      return `extends ${type.toString()}`;\n    }\n    else {\n      return type.toString();\n    }\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport ObjectTypeProperty from './ObjectTypeProperty';\nimport ObjectTypeIndexer from './ObjectTypeIndexer';\nimport ObjectTypeCallProperty from './ObjectTypeCallProperty';\n\nimport {ClassDeclaration, ParameterizedClassDeclaration} from '../declarations';\n\nexport type Property<K: string | number, V>\n = ObjectTypeProperty<K, V>\n | ObjectTypeIndexer<K, V>\n ;\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\n\nexport default class ObjectType<T: {}> extends Type {\n  typeName: string = 'ObjectType';\n  properties: ObjectTypeProperty<$Keys<T>, any>[] = [];\n  indexers: ObjectTypeIndexer<any, any>[] = [];\n  callProperties: ObjectTypeCallProperty<any>[] = [];\n  exact: boolean = false;\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<T>, any> {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return property;\n      }\n    }\n    return this.getIndexer(key);\n  }\n\n  setProperty (key: string | number, value: Type<*>, optional: boolean = false) {\n    const { context, properties } = this;\n    const { length } = properties;\n    const newProp = new ObjectTypeProperty(context);\n    newProp.key = key;\n    newProp.value = value;\n    newProp.optional = optional;\n\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        properties[i] = newProp;\n        return;\n      }\n    }\n    properties.push(newProp);\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return true;\n      }\n    }\n    return this.hasIndexer(key);\n  }\n\n\n  /**\n   * Get an indexer with which matches the given key type.\n   */\n  getIndexer <K: string | number> (key: K): ? ObjectTypeIndexer<K, any> {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return indexer;\n      }\n    }\n  }\n\n  /**\n   * Determine whether an indexer exists which matches the given key type.\n   */\n  hasIndexer (key: string | number): boolean {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input === null) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n      }\n    }\n    else if (typeof input !== 'object') {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n\n\n    if (this.indexers.length > 0) {\n      if (input instanceof Object && Array.isArray(input)) {\n        yield[path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      yield* collectErrorsWithIndexers(this, validation, path, input);\n    }\n    else {\n      yield* collectErrorsWithoutIndexers(this, validation, path, input);\n    }\n    if (this.exact) {\n      yield* collectErrorsExact(this, validation, path, input);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    if (input === null) {\n      return false;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        return false;\n      }\n    }\n    else if (typeof input !== 'object') {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = acceptsWithIndexers(this, input);\n    }\n    else {\n      result = acceptsWithoutIndexers(this, input);\n    }\n    if (result && this.exact) {\n      result = acceptsExact(this, input);\n    }\n    endValidationCycle(this, input);\n    return result;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n      return -1;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    let isGreater = false;\n    if (hasCallProperties) {\n      const result = compareTypeCallProperties(this, (input: $FlowFixme));\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = compareTypeWithIndexers(this, (input: $FlowFixme));\n    }\n    else {\n      result = compareTypeWithoutIndexers(this, (input: $FlowFixme));\n    }\n\n    if (result === -1) {\n      return -1;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return result;\n    }\n  }\n\n  toString (): string {\n    const {callProperties, properties, indexers} = this;\n    if (inToStringCycle(this)) {\n      return '$Cycle<Object>';\n    }\n    startToStringCycle(this);\n    const body = [];\n    for (let i = 0; i < callProperties.length; i++) {\n      body.push(callProperties[i].toString());\n    }\n    for (let i = 0; i < properties.length; i++) {\n      body.push(properties[i].toString());\n    }\n    for (let i = 0; i < indexers.length; i++) {\n      body.push(indexers[i].toString());\n    }\n    endToStringCycle(this);\n    if (this.exact) {\n      return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n    }\n    else {\n      return `{\\n${indent(body.join('\\n'))}\\n}`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      callProperties: this.callProperties,\n      properties: this.properties,\n      indexers: this.indexers,\n      exact: this.exact\n    };\n  }\n}\n\nfunction acceptsCallProperties (type: ObjectType<any>, input: any): boolean {\n  const {callProperties} = type;\n  for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nfunction compareTypeCallProperties (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {callProperties} = type;\n  const inputCallProperties = input.callProperties;\n  let identicalCount = 0;\n  loop: for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n\n    for (let j = 0; j < inputCallProperties.length; j++) {\n      const inputCallProperty = inputCallProperties[j];\n      const result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      }\n      else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  }\n  else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {indexers, properties} = type;\n  const inputIndexers = input.indexers;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (let i = 0; i < indexers.length; i++) {\n    const indexer = indexers[i];\n    for (let j = 0; j < inputIndexers.length; j++) {\n      const inputIndexer = inputIndexers[j];\n      const result = compareTypes(indexer, inputIndexer);\n      if (result === 1) {\n        isGreater = true;\n        continue loop;\n      }\n      else if (result === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction acceptsWithoutIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction acceptsExact (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (const key in input) { // eslint-disable-line guard-for-in\n    if (!properties.some(property => property.key === key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {properties} = type;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction *collectErrorsWithIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    yield [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n  }\n}\n\n\nfunction *collectErrorsWithoutIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n  }\n}\n\n\nfunction *collectErrorsExact (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (const key in input) { // eslint-disable-line guard-for-in\n    if (!properties.some(property => property.key === key)) {\n      yield [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n    }\n  }\n}\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\n\nimport ObjectType from './ObjectType';\nimport type {Property} from './ObjectType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class IntersectionType<T: {}> extends Type {\n  typeName: string = 'IntersectionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path, input);\n    }\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty <K: string | number> (key: K): ? Property<K, any> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = length - 1; i >= 0; i--) {\n      const type = types[i];\n      if (typeof type.getProperty === 'function') {\n        const prop = type.getProperty(key);\n        if (prop) {\n          return prop;\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    let identicalCount = 0;\n    if (input instanceof IntersectionType) {\n      const inputTypes = input.types;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const result = compareTypes(type, input);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 0) {\n          identicalCount++;\n        }\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n  }\n\n  unwrap (): ObjectType<T> {\n    const callProperties = [];\n    const properties = [];\n    const indexers = [];\n    const {types, context} = this;\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      invariant(type instanceof ObjectType, 'Can only intersect object types');\n      callProperties.push(...type.callProperties);\n      indexers.push(...type.indexers);\n      mergeProperties(properties, type.properties);\n    }\n    return (context: any).object(\n      ...callProperties,\n      ...properties,\n      ...indexers\n    );\n  }\n\n  toString (): string {\n    return this.types.join(' & ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\nfunction getPropertyIndex <K: string | number, V> (name: K, properties: ObjectTypeProperty<*, V>[]): number {\n  for (let i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties <K: string | number, V> (target: ObjectTypeProperty<K, V>[], source: ObjectTypeProperty<K, V>[]): ObjectTypeProperty<K, V>[] {\n  for (let i = 0; i < source.length; i++) {\n    const typeProp = source[i];\n    const index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    }\n    else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class MixedType extends Type {\n  typeName: string = 'MixedType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  toString (): string {\n    return 'mixed';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumericLiteralType<T: number> extends Type {\n  typeName: string = 'NumericLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumericLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return `${this.value}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport NumericLiteralType from './NumericLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumberType extends Type {\n  typeName: string = 'NumberType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'number') {\n      yield [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'number';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumberType) {\n      return 0;\n    }\n    else if (input instanceof NumericLiteralType) {\n      return 1;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'number';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeCreator} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport TypeAlias from './TypeAlias';\nimport PartialType from './PartialType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport {constraintsAccept} from '../typeConstraints';\n\n\nexport default class ParameterizedTypeAlias <T: Type> extends TypeAlias {\n  typeName: string = 'ParameterizedTypeAlias';\n\n  typeCreator: TypeCreator<T>;\n\n  get properties () {\n    return getPartial(this).type.properties;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    const partial = getPartial(this, ...typeInstances);\n    if (!partial.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(getPartial(this), input);\n    }\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name, ...typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name, ...typeInstances);\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const partial = getPartial(this);\n    const {typeParameters} = partial;\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n\n    const {name} = this;\n    const identifier = typeParameters.length > 0\n                     ? `${name}<${items.join(', ')}>`\n                     : name\n                     ;\n\n    if (withDeclaration) {\n      return `type ${identifier} = ${partial.toString()};`;\n    }\n    else {\n      return identifier;\n    }\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <T> (parent: ParameterizedTypeAlias<T>, ...typeInstances: Type<any>[]): PartialType<T> {\n\n  const {typeCreator, context, name} = parent;\n  const partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport PartialType from './PartialType';\nimport type FunctionTypeParam from './FunctionTypeParam';\nimport type FunctionTypeRestParam from './FunctionTypeRestParam';\nimport type FunctionTypeReturn from './FunctionTypeReturn';\nimport type TypeParameter from './TypeParameter';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type FunctionBodyCreator <P, R> = (partial: PartialType<(...params: P[]) => R>) => Array<FunctionTypeParam<P> | FunctionTypeRestParam<P> | FunctionTypeReturn<R>>;\n\n\nexport default class ParameterizedFunctionType <X, P: any, R: any> extends Type {\n  typeName: string = 'ParameterizedFunctionType';\n  bodyCreator: FunctionBodyCreator<P, R>;\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  get params (): FunctionTypeParam<P>[] {\n    return getPartial(this).type.params;\n  }\n\n  get rest (): ? FunctionTypeRestParam<P> {\n    return getPartial(this).type.rest;\n  }\n\n  get returnType (): Type<R> {\n    return getPartial(this).type.returnType;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getPartial(this), input);\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    return getPartial(this).type.acceptsParams(...args);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return getPartial(this).type.acceptsReturn(input);\n  }\n\n  assertParams <T> (...args: T[]): T[] {\n    return getPartial(this).type.assertParams(...args);\n  }\n\n  assertReturn <T> (input: T): T {\n    return getPartial(this).type.assertReturn(input);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<(...params: P[]) => R | any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (): string {\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return type.toString();\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    return `<${items.join(', ')}> ${type.toString()}`;\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <X, P, R> (parent: ParameterizedFunctionType<X, P, R>, ...typeInstances: Type<any>[]): PartialType<(...params: P[]) => R> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  partial.type = context.function(...body);\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n","\nimport Type from './Type';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class RefinementType<T> extends Type {\n  typeName: string = 'RefinementType';\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): RefinementType<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `$Refinment<${type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringLiteralType<T: string> extends Type {\n  typeName: string = 'StringLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return JSON.stringify(this.value);\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport StringLiteralType from './StringLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringType extends Type {\n  typeName: string = 'StringType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'string') {\n      yield [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'string';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType) {\n      return 1;\n    }\n    else if (input instanceof StringType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'string';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from '../getErrorMessage';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolLiteralType<T: Symbol> extends Type {\n  typeName: string = 'SymbolLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return `typeof ${String(this.value)}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport SymbolLiteralType from './SymbolLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolType extends Type {\n  typeName: string = 'SymbolType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIssue 252\n    if (typeof input !== 'symbol') {\n      yield [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'symbol';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType) {\n      return 1;\n    }\n    else if (input instanceof SymbolType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'Symbol';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport getErrorMessage from \"../getErrorMessage\";\n\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\nexport default class ThisType<T> extends Type {\n  typeName: string = 'ThisType';\n\n  recorded: ? T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {recorded} = this;\n    if (input === recorded) {\n      return;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return;\n    }\n    else if (recorded != null) {\n      yield [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {recorded} = this;\n    if (input === recorded) {\n      return true;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return true;\n    }\n    else if (recorded != null) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ThisType)) {\n      return -1;\n    }\n    else if (input.recorded && this.recorded) {\n      return input.recorded === this.recorded ? 0 : -1;\n    }\n    else if (this.recorded) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (withBinding?: boolean): string {\n    return 'this';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeBox<T: any> extends Type {\n  typeName: string = 'TypeBox';\n\n  reveal: TypeRevealer<T>;\n\n  get name (): ? string {\n    return (this.type: any).name;\n  }\n\n  get type (): Type<T> {\n    const {reveal} = this;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(this)) {\n        this.context.emitWarningMessage('Failed to reveal boxed type.');\n        warnedInstances.add(this);\n      }\n      return this.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return this.context.ref(type);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this.type;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return this.type.toString();\n  }\n\n  toJSON () {\n    return this.type.toJSON();\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport compareTypes from '../compareTypes';\n\nconst warnedMissing = {};\n\nexport default class TypeReference<T: any> extends Type {\n  typeName: string = 'TypeReference';\n  name: string;\n\n  get type (): Type<T> {\n    const {context, name} = this;\n    const type = context.get(name);\n    if (!type) {\n      if (!warnedMissing[name]) {\n        context.emitWarningMessage(`Cannot resolve type: ${name}`);\n        warnedMissing[name] = true;\n      }\n      return (context.any(): any);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return (this.type.unwrap(): any);\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nconst RevealedName = Symbol('RevealedName');\nconst RevealedValue = Symbol('RevealedValue');\n\nexport default class TypeTDZ<T: any> extends Type {\n  typeName: string = 'TypeTDZ';\n\n  reveal: TypeRevealer<T>;\n\n  // @flowIssue 252\n  [RevealedName]: ? string = undefined;\n\n  // @flowIssue 252\n  [RevealedValue]: ? Type<T> = undefined;\n\n  get name (): ? string {\n    let name = (this: any)[RevealedName];\n    if (!name) {\n      name = (getRevealed(this): any).name;\n    }\n    return name;\n  }\n\n  set name (value: string) {\n    (this: any)[RevealedName] = value;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* getRevealed(this).errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return getRevealed(this).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getRevealed(this), input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = getRevealed(this);\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return getRevealed(this).unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    return getRevealed(this).toString();\n  }\n\n  toJSON () {\n    return getRevealed(this).toJSON();\n  }\n}\n\nfunction getRevealed <T: any> (container: TypeTDZ<T>): Type<T> {\n  const existing = (container: $FlowIssue<252>)[RevealedValue];\n  if (existing) {\n    return existing;\n  }\n  else {\n    const {reveal} = container;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(container)) {\n        const name = (container: any)[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage(`Failed to reveal type called \"${name}\" in Temporal Dead Zone.`);\n        }\n        else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances.add(container);\n      }\n      return container.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport compareTypes from '../compareTypes';\n\nexport default class UnionType<T> extends Type {\n  typeName: string = 'UnionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return;\n      }\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    if (input instanceof UnionType) {\n      const inputTypes = input.types;\n      let identicalCount = 0;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n\n      if (identicalCount === types.length) {\n        return 0;\n      }\n      else {\n        return 1;\n      }\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (compareTypes(type, input) >= 0) {\n          return 1;\n        }\n      }\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {types} = this;\n    const normalized = new Array(types.length);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i];\n      if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n        normalized[i] = `(${type.toString()})`;\n      }\n      else {\n        normalized[i] = type.toString();\n      }\n    }\n    return normalized.join(' | ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nimport type {\n  Type,\n  ArrayType,\n  ObjectType\n} from './types';\n\ntype Inferred = Map<Object, Type<any>>;\n\nexport class TypeInferer {\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  infer <T> (input: T): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    const inferred = new Map();\n    return this.inferComplex(input, inferred);\n  }\n\n  inferInternal <T> (input: T, inferred: Inferred): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    return this.inferComplex(input, inferred);\n  }\n\n  inferPrimitive <T> (input: T): ? Type<T> {\n    const {context} = this;\n    if (input === null) {\n      return (context.null(): any);\n    }\n    else if (input === undefined) {\n      return (context.void(): any);\n    }\n    else if (typeof input === 'number') {\n      return (context.number(): any);\n    }\n    else if (typeof input === 'boolean') {\n      return (context.boolean(): any);\n    }\n    else if (typeof input === 'string') {\n      return (context.string(): any);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return context.symbol((input: any));\n    }\n    else {\n      return undefined;\n    }\n  }\n\n  inferComplex <T> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n\n    if (typeof input === 'function') {\n      return (this.inferFunction(input, inferred): any);\n    }\n    else if (input !== null && typeof input === 'object') {\n      return (this.inferObject(input, inferred): any);\n    }\n    else {\n      return (context.any(): any);\n    }\n  }\n\n  inferFunction <T: Function> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n    const {length} = input;\n    const body = new Array(length + 1);\n    for (let i = 0; i < length; i++) {\n      body[i] = context.param(\n        String.fromCharCode(97 + i),\n        context.existential()\n      );\n    }\n    body[length] = context.return(context.existential());\n    return (context.fn(...body): any);\n  }\n\n  inferObject <T: Object> (input: T, inferred: Inferred): Type<T> {\n    const existing = inferred.get(input);\n    if (existing) {\n      return existing;\n    }\n    const {context} = this;\n    let type;\n\n    // Temporarily create a box for this type to catch cyclical references.\n    // Nested references to this object will receive the boxed type.\n    const box = context.box(() => type);\n    inferred.set(input, box);\n\n    if (context.checkPredicate('Array', input)) {\n      type = this.inferArray((input: any), inferred);\n    }\n    else if (!(input instanceof Object)) {\n      type = this.inferDict(input, inferred);\n    }\n    else if (input.constructor !== Object) {\n      const handler = context.getTypeConstructor(input.constructor);\n      if (handler) {\n        const typeParameters = handler.inferTypeParameters(input);\n        type = handler.apply(...typeParameters);\n      }\n      else {\n        type = context.ref(input.constructor);\n      }\n    }\n    else {\n      const body = [];\n      for (const key in input) { // eslint-disable-line\n        const value = input[key];\n        body.push(context.property(key, this.inferInternal(value, inferred)));\n      }\n      type = context.object(...body);\n    }\n\n    // Overwrite the box with the real value.\n    inferred.set(input, type);\n    return (type: any);\n  }\n\n  inferDict <T: Object> (input: T, inferred: Inferred): ObjectType<T> {\n    const numericIndexers = [];\n    const stringIndexers = [];\n    loop: for (const key in input) { // eslint-disable-line\n      const value = input[key];\n      const types = isNaN(+key) ? stringIndexers : numericIndexers;\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (type.accepts(value)) {\n          continue loop;\n        }\n      }\n      types.push(this.inferInternal(value, inferred));\n    }\n\n    const {context} = this;\n    const body = [];\n    if (numericIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          numericIndexers[0]\n        )\n      );\n    }\n    else if (numericIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          context.union(...numericIndexers)\n        )\n      );\n    }\n\n    if (stringIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          stringIndexers[0]\n        )\n      );\n    }\n    else if (stringIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          context.union(...stringIndexers)\n        )\n      );\n    }\n\n    return context.object(...body);\n  }\n\n  inferArray <T> (input: T[], inferred: Inferred): ArrayType<T> {\n    const {context} = this;\n    const types = [];\n    const values = [];\n    const {length} = input;\n    loop: for (let i = 0; i < length; i++) {\n      const item = input[i];\n      const inferredType = this.inferInternal(item, inferred);\n      for (let j = 0; j < types.length; j++) {\n        const type = types[j];\n        if (type.accepts(item) && inferredType.accepts(values[j])) {\n          continue loop;\n        }\n      }\n      types.push(inferredType);\n      values.push(item);\n    }\n    if (types.length === 0) {\n      return (context.array(context.any()): any);\n    }\n    else if (types.length === 1) {\n      return context.array(types[0]);\n    }\n    else {\n      return context.array(context.union(...types));\n    }\n  }\n\n}\n\nexport default TypeInferer;","/* @flow */\n\nimport UnionType from './types/UnionType';\nimport compareTypes from './compareTypes';\n\nimport AnyType from './types/AnyType';\nimport MixedType from './types/MixedType';\nimport ExistentialType from './types/ExistentialType';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\n\nexport default function makeUnion <T> (context: TypeContext, types: Type<T>[]): Type<T> {\n  const length = types.length;\n  const merged = [];\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return (type: $FlowFixme);\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    }\n    else {\n      merged.push(type);\n    }\n  }\n  const union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes (aTypes: Type<any>[], bTypes: Type<any>[]): void {\n  loop: for (let i = 0; i < bTypes.length; i++) {\n    const bType = bTypes[i];\n    for (let j = 0; j < aTypes.length; j++) {\n      const aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}","/* @flow */\n\nimport type Type from './types/Type';\n\ntype ValueDescriptor<T> = {\n  writable: boolean;\n  initializer?: () => T;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\ntype AccessorDescriptor<T> = {\n  get: () => ? T;\n  set: (value: T) => void;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\nexport type Descriptor<T>\n = AccessorDescriptor<T>\n | ValueDescriptor<T>\n ;\n\ntype TypeSource<T>\n = (() => Type<T>)\n | Type<T>\n ;\n\nexport function makePropertyDescriptor <O: {} | Function, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: Descriptor<T>, shouldAssert: boolean): ? Descriptor<T> {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, (descriptor: $FlowIssue<AccessorDescriptor<T>>), shouldAssert);\n  }\n  else {\n    return propertyToAccessor(typeSource, input, propertyName, (descriptor: $FlowIssue<ValueDescriptor<T>>), shouldAssert);\n  }\n}\n\nfunction makePropertyName (name: string): string {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName (input: Function | Object): string {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  }\n  else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  }\n  else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType <T> (receiver: any, typeSource: TypeSource<T>): Type<T> {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  }\n  else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: ValueDescriptor<T>, shouldAssert: boolean): AccessorDescriptor<T> {\n  const safeName = makePropertyName(propertyName);\n  const className = getClassName(input);\n  const {initializer, writable, ...config} = descriptor; // eslint-disable-line no-unused-vars\n\n  const propertyPath = [className, propertyName];\n\n  return {\n    ...config,\n    type: 'accessor',\n    get (): ? T {\n      if (safeName in this) {\n        return (this: any)[safeName];\n      }\n      else if (initializer) {\n        const type = resolveType(this, typeSource);\n        const value = initializer.call(this);\n        const context = type.context;\n        context.check(type, value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n        return value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set (value: T): void {\n      const type = resolveType(this, typeSource);\n      const context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      }\n      else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  };\n}\n\nfunction augmentExistingAccessors <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: AccessorDescriptor<T>, shouldAssert: boolean) {\n\n  const className = getClassName(input);\n  const propertyPath = [className, propertyName];\n\n  const originalSetter = descriptor.set;\n\n  descriptor.set = function set (value: T): void {\n    const type = resolveType(this, typeSource);\n    const context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    }\n    else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n\n}\n\n","/* @flow */\n\nimport Type from './types/Type';\n\nimport {TypeSymbol} from './symbols';\n\nexport type Decorator<T> = (input: T) => T;\n\ndeclare function annotateValue <T> (type: Type<T>): Decorator<T>;\ndeclare function annotateValue <T> (input: T, type: Type<T>): T; // eslint-disable-line no-redeclare\n\nexport default function annotateValue (input, type?) { // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  }\n  else {\n    const type = input;\n    return (input) => {\n      input[TypeSymbol] = type;\n      return input;\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nexport default class $DiffType<A: {}, B: {}> extends Type<$Diff<A, B>> {\n  typeName: string = '$DiffType';\n\n  aType: Type<A>;\n  bType: Type<B>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      yield* property.errors(validation, path.concat(property.key), input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      if (!property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Diff<A, B>> {\n    let {aType, bType} = this;\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    const args = [];\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      args.push(property);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      aType: this.aType,\n      bType: this.bType\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $FlowFixMeType extends Type<any> {\n  typeName: string = '$FlowFixMeType';\n\n  *errors (validation: Validation<any>, input: any, path: IdentifierPath = []): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  unwrap (): Type<any> {\n    return this;\n  }\n\n  toString (): string {\n    return '$FlowFixMe';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $KeysType<T: {}> extends Type<$Keys<T>> {\n  typeName: string = '$KeysType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return;\n      }\n    }\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      keys[i] = properties[i].key;\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Keys<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      keys[i] = context.literal(property.key);\n    }\n    return this.context.union(...keys);\n  }\n\n  toString (): string {\n    return `$Keys<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys and values in an object.\n\nexport default class $ObjMapiType<O: {}, M: Mapper> extends Type<$ObjMapi<O, M>> {\n  typeName: string = '$ObjMapiType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMapi<O, M>> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key), prop.value)\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys in an object.\n\nexport default class $ObjMapType<O: {}, M: Mapper> extends Type<$ObjMap<O, M>> {\n  typeName: string = '$ObjMapType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMap<O, M>> {\n\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key))\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The type of the named object property\n\nexport default class $PropertyType<O: {}, P: string | number | Symbol> extends Type {\n  typeName: string = '$PropertyType';\n\n  object: Type<O>;\n\n  property: P;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.unwrap().errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.unwrap().accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<*> {\n    const {object, property} = this;\n    const unwrapped = object.unwrap();\n    invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n    return unwrapped.getProperty(property).unwrap();\n  }\n\n  toString (): string {\n    return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      property: this.property\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nexport default class $ShapeType<T> extends Type<$Shape<T>> {\n  typeName: string = '$ShapeType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {type} = this;\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property) {\n        continue;\n      }\n      yield* property.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {type} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property || !property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Shape<T>> {\n    let {type} = this;\n    type = type.unwrap();\n    const context = this.context;\n    invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n    const properties = type.properties;\n    const args = new Array(properties.length);\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      args[i] = context.property(property.key, property.value, true);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Shape<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $SubType<T> extends Type<$Subtype<T>> {\n  typeName: string = '$SubType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(input, path);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Subtype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Subtype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any, but at least T.\n\nexport default class $SuperType<T> extends Type<$Supertype<T>> {\n  typeName: string = '$SuperType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Supertype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Supertype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport TupleType from '../types/TupleType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the values in a tuple.\n\nexport default class $TupleMapType<T: [], M: Mapper> extends Type<$TupleMap<T, M>> {\n  typeName: string = '$TupleMapType';\n\n  tuple: Type<T>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const expected = applied.invoke(type);\n      const value = input[i];\n      yield* expected.errors(validation, path.concat(i), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      if (!applied.invoke(type).accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$TupleMap<T, M>> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n    const args = [];\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(applied.invoke(type).unwrap().unwrap());\n    }\n\n    return context.tuple(...args);\n  }\n\n  toString (): string {\n    return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      tuple: this.tuple,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $ValuesType<T: {}> extends Type<$Values<T>> {\n  typeName: string = '$ValuesType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.value.accepts(input)) {\n        return;\n      }\n    }\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      values[i] = properties[i].value.toString();\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', values.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.value.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Values<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      values[i] = property.value;\n    }\n    return context.union(...values);\n  }\n\n  toString (): string {\n    return `$Values<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport GenericType from '../types/GenericType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nfunction checkGenericType (context: TypeContext, expected: GenericType, input: Function) {\n  const {impl} = expected;\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  }\n  else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  const annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  }\n  else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType (context: TypeContext, expected: Type<*>, input: Function) {\n  const annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    const result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\n\nexport default class ClassType<T> extends Type {\n  typeName: string = 'ClassType';\n\n  instanceType: Type<*>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n      return;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    const isValid = (\n      expectedType instanceof GenericType\n      ? checkGenericType(context, expectedType, input)\n      : checkType(context, expectedType, input)\n    );\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    if (expectedType instanceof GenericType) {\n      return checkGenericType(context, expectedType, input);\n    }\n    else {\n      return checkType(context, expectedType, input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {instanceType} = this;\n    if (input instanceof ClassType) {\n      return compareTypes(instanceType, input.instanceType);\n    }\n    return -1;\n  }\n\n  toString (): string {\n    return `Class<${this.instanceType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      instanceType: this.instanceType\n    };\n  }\n}","/* @flow */\n\nimport TypeInferrer from './TypeInferrer';\nimport primitiveTypes from './primitiveTypes';\nimport invariant from './invariant';\n\nimport Validation from './Validation';\n\nimport makeReactPropTypes from './makeReactPropTypes';\n\nimport makeJSONError from './errorReporting/makeJSONError';\nimport makeTypeError from './errorReporting/makeTypeError';\nimport makeWarningMessage from './errorReporting/makeWarningMessage';\n\nimport makeUnion from './makeUnion';\nimport compareTypes from './compareTypes';\nimport {makePropertyDescriptor} from './classDecorators';\n\nimport {flowIntoTypeParameter} from './types/TypeParameter';\n\nimport annotateValue from './annotateValue';\n\nimport type {PropTypeDict} from './makeReactPropTypes';\nimport type {IdentifierPath, ErrorTuple} from './Validation';\n\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType\n} from './types';\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport {\n  $DiffType,\n  $FlowFixMeType,\n  $KeysType,\n  $ObjMapiType,\n  $ObjMapType,\n  $PropertyType as _$PropertyType,\n  $ShapeType,\n  $SubType,\n  $SuperType,\n  $TupleMapType,\n  $ValuesType,\n  ClassType\n} from './flowTypes';\n\nimport {\n  ParentSymbol,\n  NameRegistrySymbol,\n  ModuleRegistrySymbol,\n  CurrentModuleSymbol,\n  TypeConstructorRegistrySymbol,\n  TypeParametersSymbol,\n  InferrerSymbol,\n  TypePredicateRegistrySymbol,\n  TypeSymbol\n} from './symbols';\n\nimport type {\n  TypeConstraint,\n  TypeCreator,\n  TypeRevealer,\n  FunctionBodyCreator,\n  ApplicableType,\n  ValidFunctionBody,\n  ObjectPropertyDict,\n  ValidObjectBody\n} from './types';\n\nimport type {\n  ClassBodyCreator,\n  ValidClassBody\n} from './declarations';\n\nexport type TypeConstructorConfig = {\n  name: string;\n  impl?: Function;\n  typeName: string;\n  compareWith?: (Type<any>) => -1 | 0 | 1;\n  errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void>;\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean;\n  inferTypeParameters (input: any): Type<any>[];\n};\n\nexport type TypePredicate = (input: any) => boolean;\n\ntype NameRegistry = {\n  [name: string]: Type<any> | Class<TypeConstructor<any>>;\n};\n\ntype TypePredicateRegistry = {\n  [name: string]: TypePredicate;\n};\n\ntype ModuleRegistry = {\n  [name: string]: ModuleDeclaration;\n};\n\ntype TypeConstructorRegistry = Map<Function, Class<TypeConstructor<any>>>;\n\nexport type MatchClause<P, R> = (...params: P[]) => R;\nexport type PatternMatcher<P, R> = (...params: P[]) => R;\n\nexport type CheckMode\n  = 'assert'\n  | 'warn'\n  ;\n\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nconst warnedInvalidReferences: WeakSet<any> = new WeakSet();\n\nexport default class TypeContext {\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n  mode: CheckMode = 'assert';\n\n  // @flowIssue 252\n  [ParentSymbol]: ? TypeContext;\n\n  // @flowIssue 252\n  [NameRegistrySymbol]: NameRegistry = {};\n\n  // @flowIssue 252\n  [TypePredicateRegistrySymbol]: TypePredicateRegistry = {};\n\n  // @flowIssue 252\n  [TypeConstructorRegistrySymbol]: TypeConstructorRegistry = new Map();\n\n  // @flowIssue 252\n  [InferrerSymbol]: TypeInferrer = new TypeInferrer(this);\n\n  // @flowIssue 252\n  [ModuleRegistrySymbol]: ModuleRegistry = {};\n\n  // @flowIssue 252\n  [CurrentModuleSymbol]: ? ModuleDeclaration;\n\n  get TypeParametersSymbol (): typeof TypeParametersSymbol {\n    return TypeParametersSymbol;\n  }\n\n\n  makeJSONError <T> (validation: Validation<T>): ? Array<Object> {\n    return makeJSONError(validation);\n  }\n\n  makeTypeError <T> (validation: Validation<T>): ? TypeError {\n    return makeTypeError(validation);\n  }\n\n  createContext (): TypeContext {\n    const context = new TypeContext();\n    // @flowIssue 252\n    context[ParentSymbol] = this;\n    return context;\n  }\n\n  typeOf <T> (input: T): Type<T> {\n\n    const annotation = this.getAnnotation(input);\n    if (annotation) {\n      if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n        return this.Class(annotation);\n      }\n      return annotation;\n    }\n    // @flowIssue 252\n    const inferrer = this[InferrerSymbol];\n    (inferrer: TypeInferrer);\n\n    return inferrer.infer(input);\n  }\n\n  compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n    return compareTypes(a, b);\n  }\n\n  get (name: string, ...propertyNames: string[]): ? Type<any> {\n    // @flowIssue 252\n    const item = this[NameRegistrySymbol][name];\n    if (item != null) {\n      let current = typeof item === 'function'\n                  ? new item(this)\n                  : item\n                  ;\n      for (let i = 0; i < propertyNames.length; i++) {\n        const propertyName = propertyNames[i];\n        if (typeof current.getProperty !== 'function') {\n          return;\n        }\n        current = current.getProperty(propertyName);\n        if (!current) {\n          return;\n        }\n        current = current.unwrap();\n      }\n      return current;\n    }\n    // @flowIssue 252\n    const parent = this[ParentSymbol];\n    if (parent) {\n      const fromParent = parent.get(name, ...propertyNames);\n      if (fromParent) {\n        return fromParent;\n      }\n    }\n\n    // if we got this far, see if we have a global type with this name.\n    if (typeof global[name] === 'function') {\n      const target = new GenericType(this);\n      target.name = name;\n      target.impl = global[name];\n      // @flowIssue 252\n      this[NameRegistrySymbol][name] = target;\n      return target;\n    }\n  }\n\n  /**\n   * Get the predicate for a given type name.\n   * e.g. `t.getPredicate('Array')`.\n   */\n  getPredicate (name: string): ? TypePredicate {\n    const item: ? TypePredicate = (this: any)[TypePredicateRegistrySymbol][name];\n    if (item) {\n      return item;\n    }\n    const parent: ? TypeContext = (this: any)[ParentSymbol];\n    if (parent) {\n      return parent.getPredicate(name);\n    }\n  }\n\n  /**\n   * Set the predicate for a given type name.\n   * This can be used to customise the behaviour of things like Array\n   * detection or allowing Thenables in place of the global Promise.\n   */\n  setPredicate (name: string, predicate: TypePredicate) {\n    (this: any)[TypePredicateRegistrySymbol][name] = predicate;\n  }\n\n  /**\n   * Check the given value against the named predicate.\n   * Returns false if no such predicate exists.\n   * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n   */\n  checkPredicate (name: string, input: any): boolean {\n    const predicate = this.getPredicate(name);\n    if (predicate) {\n      return predicate(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns a decorator for a function or object with the given type.\n   */\n  decorate (type: (() => Type<any>) | Type<any>, shouldAssert?: boolean): * {\n    if (shouldAssert == null) {\n      shouldAssert = this.mode === 'assert';\n    }\n    return (input: Object | Function, propertyName?: string, descriptor?: Object): * => {\n      if (descriptor && typeof propertyName === 'string') {\n        return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n      }\n      else {\n        invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n        return this.annotate(input, type);\n      }\n    };\n  }\n\n  /**\n   * Annotates an object or function with the given type.\n   * If a type is specified as the sole argument, returns a\n   * function which can decorate classes or functions with the given type.\n   */\n  annotate <T> (input: Type<T> | T, type?: Type<T>) {\n    if (type === undefined) {\n      return annotateValue(input);\n    }\n    else {\n      return annotateValue(input, type);\n    }\n  }\n\n  getAnnotation <T> (input: T): ? Type<T> {\n    if ((input !== null && typeof input === 'object') || typeof input === 'function') {\n      // @flowIssue 252\n      return input[TypeSymbol];\n    }\n  }\n\n  hasAnnotation (input: any): boolean {\n    if (input == null) {\n      return false;\n    }\n    else {\n      return input[TypeSymbol] ? true : false;\n    }\n  }\n\n  setAnnotation <T: Object | Function> (input: T, type: Type<T>): T {\n    input[TypeSymbol] = type;\n    return input;\n  }\n\n  type <T> (name: string, type: Type<T> | TypeCreator<Type<T>>): TypeAlias<T> | ParameterizedTypeAlias<T> {\n    if (typeof type === 'function') {\n      const target = new ParameterizedTypeAlias(this);\n      target.name = name;\n      target.typeCreator = type;\n      return target;\n    }\n    else {\n      const target = new TypeAlias(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }\n\n  declare <T: any, D: ModuleDeclaration | TypeDeclaration<T> | VarDeclaration<T> | ClassDeclaration<T>> (name: string | D, type?: Type<T> | TypeCreator<Type<T>>): D | TypeDeclaration<T> {\n\n    if (name instanceof Declaration) {\n      type = name;\n      name = type.name;\n    }\n    else if (name instanceof TypeAlias) {\n      type = name;\n      name = type.name;\n    }\n    if (typeof type === 'function') {\n      type = this.type(name, type);\n    }\n    if (type instanceof ModuleDeclaration) {\n      const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n      moduleRegistry[name] = type;\n      return type;\n    }\n    else {\n      invariant(typeof name === 'string', 'Name must be a string');\n      invariant(type instanceof Type, 'Type must be supplied to declaration');\n      const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n      if (type instanceof Declaration) {\n        nameRegistry[name] = type;\n        return type;\n      }\n      else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n        const target = new TypeDeclaration(this);\n        target.name = name;\n        target.typeAlias = type;\n        nameRegistry[name] = target;\n        return target;\n      }\n      else {\n        const target = this.var(name, type);\n        nameRegistry[name] = target;\n        return target;\n      }\n    }\n  }\n\n  *declarations (): Generator<[string, Type<any> | TypeConstructor<any>], void, void> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n    for (const key in nameRegistry) { // eslint-disable-line guard-for-in\n      yield [key, nameRegistry[key]];\n    }\n  }\n\n  *modules (): Generator<ModuleDeclaration, void, void> {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    for (const key in moduleRegistry) { // eslint-disable-line guard-for-in\n      yield moduleRegistry[key];\n    }\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    if (moduleRegistry[moduleName]) {\n      return moduleRegistry[moduleName];\n    }\n    const [head] = moduleName.split('/');\n    const module = moduleRegistry[head];\n    if (module) {\n      return module.import(moduleName);\n    }\n    const parent = (this: $FlowIssue<252>)[ParentSymbol];\n    if (parent) {\n      return parent.import(moduleName);\n    }\n  }\n\n  declareTypeConstructor ({name, impl, typeName, errors, accepts, inferTypeParameters, compareWith}: TypeConstructorConfig): TypeConstructor<any> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n    if (nameRegistry[name]) {\n      this.emitWarningMessage(`Redeclaring type: ${name}, this may be unintended.`);\n    }\n\n    const target = new TypeConstructor(this);\n    target.name = name;\n    target.typeName = typeName;\n    target.impl = impl;\n    target.errors = errors;\n    target.accepts = accepts;\n    target.inferTypeParameters = inferTypeParameters;\n    if (typeof compareWith === 'function') {\n      target.compareWith = compareWith;\n    }\n\n    nameRegistry[name] = target;\n\n    if (typeof impl === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      if (handlerRegistry.has(impl)) {\n        this.emitWarningMessage(`A type handler already exists for the given implementation of ${name}.`);\n      }\n      handlerRegistry.set(impl, target);\n    }\n    return target;\n  }\n\n  getTypeConstructor (impl: Function): ? TypeConstructor<any> {\n    // @flowIssue 252\n    const handlerRegistry = this[TypeConstructorRegistrySymbol];\n    (handlerRegistry: TypeConstructorRegistry);\n\n    return handlerRegistry.get(impl);\n  }\n\n  literal <T: void | null | boolean | number | string | Symbol> (input: T): Type<T> {\n    if (input === undefined) {\n      return this.void();\n    }\n    else if (input === null) {\n      return this.null();\n    }\n    else if (typeof input === 'boolean') {\n      return this.boolean(input);\n    }\n    else if (typeof input === 'number') {\n      return this.number(input);\n    }\n    else if (typeof input === 'string') {\n      return this.string(input);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return this.symbol(input);\n    }\n    else {\n      return this.typeOf(input);\n    }\n  }\n\n  null (): NullLiteralType {\n    return primitiveTypes.null;\n  }\n\n  nullable <T> (type: Type<T>): NullableType<? T> {\n    const target = new NullableType(this);\n    target.type = type;\n    return target;\n  }\n\n  existential (): ExistentialType {\n    return primitiveTypes.existential;\n  }\n\n\n  empty (): EmptyType {\n    return primitiveTypes.empty;\n  }\n\n  any (): AnyType {\n    return primitiveTypes.any;\n  }\n\n  mixed (): MixedType {\n    return primitiveTypes.mixed;\n  }\n\n  void (): VoidType {\n    return primitiveTypes.void;\n  }\n\n  this <T> (input?: T): ThisType<T> {\n    const target = new ThisType(this);\n    if (input !== undefined) {\n      target.recorded = input;\n    }\n    return target;\n  }\n\n  number <T: number> (input?: T): NumberType | NumericLiteralType<T> {\n    if (input !== undefined) {\n      const target = new NumericLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.number;\n    }\n  }\n\n  boolean <T: boolean> (input?: T): BooleanType | BooleanLiteralType<T> {\n    if (input !== undefined) {\n      const target = new BooleanLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.boolean;\n    }\n  }\n\n  string <T: string> (input?: T): StringType | StringLiteralType<T> {\n    if (input !== undefined) {\n      const target = new StringLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.string;\n    }\n  }\n\n  symbol <T: Symbol> (input?: T): SymbolType | SymbolLiteralType<T> {\n    if (input !== undefined) {\n      const target = new SymbolLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.symbol;\n    }\n  }\n\n  typeParameter <T> (id: string, bound?: Type<T>, defaultType?: Type<T>): TypeParameter<T> {\n    const target = new TypeParameter(this);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    return target;\n  }\n\n  flowInto <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n    return flowIntoTypeParameter(typeParameter);\n  }\n\n  /**\n   * Bind the type parameters for the parent class of the given instance.\n   */\n  bindTypeParameters <T: {}> (subject: T, ...typeInstances: Type<any>[]): T {\n    const instancePrototype = Object.getPrototypeOf(subject);\n    // @flowIssue\n    const parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n    // @flowIssue\n    const parentClass = parentPrototype && parentPrototype.constructor;\n\n    if (!parentClass) {\n      this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n      return subject;\n    }\n    // @flowIssue 252\n    const typeParametersPointer = parentClass[TypeParametersSymbol];\n\n    if (typeParametersPointer) {\n      const typeParameters = subject[typeParametersPointer];\n      const keys = Object.keys(typeParameters);\n      const length = Math.min(keys.length, typeInstances.length);\n      for (let i = 0; i < length; i++) {\n        const typeParam = typeParameters[keys[i]];\n        typeParam.bound = typeInstances[i];\n      }\n    }\n    return subject;\n  }\n\n  module (name: string, body: (context: TypeContext) => any): ModuleDeclaration {\n    const target = new ModuleDeclaration(this);\n    target.name = name;\n    const innerContext = this.createContext();\n    // @flowIssue 252\n    innerContext[ParentSymbol] = this;\n    // @flowIssue 252\n    innerContext[CurrentModuleSymbol] = target;\n\n    target.innerContext = innerContext;\n    body(innerContext);\n    return target;\n  }\n\n  moduleExports <T> (type: Type<T>): ModuleExportsDeclaration<T> {\n    const currentModule: ModuleDeclaration = (this: $FlowIssue<252>)[CurrentModuleSymbol];\n    if (!currentModule) {\n      throw new Error('Cannot declare module.exports outside of a module.');\n    }\n    const target = new ModuleExportsDeclaration(this);\n    target.type = type;\n    currentModule.moduleExports = target;\n    return target;\n  }\n\n  var <T> (name: string, type: Type<T>): VarDeclaration<T> {\n    const target = new VarDeclaration(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  class <X, O: {}> (name: string, head?: ClassBodyCreator<X, O> | ValidClassBody<X, O>, ...tail: Array<ValidClassBody<X, O>>): ClassDeclaration<O> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedClassDeclaration(this);\n      target.name = name;\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new ClassDeclaration(this);\n    target.name = name;\n    if (head != null) {\n      tail.unshift(head);\n    }\n    const {length} = tail;\n    const properties = [];\n    let body;\n\n    for (let i = 0; i < length; i++) {\n      const item = tail[i];\n      if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n        properties.push(item);\n      }\n      else if (item instanceof ObjectType) {\n        invariant(!body, 'Class body must only be declared once.');\n        body = item;\n      }\n      else if (item instanceof ExtendsDeclaration) {\n        invariant(!target.superClass, 'Classes can only have one super class.');\n        target.superClass = item;\n      }\n      else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n        for (const propertyName in item) { // eslint-disable-line\n          properties.push(this.property(propertyName, (item: any)[propertyName]));\n        }\n      }\n      else {\n        throw new Error('ClassDeclaration cannot contain the given type directly.');\n      }\n    }\n    if (!body) {\n      body = new ObjectType(this);\n    }\n    if (properties.length) {\n      body.properties.push(...properties);\n    }\n    target.body = body;\n    return target;\n  }\n\n  extends <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): ExtendsDeclaration<T> {\n    const target = new ExtendsDeclaration(this);\n    target.type = this.ref(subject, ...typeInstances);\n    return target;\n  }\n\n  fn <X, P, R> (head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    return this.function(head, ...tail);\n  }\n\n  function <X, P, R> (head: ? FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedFunctionType(this);\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new FunctionType(this);\n    if (head != null) {\n      tail.unshift(head);\n      const {length} = tail;\n      for (let i = 0; i < length; i++) {\n        const item = tail[i];\n        if (item instanceof FunctionTypeParam) {\n          target.params.push(item);\n        }\n        else if (item instanceof FunctionTypeRestParam) {\n          target.rest = item;\n        }\n        else if (item instanceof FunctionTypeReturn) {\n          target.returnType = item;\n        }\n        else {\n          throw new Error('FunctionType cannot contain the given type directly.');\n        }\n      }\n    }\n    if (!target.returnType) {\n      target.returnType = this.any();\n    }\n    return target;\n  }\n\n  param <T> (name: string, type: Type<T>, optional: boolean = false): FunctionTypeParam<T> {\n    const target = new FunctionTypeParam(this);\n    target.name = name;\n    target.type = type;\n    target.optional = optional;\n    return target;\n  }\n\n  rest <T> (name: string, type: Type<T>): FunctionTypeRestParam<T> {\n    const target = new FunctionTypeRestParam(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  return <T> (type: Type<T>): FunctionTypeReturn<T> {\n    const target =  new FunctionTypeReturn(this);\n    target.type = type;\n    return target;\n  }\n\n  generator <Y, R, N> (yieldType: Type<Y>, returnType?: Type<R>, nextType?: Type<N>): GeneratorType<Y, R, N> {\n    const target = new GeneratorType(this);\n    target.yieldType = yieldType;\n    target.returnType = returnType || this.any();\n    target.nextType = nextType || this.any();\n    return target;\n  }\n\n  object <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n      for (const propertyName in head) { // eslint-disable-line\n        target.properties.push(this.property(propertyName, head[propertyName]));\n      }\n    }\n    else {\n      let body;\n      if (head) {\n        body = [head, ...tail];\n      }\n      else {\n        body = tail;\n      }\n      const {length} = body;\n      for (let i = 0; i < length; i++) {\n        const item = body[i];\n        if (item instanceof ObjectTypeProperty) {\n          target.properties.push(item);\n        }\n        else if (item instanceof ObjectTypeIndexer) {\n          target.indexers.push(item);\n        }\n        else if (item instanceof ObjectTypeCallProperty) {\n          target.callProperties.push(item);\n        }\n        else {\n          throw new Error('ObjectType cannot contain the given type directly.');\n        }\n      }\n    }\n    return target;\n  }\n\n  exactObject <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const object = this.object(head, ...tail);\n    object.exact = true;\n    return object;\n  }\n\n  callProperty <T> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const target = new ObjectTypeCallProperty(this);\n    target.value = value;\n    return target;\n  }\n\n  property <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const target = new ObjectTypeProperty(this);\n    target.key = key;\n    if (value instanceof Type) {\n      target.value = value;\n    }\n    else {\n      target.value = this.object(value);\n    }\n    target.optional = optional;\n    return target;\n  }\n\n  indexer <K, V> (id: string, key: Type<K>, value: Type<V>): ObjectTypeIndexer<K, V> {\n    const target = new ObjectTypeIndexer(this);\n    target.id = id;\n    target.key = key;\n    target.value = value;\n    return target;\n  }\n\n  method <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const target = new ObjectTypeProperty(this);\n    target.key = name;\n    target.value = this.function(head, ...tail);\n    return target;\n  }\n\n  staticCallProperty <T: Function> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const prop = this.callProperty(value);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticProperty <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const prop = this.property(key, value, optional);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticMethod <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const prop = this.method(name, head, ...tail);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  spread <T> (...types: Type<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      if (Array.isArray(type.callProperties)) {\n        target.callProperties.push(...type.callProperties);\n      }\n      if (Array.isArray(type.indexers)) {\n        target.indexers.push(...type.indexers);\n      }\n      if (Array.isArray(type.properties)) {\n        for (let j = 0; j < type.properties.length; j++) {\n          const prop = type.properties[j];\n          invariant(prop instanceof ObjectTypeProperty);\n          target.setProperty(prop.key, prop.value, prop.optional);\n        }\n      }\n    }\n    return target;\n  }\n\n  tuple <T> (...types: Type<T>[]): TupleType<any> {\n    const target = new TupleType(this);\n    target.types = types;\n    return target;\n  }\n\n  array <T> (elementType?: Type<T>): ArrayType<T> {\n    const target = new ArrayType(this);\n    target.elementType = elementType || this.any();\n    return target;\n  }\n\n  union <T> (...types: Type<T>[]): Type<T> {\n    return makeUnion(this, types);\n  }\n\n  intersect <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    const target = new IntersectionType(this);\n    target.types = types;\n    return target;\n  }\n\n  intersection <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    return this.intersect(...types);\n  }\n\n  box <T> (reveal: TypeRevealer<T>): TypeBox<T> {\n    const box = new TypeBox(this);\n    box.reveal = reveal;\n    return box;\n  }\n\n  tdz <T> (reveal: TypeRevealer<T>, name?: string): TypeTDZ<T> {\n    const tdz = new TypeTDZ(this);\n    tdz.reveal = reveal;\n    tdz.name = name;\n    return tdz;\n  }\n\n  ref <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): Type<T | any> {\n    let target;\n    if (typeof subject === 'string') {\n      // try and eagerly resolve the reference\n      target = this.get(subject);\n      if (!target) {\n        // defer dereferencing for now\n        target = new TypeReference(this);\n        target.name = subject;\n      }\n    }\n    else if (typeof subject === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      // see if we have a dedicated TypeConstructor for this.\n      target = handlerRegistry.get(subject);\n\n      if (!target) {\n        // just use a generic type handler.\n        target = new GenericType(this);\n        target.impl = subject;\n        target.name = subject.name;\n      }\n\n    }\n    else if (subject instanceof Type) {\n      target = subject;\n    }\n    else {\n      if (subject == null || typeof subject !== 'object') {\n        this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n      }\n      else if (!warnedInvalidReferences.has(subject)) {\n        this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n        warnedInvalidReferences.add(subject);\n      }\n      return this.any();\n    }\n\n    if (typeInstances.length) {\n      invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n      return target.apply(...typeInstances);\n    }\n    else {\n      return target;\n    }\n  }\n\n  validate <T> (type: Type<T>, input: any, prefix: string = '', path?: string[]): Validation<T> {\n    const validation = new Validation(this, input);\n    if (path) {\n      validation.path.push(...path);\n    }\n    else if (typeof type.name === 'string') {\n      validation.path.push(type.name);\n    }\n    validation.prefix = prefix;\n    validation.errors = Array.from(type.errors(validation, [], input));\n    return validation;\n  }\n\n  check <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    if (this.mode === 'assert') {\n      return this.assert(type, input, prefix, path);\n    }\n    else {\n      return this.warn(type, input, prefix, path);\n    }\n  }\n\n  assert <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const error = this.makeTypeError(validation);\n    if (error) {\n      throw error;\n    }\n    return input;\n  }\n\n  warn <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const message = makeWarningMessage(validation);\n    if (typeof message === 'string') {\n      this.emitWarningMessage(message);\n    }\n    return input;\n  }\n\n  /**\n   * Emits a warning message, using `console.warn()` by default.\n   */\n  emitWarningMessage (message: string): void {\n    console.warn('flow-runtime:', message);\n  }\n\n  propTypes <T: {}> (type: Type<T>): PropTypeDict<T> {\n    return makeReactPropTypes((type.unwrap(): $FlowIgnore));\n  }\n\n  match <P, R> (...args: Array<P | MatchClause<P, R>>): R {\n    const clauses: any = args.pop();\n    if (!Array.isArray(clauses)) {\n      throw new Error('Invalid pattern, last argument must be an array.');\n    }\n    (clauses: MatchClause<P, R>[]);\n    const pattern = this.pattern(...clauses);\n    return pattern(...args);\n  }\n\n  pattern <P, R> (...clauses: MatchClause<P, R>[]): PatternMatcher<P, R> {\n    const {length} = clauses;\n    const tests: Array<true | FunctionType<P, R> | ParameterizedFunctionType<any, P, R>> = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const clause = clauses[i];\n      const annotation = this.getAnnotation(clause);\n      if (!annotation) {\n        if (i !== length - 1) {\n          throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n        }\n        tests[i] = true;\n      }\n      else {\n        invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n        tests[i] = annotation;\n      }\n    }\n    return (...args: P[]): R => {\n      for (let i = 0; i < tests.length; i++) {\n        const test = tests[i];\n        const clause = clauses[i];\n        if (test === true) {\n          return clause(...args);\n        }\n        else if (test.acceptsParams(...args)) {\n          return clause(...args);\n        }\n      }\n      const error = new TypeError('Value did not match any of the candidates.');\n      error.name = 'RuntimeTypeError';\n      throw error;\n    };\n  }\n\n  wrapIterator <T> (type: Type<T>): (input: Iterable<T>) => Generator<T, void, void> {\n    const t = this;\n    return function* wrappedIterator (input: Iterable<T>): Generator<T, void, void> {\n      for (const item of input) {\n        yield t.check(type, item);\n      }\n    };\n  }\n\n  refinement <T> (type: Type<T>, ...constraints: TypeConstraint[]): RefinementType<T> {\n    const target = new RefinementType(this);\n    target.type = type;\n    target.addConstraint(...constraints);\n    return target;\n  }\n\n  $exact <T> (type: Type<T>): ObjectType<T> {\n    const target = new ObjectType(this);\n    type = type.unwrap();\n    if (Array.isArray(type.callProperties)) {\n      target.callProperties.push(...type.callProperties);\n    }\n    if (Array.isArray(type.indexers)) {\n      target.indexers.push(...type.indexers);\n    }\n    if (Array.isArray(type.properties)) {\n      target.properties.push(...type.properties);\n    }\n    target.exact = true;\n    return target;\n  }\n\n  $diff <A: {}, B: {}> (aType: Type<A>, bType: Type<B>): $DiffType<A, B> {\n    const target = new $DiffType(this);\n    target.aType = aType;\n    target.bType = bType;\n    return target;\n  }\n\n  $flowFixMe (): $FlowFixMeType {\n    return new $FlowFixMeType(this);\n  }\n\n  $keys <T: {}> (type: Type<T>): $KeysType<T> {\n    const target = new $KeysType(this);\n    target.type = type;\n    return target;\n  }\n\n  $objMap <O: {}, K: $Keys<O>, M: (k: K) => any> (object: Type<O>, mapper: Type<M>): $ObjMapType<O, M> {\n    const target = new $ObjMapType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $objMapi <O: {}, K: $Keys<O>, M: (k: K, v: any) => any> (object: Type<O>, mapper: Type<M>): $ObjMapiType<O, M> {\n    const target = new $ObjMapiType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $propertyType <O: {}, P: string | number | Symbol> (object: Type<O>, property: P | Type<P>): _$PropertyType<O, P> {\n    const target = new _$PropertyType(this);\n    target.object = object;\n    if (property instanceof Type) {\n      const unwrapped = property.unwrap();\n      target.property = (unwrapped: any).value;\n    }\n    else {\n      target.property = property;\n    }\n    return target;\n  }\n\n  $shape <T: {}> (type: Type<T>): $ShapeType<T> {\n    const target = new $ShapeType(this);\n    target.type = type;\n    return target;\n  }\n\n  $subtype <T: {}> (type: Type<T>): $SubType<T> {\n    const target = new $SubType(this);\n    target.type = type;\n    return target;\n  }\n\n  $supertype <T: {}> (type: Type<T>): $SuperType<T> {\n    const target = new $SuperType(this);\n    target.type = type;\n    return target;\n  }\n\n  $tupleMap <T: [], M: (v: *) => *> (tuple: Type<T>, mapper: Type<M>): $TupleMapType<T, M> {\n    const target = new $TupleMapType(this);\n    target.tuple = tuple;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $values <T: {}> (type: Type<T>): $ValuesType<T> {\n    const target = new $ValuesType(this);\n    target.type = type;\n    return target;\n  }\n\n  Class <T: {}> (instanceType: Type<T>): ClassType<T> {\n    const target = new ClassType(this);\n    target.instanceType = instanceType;\n    return target;\n  }\n}\n\n","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeWarningMessage <T> (validation: Validation<T>): ? string {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  return `Warning: ${collected.join(delimiter)}`;\n}\n","/* @flow */\n\nimport makeError from './makeError';\n\nimport type ObjectType from './types/ObjectType';\n\nexport type PropType<T: {}> = (props: T, propName: string, componentName: string) => ? Error;\n\nexport type PropTypeDict<T: {}> = $ObjMap<T, <V>(v: V) => PropType<V>>;\n\nexport default function makeReactPropTypes <T: {}> (objectType: ObjectType<T>): PropTypeDict<T> {\n  const output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n  for (const property of objectType.properties) {\n    output[property.key] = (props, propName, componentName) => {\n      return makeError(property, props);\n    };\n  }\n  return output;\n}","/* @flow */\n\nimport registerPrimitiveTypes from './registerPrimitiveTypes';\nimport registerBuiltinTypeConstructors from './registerBuiltins';\nimport registerTypePredicates from './registerTypePredicates';\n\nimport TypeContext from './TypeContext';\n\nlet globalContext;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n}\nelse {\n  globalContext = new TypeContext();\n  registerPrimitiveTypes(globalContext);\n  registerBuiltinTypeConstructors(globalContext);\n  registerTypePredicates(globalContext);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext;\n  }\n}\n\n\nexport default globalContext;","/* @flow */\n\nimport primitiveTypes from './primitiveTypes';\n\nimport type TypeContext from './TypeContext';\n\nimport {\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\nexport default function registerPrimitiveTypes (t: TypeContext): TypeContext {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}","/* @flow */\nimport getErrorMessage from './getErrorMessage';\n\nimport invariant from './invariant';\n\nimport {Type} from './types';\n\nimport type TypeContext from './TypeContext';\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport default function registerBuiltinTypeConstructors (t: TypeContext): TypeContext {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n      if (!(input instanceof Date)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n      }\n      else if (isNaN(input.getTime())) {\n        yield [path, getErrorMessage('ERR_INVALID_DATE'), this];\n      }\n    },\n    accepts (input): boolean {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    compareWith(input) {\n      if (input.typeName === 'DateType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Date): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, futureType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(futureType, 'Must specify type parameter for Promise.');\n      const {context} = this;\n      if (!context.checkPredicate('Promise', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n      }\n    },\n    accepts (input): boolean {\n      const {context} = this;\n      return context.checkPredicate('Promise', input);\n    },\n    compareWith(input) {\n      if (input.typeName === 'PromiseType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: any): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, keyType?: Type<any>, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(keyType, 'Must specify two type parameters for Map.');\n      invariant(valueType, 'Must specify two type parameters for Map.');\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n        return;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key)) {\n          yield [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n        }\n\n        yield* valueType.errors(validation, path.concat(key), value);\n      }\n    },\n    accepts (input, keyType: Type<any>, valueType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key) || !valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'MapType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Map<*, *>): Type<any>[] {\n      const keyTypes = [];\n      const valueTypes = [];\n      loop: for (const [key, value] of input) {\n        findKey: {\n          for (let i = 0; i < keyTypes.length; i++) {\n            const type = keyTypes[i];\n            if (type.accepts(key)) {\n              break findKey;\n            }\n          }\n          keyTypes.push(t.typeOf(key));\n        }\n\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      const typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(valueType, 'Must specify type parameter for Set.');\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n        return;\n      }\n      for (const value of input) {\n        yield* valueType.errors(validation, path, value);\n      }\n    },\n    accepts (input, valueType) {\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      for (const value of input) {\n        if (!valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'SetType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Set<*>): Type<any>[] {\n      const valueTypes = [];\n      loop: for (const value of input) {\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      }\n      else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      }\n      else {\n        return [t.union(...valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nexport default function registerTypePredicates (context: TypeContext) {\n  context.setPredicate('Array', (input: any) => Array.isArray(input));\n  context.setPredicate('Map', (input: any) => input instanceof Map);\n  context.setPredicate('Set', (input: any) => input instanceof Set);\n  context.setPredicate('Promise', (input: any) => {\n    if (input instanceof Promise) {\n      return true;\n    } else {\n      return input !== null\n        && (typeof input === 'object' || typeof input === 'function')\n        && typeof input.then === 'function'\n        ;\n    }\n  });\n}\n","/* @flow */\n\nimport globalContext from './globalContext';\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  PartialType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType,\n  TypeParameterApplication\n} from './types';\n\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport TypeContext from './TypeContext';\n\nfunction v (thing) {\n  return { value: thing }\n}\n\nif (typeof global !== 'undefined' && global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== globalContext) {\n  Object.defineProperties(globalContext, {\n    TypeContext: v(TypeContext),\n    Type: v(Type),\n    TypeBox: v(TypeBox),\n    TypeParameter: v(TypeParameter),\n    TypeReference: v(TypeReference),\n    TypeTDZ: v(TypeTDZ),\n    ParameterizedTypeAlias: v(ParameterizedTypeAlias),\n    TypeAlias: v(TypeAlias),\n    TypeConstructor: v(TypeConstructor),\n    GenericType: v(GenericType),\n    NullLiteralType: v(NullLiteralType),\n    NumberType: v(NumberType),\n    NumericLiteralType: v(NumericLiteralType),\n    BooleanType: v(BooleanType),\n    BooleanLiteralType: v(BooleanLiteralType),\n    SymbolType: v(SymbolType),\n    SymbolLiteralType: v(SymbolLiteralType),\n    StringType: v(StringType),\n    StringLiteralType: v(StringLiteralType),\n    ArrayType: v(ArrayType),\n    ObjectType: v(ObjectType),\n    ObjectTypeCallProperty: v(ObjectTypeCallProperty),\n    ObjectTypeIndexer: v(ObjectTypeIndexer),\n    ObjectTypeProperty: v(ObjectTypeProperty),\n    FunctionType: v(FunctionType),\n    FunctionTypeParam: v(FunctionTypeParam),\n    FunctionTypeRestParam: v(FunctionTypeRestParam),\n    FunctionTypeReturn: v(FunctionTypeReturn),\n    ParameterizedFunctionType: v(ParameterizedFunctionType),\n    PartialType: v(PartialType),\n    RefinementType: v(RefinementType),\n    TypeParameterApplication: v(TypeParameterApplication),\n    GeneratorType: v(GeneratorType),\n    ExistentialType: v(ExistentialType),\n    FlowIntoType: v(FlowIntoType),\n    AnyType: v(AnyType),\n    MixedType: v(MixedType),\n    EmptyType: v(EmptyType),\n    NullableType: v(NullableType),\n    ThisType: v(ThisType),\n    TupleType: v(TupleType),\n    UnionType: v(UnionType),\n    IntersectionType: v(IntersectionType),\n    VoidType: v(VoidType),\n    Declaration: v(Declaration),\n    VarDeclaration: v(VarDeclaration),\n    TypeDeclaration: v(TypeDeclaration),\n    ModuleDeclaration: v(ModuleDeclaration),\n    ModuleExportsDeclaration: v(ModuleExportsDeclaration),\n    ClassDeclaration: v(ClassDeclaration),\n    ParameterizedClassDeclaration: v(ParameterizedClassDeclaration),\n    ExtendsDeclaration: v(ExtendsDeclaration),\n  })\n}\n\nexport default globalContext;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() {\n  return this || (typeof self === \"object\" && self);\n})() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() {\n    return this || (typeof self === \"object\" && self);\n  })() || Function(\"return this\")()\n);\n"],"sourceRoot":""}