"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var errors_1 = require("./errors");
exports.LITERAL_KINDS = [
    ts.SyntaxKind.LiteralType,
    ts.SyntaxKind.NumericLiteral,
    ts.SyntaxKind.StringLiteral,
    ts.SyntaxKind.TrueKeyword,
    ts.SyntaxKind.FalseKeyword
];
exports.AMBIENT_KINDS = [
    ts.SyntaxKind.InterfaceDeclaration,
    ts.SyntaxKind.TypeAliasDeclaration,
];
function asArray(value) {
    return Array.isArray(value) ? value : !value ? [] : [value];
}
exports.asArray = asArray;
function asNewArray(value) {
    return Array.isArray(value) ? value.length > 0 ? value.slice() : [] : !value ? [] : [value];
}
exports.asNewArray = asNewArray;
function arrayFromNodeArray(value) {
    return !value ? [] : value.slice();
}
exports.arrayFromNodeArray = arrayFromNodeArray;
function hasTypeParameters(node) {
    return Array.isArray(node.typeParameters) && node.typeParameters.length > 0;
}
exports.hasTypeParameters = hasTypeParameters;
function hasProperty(obj, prop) {
    return obj && obj.hasOwnProperty(prop);
}
exports.hasProperty = hasProperty;
function hasArrayProperty(obj, prop) {
    return hasProperty(obj, prop) && Array.isArray(obj[prop]);
}
exports.hasArrayProperty = hasArrayProperty;
function hasNonEmptyArrayProperty(obj, prop) {
    return hasArrayProperty(obj, prop) && obj[prop].length > 0;
}
exports.hasNonEmptyArrayProperty = hasNonEmptyArrayProperty;
function hasKind(node, kind) {
    if (!node) {
        return false;
    }
    if (node.kind === kind) {
        return true;
    }
    return ts.forEachChild(node, function (n) { return hasKind(n, kind); }) || false;
}
exports.hasKind = hasKind;
function hasModifier(node, modifier) {
    for (var _i = 0, _a = node.modifiers || []; _i < _a.length; _i++) {
        var flag = _a[_i];
        if (flag.kind === modifier) {
            return true;
        }
    }
    return false;
}
exports.hasModifier = hasModifier;
function hasFlag(node, flag) {
    return !!(node.flags & flag);
}
exports.hasFlag = hasFlag;
function setParent(node) {
    if (!node)
        return node;
    ts.forEachChild(node, function (n) {
        n.parent = node;
        setParent(n);
    });
    return node;
}
exports.setParent = setParent;
function isAnyKeyword(node) {
    if (!node) {
        return false;
    }
    if (node.kind === ts.SyntaxKind.AnyKeyword) {
        return true;
    }
    return false;
}
exports.isAnyKeyword = isAnyKeyword;
function isSynthesized(node) {
    return (node.flags & ts.NodeFlags.Synthesized) === ts.NodeFlags.Synthesized;
}
exports.isSynthesized = isSynthesized;
function isAmbient(node) {
    do {
        if (isKind.apply(void 0, [node].concat(exports.AMBIENT_KINDS))) {
            return true;
        }
    } while (node = node.parent);
    return false;
}
exports.isAmbient = isAmbient;
function isAmbientDeclaration(node) {
    do {
        if (hasModifier(node, ts.SyntaxKind.DeclareKeyword)) {
            return true;
        }
    } while (node = node.parent);
    return false;
}
exports.isAmbientDeclaration = isAmbientDeclaration;
function isPartOfTypeNode(node) {
    while (node && node.parent) {
        if (ts.isTypeNode(node)) {
            return true;
        }
        node = node.parent;
    }
    return false;
}
exports.isPartOfTypeNode = isPartOfTypeNode;
function isBindingPattern(node) {
    return ts.isArrayBindingPattern(node) || ts.isObjectBindingPattern(node);
}
exports.isBindingPattern = isBindingPattern;
function isStatic(node) {
    return !Array.isArray(node.modifiers) ? false : node.modifiers.findIndex(function (el) { return el.kind === ts.SyntaxKind.StaticKeyword; }) !== -1;
}
exports.isStatic = isStatic;
function isTypeParameter(node) {
    var nodeName = getEntityNameText(node.typeName);
    while (node = node.parent) {
        if (node.typeParameters && node.typeParameters.length > 0) {
            if (node.typeParameters.find(function (param) {
                return param.name.text === nodeName;
            })) {
                return true;
            }
        }
    }
    return false;
}
exports.isTypeParameter = isTypeParameter;
function isTypeParameterOf(node, typeParameters) {
    if (!ts.isTypeReferenceNode(node)) {
        return false;
    }
    var nodeName = getEntityNameText(node.typeName);
    for (var _i = 0, typeParameters_1 = typeParameters; _i < typeParameters_1.length; _i++) {
        var typeParameter = typeParameters_1[_i];
        if (typeParameter.name.text === nodeName) {
            return true;
        }
    }
    return false;
}
exports.isTypeParameterOf = isTypeParameterOf;
function isTypeParameterOfClass(node) {
    var current = node;
    while (current = current.parent) {
        if (ts.isClassDeclaration(current)) {
            if (isTypeParameterOf(node, arrayFromNodeArray(current.typeParameters))) {
                return current;
            }
            return null;
        }
    }
    return null;
}
exports.isTypeParameterOfClass = isTypeParameterOfClass;
function isInStaticContext(node) {
    var current = node;
    while (current = current.parent) {
        if (isStatic(current)) {
            return true;
        }
    }
    return false;
}
exports.isInStaticContext = isInStaticContext;
function isSuperStatement(node) {
    return ts.isExpressionStatement(node) && ts.isCallExpression(node.expression) &&
        node.expression.expression.kind === ts.SyntaxKind.SuperKeyword;
}
exports.isSuperStatement = isSuperStatement;
function isKind(node) {
    var kind = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        kind[_i - 1] = arguments[_i];
    }
    return kind.indexOf(node.kind) !== -1;
}
exports.isKind = isKind;
function isBindingName(node) {
    return ts.isIdentifier(node) || this.isBindingPattern(node);
}
exports.isBindingName = isBindingName;
function isLiteral(node) {
    return exports.LITERAL_KINDS.indexOf(node.kind) !== -1;
}
exports.isLiteral = isLiteral;
function getHash(str) {
    var hash = 5381, i = str.length;
    while (i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
    }
    return hash >>> 0;
}
exports.getHash = getHash;
function getHashedDeclarationName(name, fileName) {
    return name + "." + getHash(fileName);
}
exports.getHashedDeclarationName = getHashedDeclarationName;
function getIdentifierOfEntityName(node) {
    if (ts.isIdentifier(node)) {
        return node;
    }
    return node.right;
}
exports.getIdentifierOfEntityName = getIdentifierOfEntityName;
function getBaseIdentifierOfEntityName(node) {
    while (ts.isQualifiedName(node)) {
        node = node.left;
    }
    return node;
}
exports.getBaseIdentifierOfEntityName = getBaseIdentifierOfEntityName;
function getExtendsClause(node) {
    return node.heritageClauses && node.heritageClauses.find(function (clause) {
        if (clause.token === ts.SyntaxKind.ExtendsKeyword) {
            return true;
        }
    });
}
exports.getExtendsClause = getExtendsClause;
function getImplementsClause(node) {
    return node.heritageClauses && node.heritageClauses.find(function (clause) {
        if (clause.token === ts.SyntaxKind.ImplementsKeyword) {
            return true;
        }
    });
}
exports.getImplementsClause = getImplementsClause;
function getExpression(node) {
    while (node.expression) {
        node = node.expression;
    }
    return node;
}
exports.getExpression = getExpression;
function getPropertyAccessExpressionTextOrFail(node) {
    var text = '';
    while (ts.isPropertyAccessExpression(node)) {
        text += "." + node.name.text;
        node = node.expression;
    }
    if (node.kind !== ts.SyntaxKind.Identifier) {
        throw new errors_1.ProgramError('Can\'t get text of property access expression that contains other expressions than property access expression.');
    }
    text = "" + node.text + text;
    return text;
}
exports.getPropertyAccessExpressionTextOrFail = getPropertyAccessExpressionTextOrFail;
function getIdentifierOfPropertyAccessExpressionOrFail(node) {
    var expression = node.expression;
    while (expression.kind === ts.SyntaxKind.PropertyAccessExpression) {
        expression = expression.expression;
    }
    if (expression.kind !== ts.SyntaxKind.Identifier) {
        throw new errors_1.ProgramError('Can\'t get identifier of property access expression that contains other expressions than property access expression.');
    }
    return expression;
}
exports.getIdentifierOfPropertyAccessExpressionOrFail = getIdentifierOfPropertyAccessExpressionOrFail;
function getEntityNameText(node) {
    if (ts.isIdentifier(node)) {
        return node.text;
    }
    var left = getEntityNameText(node.left);
    var right = node.right.text;
    return left + "." + right;
}
exports.getEntityNameText = getEntityNameText;
function insertBeforeSuper(statements, insert, offset) {
    if (offset === void 0) { offset = 0; }
    var index = statements.findIndex(function (statement) { return isSuperStatement(statement); });
    insert = asArray(insert);
    if (index !== -1) {
        statements.splice.apply(statements, [index + offset, 0].concat(insert));
    }
    else {
        statements.unshift.apply(statements, insert);
        // statements.splice(statements.length, 0, ...insert);
    }
    return statements;
}
exports.insertBeforeSuper = insertBeforeSuper;
function insertAfterSuper(statements, insert, offset) {
    if (offset === void 0) { offset = 0; }
    return this.insertBeforeSuper(statements, insert, 1);
}
exports.insertAfterSuper = insertAfterSuper;
function declarationCanHaveTypeAnnotation(node) {
    var current = node;
    if (ts.isVariableDeclaration(current) && current.parent) {
        current = current.parent;
    }
    if (ts.isVariableDeclarationList(current) && current.parent) {
        current = current.parent;
    }
    switch (current.kind) {
        case ts.SyntaxKind.ForOfStatement:
        case ts.SyntaxKind.ForInStatement:
        case ts.SyntaxKind.CatchClause:
        case ts.SyntaxKind.ImportClause:
            return false;
    }
    return true;
}
exports.declarationCanHaveTypeAnnotation = declarationCanHaveTypeAnnotation;
function extendsClauseHasTypeArguments(node) {
    return node && node.types && node.types[0] && node.types[0].typeArguments && node.types[0].typeArguments.length > 0;
}
exports.extendsClauseHasTypeArguments = extendsClauseHasTypeArguments;
function canHaveType(node) {
    if (!node) {
        return false;
    }
    switch (node.kind) {
        case ts.SyntaxKind.VariableDeclaration:
        case ts.SyntaxKind.ObjectBindingPattern:
        case ts.SyntaxKind.ArrayBindingPattern:
        case ts.SyntaxKind.Parameter:
        case ts.SyntaxKind.PropertySignature:
        case ts.SyntaxKind.PropertyDeclaration:
        case ts.SyntaxKind.MethodSignature:
        case ts.SyntaxKind.CallSignature:
        case ts.SyntaxKind.ConstructSignature:
        case ts.SyntaxKind.IndexSignature:
        case ts.SyntaxKind.MethodDeclaration:
        case ts.SyntaxKind.GetAccessor:
        case ts.SyntaxKind.FunctionExpression:
        case ts.SyntaxKind.ArrowFunction:
        case ts.SyntaxKind.FunctionDeclaration:
            return true;
    }
    return false;
}
exports.canHaveType = canHaveType;
function annotateWithAny(node) {
    switch (node.kind) {
        case ts.SyntaxKind.VariableDeclaration:
            if (!declarationCanHaveTypeAnnotation(node)) {
                return false;
            }
        case ts.SyntaxKind.ObjectBindingPattern:
        case ts.SyntaxKind.ArrayBindingPattern:
        case ts.SyntaxKind.Parameter:
        case ts.SyntaxKind.PropertySignature:
        case ts.SyntaxKind.PropertyDeclaration:
        case ts.SyntaxKind.MethodSignature:
        case ts.SyntaxKind.CallSignature:
        case ts.SyntaxKind.ConstructSignature:
        case ts.SyntaxKind.IndexSignature:
        case ts.SyntaxKind.MethodDeclaration:
        case ts.SyntaxKind.GetAccessor:
        case ts.SyntaxKind.FunctionExpression:
        case ts.SyntaxKind.ArrowFunction:
        case ts.SyntaxKind.FunctionDeclaration:
            node.type = ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
            node.type.parent = node;
            return true;
    }
    return false;
}
exports.annotateWithAny = annotateWithAny;
