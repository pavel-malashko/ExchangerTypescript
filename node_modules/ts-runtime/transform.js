"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var format = require("pretty-time");
var rimraf = require("rimraf");
var commondir = require("commondir");
var ts = require("typescript");
var util = require("./util");
var bus = require("./bus");
var context_1 = require("./context");
var mutators_1 = require("./mutators");
var host_1 = require("./host");
var options_1 = require("./options");
var scanner_1 = require("./scanner");
var start, elapsed;
function transform(rootNames, options) {
    return result(transformProgram(rootNames, options));
}
exports.transform = transform;
function transformReflection(rootNames, reflections, options) {
    return result(transformProgram(rootNames, options, reflections));
}
exports.transformReflection = transformReflection;
function getOptions(options) {
    if (options === void 0) { options = {}; }
    var opts = Object.assign({}, options_1.defaultOptions, options);
    var compilerOptions = Object.assign(ts.getDefaultCompilerOptions(), options_1.defaultOptions.compilerOptions, options && options.compilerOptions || {});
    opts.compilerOptions = compilerOptions;
    return opts;
}
exports.getOptions = getOptions;
function result(host) {
    if (!host)
        return [];
    return host.getResult();
}
function transformProgram(rootNames, options, reflections) {
    if (!reflections)
        start = elapsed = process.hrtime();
    var entryFiles = util
        .asArray(rootNames)
        .map(function (file) { return path.normalize(file); })
        .map(function (file) { return !path.extname(file) ? file + '.ts' : file; });
    options = getOptions(options);
    emit(bus.events.START);
    var resolvedEntryFiles;
    var commonDir;
    var host;
    if (!reflections) {
        resolvedEntryFiles = entryFiles.map(function (f) { return path.resolve(f); });
        commonDir = commondir(resolvedEntryFiles.map(function (f) { return path.dirname(f); }));
        setCompilerOptions();
        host = ts.createCompilerHost(options.compilerOptions, true);
    }
    else {
        resolvedEntryFiles = entryFiles.map(function (f) { return path.join("" + path.resolve(path.dirname(f)), path.basename(f)); });
        commonDir = commondir(resolvedEntryFiles.map(function (f) { return path.dirname(f); }));
        reflections = reflections.map(function (f) {
            return {
                name: path.join("" + path.resolve(path.dirname(f.name)), path.basename(f.name)),
                text: f.text
            };
        });
        setCompilerOptions();
        setCompilerOptionsForReflection();
        host = new host_1.Host(reflections, options.compilerOptions, true);
    }
    var tempBasePath = options.compilerOptions.rootDir;
    var program;
    var scanner;
    var context;
    var currentSourceFile;
    return startTransformation();
    function startTransformation() {
        program = ts.createProgram(resolvedEntryFiles, options.compilerOptions, host);
        var _a = getDiagnostics(), diagnostics = _a.diagnostics, optionsDiagnostics = _a.optionsDiagnostics, syntacticDiagnostics = _a.syntacticDiagnostics;
        if (options.compilerOptions.noEmitOnError === false) {
            options.force = true;
        }
        if (!check(diagnostics, options.log) && (!options.force)) {
            emit(bus.events.STOP);
            return;
        }
        if (optionsDiagnostics.length > 0) {
            emit(bus.events.STOP);
            return;
        }
        if (syntacticDiagnostics.length > 0) {
            emit(bus.events.STOP);
            return;
        }
        if (options.compilerOptions.declaration) {
            options.compilerOptions.emitDeclarationOnly = true;
            program.emit();
            options.compilerOptions.declaration = false;
            options.compilerOptions.emitDeclarationOnly = false;
        }
        var sourceFiles = program.getSourceFiles().filter(function (sf) { return !sf.isDeclarationFile; });
        emit(bus.events.SCAN, getElapsedTime());
        scanner = new scanner_1.Scanner(program, options);
        emit(bus.events.TRANSFORM, sourceFiles, getElapsedTime());
        var result = ts.transform(sourceFiles, [transformer], options.compilerOptions);
        emit(bus.events.EMIT, getElapsedTime());
        if (!emitTransformed(result) && !options.force) {
            emit(bus.events.STOP);
            return;
        }
        emitDeclarations();
        result.dispose();
        emit(bus.events.END, getElapsedTime(), getElapsedTime(true));
        emit(bus.events.STOP, true);
        return host;
    }
    ;
    function emitTransformed(result) {
        if (!options.compilerOptions.outFile && !options.compilerOptions.outDir) {
            options.compilerOptions.outDir = commonDir;
        }
        host = getHostFromTransformationResult(result);
        program = ts.createProgram(resolvedEntryFiles, __assign({}, options.compilerOptions, { noEmitOnError: false }), host, program);
        var diagnostics = program.emit().diagnostics;
        return check(diagnostics, options.log);
    }
    function emitDeclarations() {
        var filename = options.declarationFileName + ".js";
        var outDir = getOutDir();
        var location = path.join(outDir, filename);
        if (!reflections)
            rimraf.sync(location);
        var printerOptions = {
            removeComments: false
        };
        var printHandlers = {
            substituteNode: function (hint, node) {
                node.parent = undefined;
                node.flags |= ts.NodeFlags.Synthesized;
                return node;
            }
        };
        var printer = ts.createPrinter(printerOptions, printHandlers);
        var sourceFile = ts.createSourceFile(filename, '', options.compilerOptions.target, true, ts.ScriptKind.TS);
        var expressions = [];
        var names = [];
        var processed = 0;
        var declarations;
        var length;
        do {
            declarations = scanner.getDeclarations();
            length = declarations.length;
            if (length < 1) {
                return;
            }
            for (var i = 0; i < declarations.length - processed; i++) {
                if (names.indexOf(declarations[i].name) !== -1) {
                    continue;
                }
                names.push(declarations[i].name);
                expressions.unshift.apply(expressions, context.factory.namedDeclarationsReflections(declarations[i].name, declarations[i].symbol.getDeclarations(), declarations[i].originalName));
            }
            processed = length;
        } while (length !== scanner.getDeclarations().length);
        if (expressions.length < 1) {
            return;
        }
        sourceFile = ts.updateSourceFileNode(sourceFile, [
            context.factory.importLibStatement()
        ].concat(expressions.map(function (exp) {
            return ts.createStatement(exp);
        })));
        var printed = printer.printFile(sourceFile);
        var transpiled = ts.transpile(printed, options.compilerOptions);
        var writeHost = !reflections ? ts.sys : host;
        writeHost.writeFile(location, transpiled);
    }
    function createMutationContext(node, transformationContext) {
        if (ts.isSourceFile(node) && currentSourceFile !== node) {
            currentSourceFile = node;
            context = new context_1.MutationContext(node, options, program, host, scanner, resolvedEntryFiles, commonDir, transformationContext);
        }
    }
    // TODO: add source map range in mutators
    // TODO: infer implicit types and add to global declarations immediately
    // TODO: support (recursive) opt-in only mode via verify<FooType>(value);
    function transformer(transformationContext) {
        var visitor = function (node) {
            var original = node;
            if (node && !node.type) {
                if (util.annotateWithAny(node)) {
                    // do nothing for now
                }
            }
            node = ts.visitEachChild(node, visitor, transformationContext);
            if (node !== original) {
                scanner.mapNode(node, original);
            }
            if (node && !node.parent) {
                node.parent = original.parent;
                util.setParent(node);
            }
            for (var _i = 0, _a = mutators_1.getMutators(); _i < _a.length; _i++) {
                var mutator = _a[_i];
                var previous = node;
                node = mutator.mutateNode(node, context);
                if (node !== previous) {
                    scanner.mapNode(node, previous);
                }
                if (node && !node.parent) {
                    node.parent = previous.parent;
                    util.setParent(node);
                }
            }
            if (!node) {
                return node;
            }
            return node;
        };
        return function (sf) {
            createMutationContext(sf, transformationContext);
            return ts.visitNode(sf, visitor);
        };
    }
    function setCompilerOptions() {
        if (options.compilerOptions.outFile) {
            options.compilerOptions.outFile = path.resolve(options.compilerOptions.outFile);
        }
        else if (options.compilerOptions.outDir) {
            options.compilerOptions.outDir = path.resolve(options.compilerOptions.outDir);
        }
        if (options.compilerOptions.rootDir) {
            options.compilerOptions.rootDir = path.resolve(options.compilerOptions.rootDir);
        }
        else {
            options.compilerOptions.rootDir = commonDir;
        }
        if (options.compilerOptions.noEmitOnError) {
            var warning = 'Compiler option \'noEmitOnError\' is the default behavior.';
            options.compilerOptions.noEmitOnError = false;
            emit(bus.events.WARN, warning);
            if (options.log)
                console.warn(warning);
        }
        if (!options.compilerOptions.preserveConstEnums) {
            var warning = 'Compiler option \'emitDeclarationOnly\' is not supported.';
            options.compilerOptions.preserveConstEnums = true;
            emit(bus.events.WARN, warning);
            if (options.log)
                console.warn(warning);
        }
        if (!options.compilerOptions.preserveConstEnums) {
            var warning = 'Compiler option \'preserveConstEnums\' was enabled.';
            options.compilerOptions.preserveConstEnums = true;
            emit(bus.events.WARN, warning);
            if (options.log)
                console.warn(warning);
        }
        if (!options.compilerOptions.experimentalDecorators) {
            var warning = 'Compiler option \'experimentalDecorators\' was enabled.';
            options.compilerOptions.experimentalDecorators = true;
            emit(bus.events.WARN, warning);
            if (options.log)
                console.warn(warning);
        }
    }
    function setCompilerOptionsForReflection() {
    }
    function getHostFromTransformationResult(result) {
        var previousHost = host;
        var printer = ts.createPrinter();
        var files = [];
        for (var _i = 0, _a = result.transformed; _i < _a.length; _i++) {
            var transformed = _a[_i];
            var name = transformed.fileName;
            var text = printer.printFile(transformed);
            files.push({ name: name, text: text });
        }
        var newHost = new host_1.Host(files, options.compilerOptions);
        newHost.setNewLine(previousHost.getNewLine());
        newHost.setCurrentDirectory(previousHost.getCurrentDirectory());
        newHost.setDefaultLibFileName(previousHost.getDefaultLibFileName(options.compilerOptions));
        newHost.setDefaultLibLocation(previousHost.getDefaultLibLocation());
        newHost.setUseCaseSensitiveFileNames(previousHost.useCaseSensitiveFileNames());
        newHost.writeFile = function writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles) {
            this.outputs.set(fileName, data);
            previousHost.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);
        };
        return newHost;
    }
    function getDiagnostics() {
        var diagnostics = [];
        var optionsDiagnostics = [];
        var globalDiagnostics = [];
        var syntacticDiagnostics = [];
        var semanticDiagnostics = [];
        optionsDiagnostics.push.apply(optionsDiagnostics, program.getOptionsDiagnostics());
        globalDiagnostics.push.apply(globalDiagnostics, program.getGlobalDiagnostics());
        for (var _i = 0, _a = program.getSourceFiles().filter(function (sf) { return !/\.d\.ts$/.test(sf.fileName); }); _i < _a.length; _i++) {
            var sourceFile = _a[_i];
            syntacticDiagnostics.push.apply(syntacticDiagnostics, program.getSyntacticDiagnostics(sourceFile));
            semanticDiagnostics.push.apply(semanticDiagnostics, program.getSemanticDiagnostics(sourceFile));
        }
        diagnostics.push.apply(diagnostics, optionsDiagnostics.concat(globalDiagnostics, syntacticDiagnostics, semanticDiagnostics));
        return {
            diagnostics: diagnostics,
            optionsDiagnostics: optionsDiagnostics,
            globalDiagnostics: globalDiagnostics,
            syntacticDiagnostics: syntacticDiagnostics,
            semanticDiagnostics: semanticDiagnostics
        };
    }
    function getOutDir() {
        if (options.compilerOptions.outFile) {
            return path.dirname(options.compilerOptions.outFile);
        }
        if (options.compilerOptions.outDir) {
            return options.compilerOptions.outDir;
        }
        return commonDir;
    }
    function check(diagnostics, log, report) {
        if (log === void 0) { log = false; }
        if (report === void 0) { report = true; }
        if (diagnostics && diagnostics.length > 0) {
            if (report) {
                emit(bus.events.DIAGNOSTICS, diagnostics, diagnostics.length);
            }
            if (log) {
                for (var _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {
                    var diag = diagnostics_1[_i];
                    console.error(ts.formatDiagnostics([diag], {
                        getCurrentDirectory: function () { return ''; },
                        getNewLine: function () { return '\n'; },
                        getCanonicalFileName: function (f) { return f; }
                    }).trim());
                }
            }
            return false;
        }
        return true;
    }
    function emit(event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return bus.emit(event, args);
    }
    function getElapsedTime(fromBeginning) {
        if (fromBeginning === void 0) { fromBeginning = false; }
        if (reflections) {
            return '';
        }
        var time = process.hrtime(fromBeginning ? start : elapsed);
        if (!fromBeginning)
            elapsed = process.hrtime();
        return format(time, fromBeginning ? 'ms' : void 0);
    }
}
