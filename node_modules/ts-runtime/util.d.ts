import * as ts from 'typescript';
export declare const LITERAL_KINDS: ts.SyntaxKind[];
export declare const AMBIENT_KINDS: ts.SyntaxKind[];
export declare function asArray<T>(value: T | T[]): T[];
export declare function asNewArray<T>(value: T | T[]): T[];
export declare function arrayFromNodeArray<T extends ts.Node>(value: ts.NodeArray<T>): T[];
export declare function hasTypeParameters(node: ts.Node): boolean;
export declare function hasProperty(obj: any, prop: string): boolean;
export declare function hasArrayProperty(obj: any, prop: string): boolean;
export declare function hasNonEmptyArrayProperty(obj: any, prop: string): boolean;
export declare function hasKind(node: ts.Node, kind: ts.SyntaxKind): boolean;
export declare function hasModifier(node: ts.Node, modifier: ts.SyntaxKind): boolean;
export declare function hasFlag(node: ts.Node | ts.Symbol, flag: ts.NodeFlags | ts.SymbolFlags): boolean;
export declare function setParent(node: ts.Node): ts.Node;
export declare function isAnyKeyword(node: ts.Node): boolean;
export declare function isSynthesized(node: ts.Node): boolean;
export declare function isAmbient(node: ts.Node): boolean;
export declare function isAmbientDeclaration(node: ts.Node): boolean;
export declare function isPartOfTypeNode(node: ts.Node): boolean;
export declare function isBindingPattern(node: ts.Node): node is ts.BindingPattern;
export declare function isStatic(node: ts.Node): boolean;
export declare function isTypeParameter(node: ts.TypeReferenceNode): boolean;
export declare function isTypeParameterOf(node: ts.TypeNode, typeParameters: ts.TypeParameterDeclaration[]): boolean;
export declare function isTypeParameterOfClass(node: ts.TypeReferenceNode): ts.ClassDeclaration;
export declare function isInStaticContext(node: ts.TypeReferenceNode): boolean;
export declare function isSuperStatement(node: ts.Node): boolean;
export declare function isKind(node: ts.Node, ...kind: ts.SyntaxKind[]): boolean;
export declare function isBindingName(node: ts.Node): node is ts.Identifier | ts.BindingPattern | ts.ArrayBindingPattern;
export declare function isLiteral(node: ts.Node): node is ts.LiteralTypeNode | ts.NumericLiteral | ts.BooleanLiteral | ts.StringLiteral;
export declare function getHash(str: string): number;
export declare function getHashedDeclarationName(name: string, fileName: string): string;
export declare function getIdentifierOfEntityName(node: ts.EntityName): ts.Identifier;
export declare function getBaseIdentifierOfEntityName(node: ts.EntityName): ts.Identifier;
export declare function getExtendsClause(node: ts.InterfaceDeclaration | ts.ClassDeclaration): ts.HeritageClause;
export declare function getImplementsClause(node: ts.InterfaceDeclaration | ts.ClassDeclaration): ts.HeritageClause;
export declare function getExpression(node: ts.Node): ts.Expression;
export declare function getPropertyAccessExpressionTextOrFail(node: ts.PropertyAccessExpression): string;
export declare function getIdentifierOfPropertyAccessExpressionOrFail(node: ts.PropertyAccessExpression): ts.Identifier;
export declare function getEntityNameText(node: ts.EntityName): string;
export declare function insertBeforeSuper(statements: ts.Statement[], insert: ts.Statement | ts.Statement[], offset?: number): ts.Statement[];
export declare function insertAfterSuper(statements: ts.Statement[], insert: ts.Statement | ts.Statement[], offset?: number): ts.Statement[];
export declare function declarationCanHaveTypeAnnotation(node: ts.Node): boolean;
export declare function extendsClauseHasTypeArguments(node: ts.HeritageClause): boolean;
export declare function canHaveType(node: any): node is {
    type: ts.TypeNode;
};
export declare function annotateWithAny(node: ts.Node): boolean;
