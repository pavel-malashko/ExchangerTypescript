"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var ts = require("typescript");
var util = require("./util");
var Scanner = /** @class */ (function () {
    function Scanner(program, options) {
        this.declarations = [];
        this.aliases = new Map();
        this.properties = new Map();
        this.scanned = new Set();
        this.identifiers = new Map();
        this.symbols = new Map();
        // private skip: ts.SyntaxKind[] = [
        //   ts.SyntaxKind.NamedImports,
        //   ts.SyntaxKind.NamespaceImport,
        //   ts.SyntaxKind.ImportClause,
        //   ts.SyntaxKind.SourceFile,
        //   ts.SyntaxKind.EndOfFileToken,
        //   ts.SyntaxKind.ObjectBindingPattern,
        //   ts.SyntaxKind.ArrayBindingPattern,
        //   ts.SyntaxKind.VariableDeclaration,
        // ];
        this.scanNodes = [
            ts.SyntaxKind.Identifier,
            ts.SyntaxKind.QualifiedName,
            ts.SyntaxKind.ExpressionWithTypeArguments,
            ts.SyntaxKind.ComputedPropertyName,
            ts.SyntaxKind.TypeReference,
            ts.SyntaxKind.MethodSignature,
            ts.SyntaxKind.MethodDeclaration,
            ts.SyntaxKind.CallSignature,
            ts.SyntaxKind.CallExpression,
            ts.SyntaxKind.FunctionDeclaration,
            ts.SyntaxKind.FunctionExpression,
            ts.SyntaxKind.ArrowFunction,
            ts.SyntaxKind.Constructor,
            ts.SyntaxKind.GetAccessor,
            ts.SyntaxKind.SetAccessor,
            ts.SyntaxKind.Parameter,
            ts.SyntaxKind.PropertySignature,
            ts.SyntaxKind.PropertyDeclaration,
            ts.SyntaxKind.ConstructSignature,
            ts.SyntaxKind.TypeAliasDeclaration,
        ];
        this.AllowedDeclarations = ts.SymbolFlags.Interface | ts.SymbolFlags.Class |
            ts.SymbolFlags.RegularEnum | ts.SymbolFlags.ConstEnum | ts.SymbolFlags.Enum |
            ts.SymbolFlags.EnumMember | ts.SymbolFlags.TypeAlias | ts.SymbolFlags.Function |
            /* ts.SymbolFlags.TypeLiteral | */ ts.SymbolFlags.Variable;
        this.DisallowedDeclaratins = ts.SymbolFlags.None;
        this._options = options;
        this._program = program;
        this._checker = program.getTypeChecker();
        this.scan();
    }
    Scanner.prototype.scan = function () {
        var sourceFiles = this.program
            .getSourceFiles()
            .filter(function (sf) { return !sf.isDeclarationFile; });
        for (var _i = 0, sourceFiles_1 = sourceFiles; _i < sourceFiles_1.length; _i++) {
            var sourceFile = sourceFiles_1[_i];
            this.scanRecursive(sourceFile);
        }
        return;
    };
    Scanner.prototype.mapNode = function (alias, original) {
        if (alias === original) {
            return;
        }
        this.aliases.set(alias, original);
        return alias;
    };
    Scanner.prototype.getTypeInfo = function (node) {
        return this.properties.get(this.getNode(node));
    };
    Scanner.prototype.getNodeSymbol = function (node) {
        return this.symbols.get(this.getNode(node));
    };
    Scanner.prototype.hasNodeSymbol = function (node) {
        return this.symbols.has(this.getNode(node));
    };
    Scanner.prototype.hasTypeInfo = function (node) {
        return this.properties.has(this.getNode(node));
    };
    Scanner.prototype.getNode = function (node) {
        node = this.getAliasedNode(node);
        if (this.properties.has(node)) {
            return node;
        }
        this.scanNode(node);
        return this.getAliasedNode(node);
    };
    Scanner.prototype.getAliasedNode = function (node) {
        while (this.aliases.has(node)) {
            node = this.aliases.get(node);
        }
        return node;
    };
    Scanner.prototype.getSymbol = function (type, node) {
        var symbol;
        if (type) {
            symbol = type.aliasSymbol || type.symbol;
        }
        if (!symbol && node) {
            symbol = this.checker.getSymbolAtLocation(node);
        }
        return symbol;
    };
    /**
     * Take a look at src/transform.ts to see, how to obtain all ambient and external declarations recursively
     */
    Scanner.prototype.getDeclarations = function () {
        return this.declarations;
    };
    Scanner.prototype.getSymbols = function () {
        return this.symbols;
    };
    Scanner.prototype.getIdentifiers = function (sf) {
        return this.identifiers.get(this.getAliasedNode(sf));
    };
    Scanner.prototype.isAllowedDeclarationSymbol = function (symbol) {
        return symbol && symbol.flags && ((symbol.flags & this.AllowedDeclarations) && !(symbol.flags & this.DisallowedDeclaratins));
    };
    Scanner.prototype.hasDeclarations = function (symbol) {
        return symbol && symbol.declarations && symbol.declarations.length > 0;
    };
    Scanner.prototype.pathIsExternal = function (fileName) {
        var r = this.program.getCompilerOptions().rootDir;
        var rootDir = !r ? '' : r + path.sep;
        return !fileName.startsWith(rootDir);
    };
    Scanner.prototype.getType = function (node) {
        var isTypeNode = ts.isTypeNode(node);
        if (isTypeNode) {
            return this.checker.getTypeFromTypeNode(node);
        }
        if (node.type) {
            return this.checker.getTypeFromTypeNode(node.type);
        }
        return this.checker.getTypeAtLocation(node);
    };
    Scanner.prototype.getTypeNode = function (node, type, enclosing) {
        var isTypeNode = ts.isTypeNode(node);
        if (isTypeNode) {
            return node;
        }
        if (node.type && ts.isTypeNode(node.type)) {
            return node.type;
        }
        return this.checker.typeToTypeNode(type, enclosing);
    };
    Scanner.prototype.getBaseType = function (type) {
        return this.checker.getBaseTypeOfLiteralType(type);
    };
    Scanner.prototype.scanRecursive = function (entry) {
        var _this = this;
        var scanNode = function (node) {
            _this.scanNode(node);
            ts.forEachChild(node, scanNode);
        };
        ts.forEachChild(entry, scanNode);
    };
    Scanner.prototype.scanNode = function (node) {
        var _this = this;
        if (ts.isParameter(node) && node.name) {
            this.mapNode(node, node.name);
            return this.scanNode(node.name);
        }
        if (ts.isIdentifier(node)) {
            var sf = node.getSourceFile();
            if (!this.identifiers.has(sf)) {
                this.identifiers.set(sf, new Set());
            }
            this.identifiers.get(sf).add(node.text);
        }
        // let nodeSymbol = this.checker.getSymbolAtLocation(
        //   (node as any).name || (node as any).typeName ||
        //   (node as any).exprName || (node as any).tagName
        // );
        //
        var nodeSymbol = this.checker.getSymbolAtLocation(node);
        if (nodeSymbol) {
            this.symbols.set(node, nodeSymbol);
        }
        if (!this.shouldScan(node)) {
            ts.forEachChild(node, function (n) { return _this.scanNode(n); });
            return;
        }
        node = this.getMappedNode(node);
        var typeInfo = new TypeInfo(this, node);
        // TODO: improve check if a declaration should be added
        if (typeInfo.isTsrDeclaration() && !ts.isParameter(node.parent)) {
            this.addDeclaration(typeInfo.symbol, typeInfo.fileNames[0]);
        }
        if (node !== typeInfo.typeNode) {
            util.setParent(typeInfo.typeNode);
            this.mapNode(typeInfo.typeNode, node);
        }
        this.properties.set(node, typeInfo);
        return node;
    };
    Scanner.prototype.shouldScan = function (node) {
        if (!node) {
            return false;
        }
        // if (this.skip.indexOf(node.kind) !== -1) {
        //   return false;
        // }
        if (this.scanNodes.indexOf(node.kind) === -1) {
            return false;
        }
        if (this.scanned.has(node)) {
            return false;
        }
        this.scanned.add(node);
        return true;
    };
    Scanner.prototype.getMappedNode = function (node) {
        if (ts.isAsExpression(node)) {
            return this.getAsExpression(node);
        }
        node = this.getNameExpression(node);
        return node;
    };
    Scanner.prototype.getNameExpression = function (node) {
        var expr = node;
        if (node.typeName) {
            expr = node.typeName;
        }
        // if ((node as any).exprName) {
        //   expr = (node as any).exprName;
        // }
        // if ((node as any).parameterName) {
        //   expr = (node as any).parameterName;
        // }
        // if ((node as any).name) {
        //   expr = (node as any).name;
        // }
        //
        // if ((node as any).tagName) {
        //   expr = (node as any).tagName;
        // }
        if (expr !== node) {
            this.mapNode(node, expr);
        }
        return expr;
    };
    Scanner.prototype.getAsExpression = function (node) {
        var expression = node.expression;
        this.mapNode(node, expression);
        return expression;
    };
    Scanner.prototype.addDeclaration = function (symbol, fileName) {
        if (!symbol)
            return;
        var name = this.checker.getFullyQualifiedName(symbol);
        var uid = util.getHashedDeclarationName(name, fileName);
        var index = this.declarations.findIndex(function (decl) { return decl.symbol === symbol; });
        if (index === -1) {
            this.declarations.unshift({ symbol: symbol, name: uid, originalName: name });
        }
    };
    Object.defineProperty(Scanner.prototype, "options", {
        get: function () {
            return this._options;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scanner.prototype, "program", {
        get: function () {
            return this._program;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Scanner.prototype, "checker", {
        get: function () {
            return this._checker;
        },
        enumerable: true,
        configurable: true
    });
    return Scanner;
}());
exports.Scanner = Scanner;
var TypeInfo = /** @class */ (function () {
    function TypeInfo(scanner, enclosing) {
        this.scanner = scanner;
        this._enclosing = enclosing;
    }
    TypeInfo.prototype.isTsrDeclaration = function () {
        if (this._isTsrDeclaration === undefined) {
            if (this.isExternal && !this.scanner.options.libDeclarations && !this.isExternalModule) {
                return this._isTsrDeclaration = false;
            }
            this._isTsrDeclaration = this.TSR_DECLARATION &&
                this.scanner.isAllowedDeclarationSymbol(this.symbol)
                && (util.isPartOfTypeNode(this.enclosing) || (this.isInDeclarationFile));
        }
        return this._isTsrDeclaration;
    };
    TypeInfo.prototype.hasDeclarations = function () {
        return this.symbol && this.symbol.declarations && this.symbol.declarations.length > 0;
    };
    Object.defineProperty(TypeInfo.prototype, "TSR_DECLARATION", {
        get: function () {
            if (this._TSR_DECLARATION === undefined) {
                this._TSR_DECLARATION = ((this.isExternal && (this.isAmbient || this.isDeclaration || this.isInDeclarationFile) ||
                    (!this.isExternal && (this.isDeclaration || this.isInDeclarationFile))));
            }
            return this._TSR_DECLARATION;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "symbol", {
        get: function () {
            if (this._symbol === undefined) {
                this._symbol = this.scanner.getSymbol(this.type, this.enclosing);
                if (this._symbol === undefined) {
                    this._symbol = null;
                }
            }
            return this._symbol;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "enclosing", {
        get: function () {
            return this._enclosing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "sourceFiles", {
        // get sourceFile(): ts.SourceFile {
        //   return (this.firstDeclaration && this.firstDeclaration.getSourceFile()) || (this.enclosing && this.enclosing.getSourceFile());
        // }
        get: function () {
            var sfs = this.declarations.map(function (declaration) { return declaration.getSourceFile(); });
            var esf = this.enclosing && this.enclosing.getSourceFile();
            if (sfs.indexOf(esf) === -1) {
                sfs.push(esf);
            }
            return sfs.filter(function (sf) { return !!(sf && ts.isSourceFile(sf)); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "fileNames", {
        // get fileName(): string {
        //   return this.sourceFile && this.sourceFile.fileName;
        // }
        get: function () {
            return this.sourceFiles.map(function (sf) { return sf.fileName; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "declarations", {
        get: function () {
            if (!this.symbol || !this.symbol.declarations) {
                return [];
            }
            return this.symbol.getDeclarations();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "type", {
        // get firstDeclaration(): ts.Declaration {
        //   return this.declarations[0];
        // }
        get: function () {
            if (!this._type) {
                this._type = this.scanner.getType(this.enclosing);
            }
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "typeText", {
        get: function () {
            if (!this._typeText) {
                this._typeText = this.scanner.checker.typeToString(this.type, this.enclosing);
            }
            return this._typeText;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "typeNode", {
        get: function () {
            if (!this._typeNode) {
                this._typeNode = this.scanner.getTypeNode(this.enclosing, this.type);
            }
            return this._typeNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "baseType", {
        get: function () {
            if (this.isLiteral && !this._baseType) {
                this._baseType = this.scanner.getBaseType(this.type);
            }
            return this._baseType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "baseTypeNode", {
        get: function () {
            if (this.isLiteral && !this._baseTypeNode) {
                this._baseTypeNode = this.scanner.checker.typeToTypeNode(this.baseType, this.enclosing);
            }
            return this._baseTypeNode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "baseTypeText", {
        get: function () {
            if (this.isLiteral && !this._baseTypeNode) {
                this._baseTypeText = this.scanner.checker.typeToString(this.baseType, this.enclosing);
            }
            return this._baseTypeText;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "isSynthesized", {
        get: function () {
            if (this._isSynthesized === undefined) {
                this._isSynthesized = util.isSynthesized(this.typeNode);
            }
            return this._isSynthesized;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "isReference", {
        get: function () {
            if (this._isReference === undefined) {
                this._isReference = ts.isTypeReferenceNode(this.typeNode);
            }
            return this._isReference;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "isLiteral", {
        get: function () {
            if (this._isLiteral === undefined) {
                this._isLiteral = util.isLiteral(this.typeNode);
            }
            return this._isLiteral;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "isAmbient", {
        get: function () {
            if (this.hasDeclarations() && this._isAmbient === undefined) {
                var results = this.declarations.map(function (declaration) { return util.isAmbient(declaration); });
                this._isAmbient = results.indexOf(true) !== -1;
            }
            return this._isAmbient;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "isDeclaration", {
        get: function () {
            if (this.hasDeclarations() && this._isDeclaration === undefined) {
                var results = this.declarations.map(function (declaration) { return util.isAmbientDeclaration(declaration); });
                this._isDeclaration = results.indexOf(true) !== -1;
            }
            return this._isDeclaration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "isInDeclarationFile", {
        get: function () {
            if (this._isInDeclarationFile === undefined) {
                var results = this.sourceFiles.map(function (sf) { return sf.isDeclarationFile; });
                this._isInDeclarationFile = results.indexOf(true) !== -1;
            }
            return this._isInDeclarationFile;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "isExternal", {
        get: function () {
            var _this = this;
            if (this.hasDeclarations() && this._isExternal === undefined) {
                var results = this.sourceFiles.map(function (sf) { return _this.scanner.pathIsExternal(sf.fileName); });
                this._isExternal = results.indexOf(true) !== -1;
            }
            return this._isExternal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeInfo.prototype, "isExternalModule", {
        get: function () {
            if (this.hasDeclarations() && this._isExternalModule === undefined) {
                var results = this.sourceFiles.map(function (sf) { return ts.isExternalModule(sf); });
                this._isExternalModule = results.indexOf(true) !== -1;
            }
            return this._isExternalModule;
        },
        enumerable: true,
        configurable: true
    });
    return TypeInfo;
}());
exports.TypeInfo = TypeInfo;
