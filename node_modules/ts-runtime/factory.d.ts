import * as ts from 'typescript';
import { Options } from './options';
import { Scanner } from './scanner';
import { MutationContext } from './context';
export declare type FunctionDeclarationLikeNode = ts.ArrowFunction | ts.FunctionDeclaration | ts.FunctionExpression | ts.ArrowFunction | ts.ConstructorDeclaration | ts.MethodDeclaration | ts.SetAccessorDeclaration | ts.GetAccessorDeclaration;
export declare type FunctionLikeNode = ts.FunctionExpression | ts.ArrowFunction | ts.FunctionDeclaration | ts.FunctionTypeNode | ts.ConstructorTypeNode | ts.ConstructorDeclaration | ts.CallSignatureDeclaration | ts.ConstructSignatureDeclaration | ts.MethodSignature | ts.MethodDeclaration | ts.SetAccessorDeclaration | ts.GetAccessorDeclaration;
export declare type MethodLikeNode = ts.ConstructorTypeNode | ts.ConstructorDeclaration | ts.CallSignatureDeclaration | ts.ConstructSignatureDeclaration | ts.MethodSignature | ts.MethodDeclaration | ts.SetAccessorDeclaration | ts.GetAccessorDeclaration;
export declare type ElementLikeNode = ts.TypeElement | ts.ClassElement;
export declare class Factory {
    private _context;
    private _state;
    private _strictNullChecks;
    private _namespace;
    private _lib;
    private _load;
    private _warnings;
    constructor(_context: MutationContext, options: Options, library?: string);
    private proxy;
    typeReflection(node: ts.TypeNode): ts.Expression;
    private warn;
    typeDeclaration(name: string | ts.Identifier, node: ts.TypeNode): ts.VariableDeclaration;
    typeAssertion(id: string | ts.Expression, args?: ts.Expression | ts.Expression[]): ts.CallExpression;
    typeReflectionAndAssertion(node: ts.TypeNode, args?: ts.Expression | ts.Expression[]): ts.CallExpression;
    anyTypeReflection(): ts.CallExpression;
    numberTypeReflection(): ts.CallExpression;
    booleanTypeReflection(): ts.CallExpression;
    stringTypeReflection(): ts.CallExpression;
    symbolTypeReflection(): ts.CallExpression;
    objectTypeReflection(): ts.CallExpression;
    voidTypeReflection(): ts.CallExpression;
    nullTypeReflection(): ts.CallExpression;
    undefinedTypeReflection(): ts.CallExpression;
    thisTypeReflection(): ts.CallExpression;
    literalTypeReflection(node: ts.LiteralTypeNode): ts.CallExpression;
    booleanLiteralTypeReflection(node: ts.BooleanLiteral): ts.CallExpression;
    numericLiteralTypeReflection(node: ts.NumericLiteral): ts.CallExpression;
    stringLiteralTypeReflection(node: ts.StringLiteral): ts.CallExpression;
    arrayTypeReflection(node: ts.ArrayTypeNode): ts.CallExpression;
    tupleTypeReflection(node: ts.TupleTypeNode): ts.CallExpression;
    unionTypeReflection(node: ts.UnionTypeNode): ts.CallExpression;
    intersectionTypeReflection(node: ts.IntersectionTypeNode): ts.CallExpression;
    typeReferenceReflection(node: ts.TypeReferenceNode): ts.Expression;
    functionTypeReflection(node: ts.FunctionTypeNode): ts.CallExpression;
    constructorTypeReflection(node: ts.ConstructorTypeNode): ts.CallExpression;
    typeQueryReflection(node: ts.TypeQueryNode): ts.CallExpression;
    typeLiteralReflection(node: ts.TypeLiteralNode): ts.CallExpression;
    expressionWithTypeArgumentsReflection(node: ts.ExpressionWithTypeArguments): ts.CallExpression;
    typeAliasReflection(node: ts.TypeAliasDeclaration, name?: string): ts.Expression;
    typeAliasSubstitution(node: ts.TypeAliasDeclaration): ts.VariableStatement;
    interfaceReflection(node: ts.InterfaceDeclaration, name?: string): ts.Expression;
    interfaceSubstitution(node: ts.InterfaceDeclaration): ts.Statement;
    classReflection(node: ts.ClassDeclaration, name?: string): ts.Expression;
    namedDeclarationsReflections(name: string, declarations: ts.Declaration[], originalName?: string): ts.Expression[];
    namedDeclarationReflection(name: string, declaration: ts.Declaration, originalName?: string): ts.Expression;
    enumReflection(node: ts.EnumDeclaration): ts.CallExpression;
    enumMemberReflection(node: ts.EnumMember): ts.CallExpression;
    variableReflection(node: ts.VariableDeclaration): ts.Expression;
    functionReflection(node: FunctionLikeNode, asCallProperty?: boolean): ts.CallExpression;
    returnTypeReflection(node: ts.TypeNode): ts.CallExpression;
    typeParameterReflection(typeParameter: ts.TypeParameterDeclaration, prop?: string): ts.CallExpression;
    indexSignatureReflection(node: ts.IndexSignatureDeclaration): ts.CallExpression;
    propertySignatureReflection(node: ts.PropertySignature | ts.PropertyDeclaration): ts.CallExpression;
    propertyReflection(node: ts.PropertyDeclaration): ts.CallExpression;
    callSignatureReflection(node: ts.CallSignatureDeclaration | ts.ConstructSignatureDeclaration): ts.CallExpression;
    constructSignatureReflection(node: ts.ConstructSignatureDeclaration): ts.CallExpression;
    constructorReflection(node: ts.ConstructorDeclaration): ts.CallExpression;
    methodReflection(node: MethodLikeNode): ts.CallExpression;
    methodSignatureReflection(node: MethodLikeNode): ts.CallExpression;
    getAccessorReflection(node: ts.GetAccessorDeclaration): ts.CallExpression;
    setAccessorReflection(node: ts.SetAccessorDeclaration): ts.CallExpression;
    parameterReflection(param: ts.ParameterDeclaration, reflectType?: boolean): ts.CallExpression;
    elementReflection(node: ts.TypeElement | ts.ClassElement): ts.CallExpression;
    elementsReflection(nodes: (ts.TypeElement | ts.ClassElement)[], merge?: boolean): ts.Expression[];
    private mergedElementsReflection;
    classTypeParameterSymbolDeclaration(name: string | ts.Identifier): ts.VariableDeclarationList;
    classTypeParameterSymbolConstructorDeclaration(name: string | ts.Identifier): ts.ExpressionStatement;
    classTypeParameterSymbolPropertyDeclaration(name: string | ts.Identifier): ts.PropertyDeclaration;
    typeParameterDeclaration(typeParameter: ts.TypeParameterDeclaration, prop?: string): ts.VariableStatement;
    typeParametersLiteral(typeParameters: ts.TypeParameterDeclaration[], asStatement?: boolean): ts.Expression;
    typeParametersLiteralDeclaration(typeParameters: ts.TypeParameterDeclaration[]): ts.VariableStatement;
    typeParameterBindingDeclaration(typeArguments: ts.TypeNode[]): ts.ExpressionStatement;
    assertReturnStatements<T extends ts.Node>(node: T, type?: ts.TypeNode): T;
    mutateFunctionBody<T extends FunctionDeclarationLikeNode>(n: T): T;
    propertyNameToLiteralOrExpression(node: ts.PropertyName): ts.Expression | ts.StringLiteral | ts.NumericLiteral;
    declarationNameToLiteralOrExpression(node: ts.DeclarationName): ts.Expression | ts.StringLiteral | ts.NumericLiteral;
    importLibStatement(): ts.ImportDeclaration;
    importDeclarationsStatement(): ts.ImportDeclaration;
    decorate(expressions: ts.Expression | ts.Expression[]): ts.CallExpression;
    annotate(expressions: ts.Expression | ts.Expression[]): ts.CallExpression;
    nullable<T extends ts.Expression>(reflection: T): T | ts.CallExpression;
    nostrict<T extends ts.Expression>(reflection: T): T | ts.CallExpression;
    intersect(args: ts.Expression | ts.Expression[]): ts.CallExpression;
    flowInto(args: ts.Expression | ts.Expression[]): ts.CallExpression;
    tdz(body: ts.Identifier, name?: string): ts.CallExpression;
    selfReference(name: string | ts.Identifier | ts.ObjectBindingPattern | ts.ArrayBindingPattern, body: ts.ConciseBody): ts.ArrowFunction;
    asObject(nodes: ts.Expression[]): ts.CallExpression;
    asRef(arg: ts.Expression): ts.CallExpression;
    asType(name: string | ts.Identifier, args: ts.Expression | ts.Expression[], keyword?: string): ts.CallExpression;
    asClass(name: string | ts.Identifier, args: ts.Expression | ts.Expression[]): ts.CallExpression;
    asVar(name: string, expression: ts.Expression): ts.CallExpression;
    asStatement(expression: ts.Expression): ts.ExpressionStatement;
    libCall(prop: string | ts.Identifier, args?: ts.Expression | ts.Expression[]): ts.CallExpression;
    propertyAccessCall(id: string | ts.Expression, prop: string | ts.Identifier, args?: ts.Expression | ts.Expression[]): ts.CallExpression;
    private addState;
    private removeState;
    state(state: FactoryState): boolean;
    rule(rule: FactoryState[]): boolean;
    match(rule: FactoryState[], state: FactoryState): boolean;
    readonly scanner: Scanner;
    context: MutationContext;
    strictNullChecks: boolean;
    lib: string;
    readonly package: string;
    namespace: string;
    readonly warnings: string[];
}
export declare enum FactoryState {
    None = 0,
    TypeDeclaration = 1,
    TypeAssertion = 2,
    TypeDeclarationAndAssertion = 3,
    AnyTypeReflection = 4,
    NumberTypeReflection = 5,
    BooleanTypeReflection = 6,
    StringTypeReflection = 7,
    SymbolTypeReflection = 8,
    ObjectTypeReflection = 9,
    VoidTypeReflection = 10,
    NullTypeReflection = 11,
    UndefinedTypeReflection = 12,
    ThisTypeReflection = 13,
    LiteralTypeReflection = 14,
    BooleanLiteralTypeReflection = 15,
    NumericLiteralTypeReflection = 16,
    StringLiteralTypeReflection = 17,
    ArrayTypeReflection = 18,
    TupleTypeReflection = 19,
    UnionTypeReflection = 20,
    IntersectionTypeReflection = 21,
    TypeReferenceReflection = 22,
    FunctionTypeReflection = 23,
    ConstructorTypeReflection = 24,
    TypeQueryReflection = 25,
    TypeLiteralReflection = 26,
    ExpressionWithTypeArgumentsReflection = 27,
    TypeAliasReflection = 28,
    TypeAliasSubstitution = 29,
    InterfaceReflection = 30,
    InterfaceSubstitution = 31,
    ClassReflection = 32,
    NamedDeclarationReflection = 33,
    NamedDeclarationsReflections = 34,
    EnumReflection = 35,
    EnumMemberReflection = 36,
    VariableReflection = 37,
    FunctionReflection = 38,
    MethodSignatureReflection = 39,
    MethodReflection = 40,
    GetAccessorReflection = 41,
    SetAccessorReflection = 42,
    ConstructorReflection = 43,
    ParameterReflection = 44,
    ReturnTypeReflection = 45,
    TypeParameterReflection = 46,
    ElementReflection = 47,
    ElementsReflection = 48,
    MergedElementsReflection = 49,
    IndexSignatureReflection = 50,
    PropertySignatureReflection = 51,
    PropertyReflection = 52,
    CallSignatureReflection = 53,
    ConstructSignatureReflection = 54,
    ClassTypeParameterSymbolDeclaration = 55,
    ClassTypeParameterSymbolConstructorDeclaration = 56,
    ClassTypeParameterSymbolPropertyDeclaration = 57,
    TypeParameterDeclaration = 58,
    TypeParametersLiteral = 59,
    TypeParametersLiteralDeclaration = 60,
    TypeParameterBindingDeclaration = 61,
    AssertReturnStatements = 62,
    MutateFunctionBody = 63,
    ImportLibStatement = 64,
    ImportDeclarationsStatement = 65,
    Decorate = 66,
    Annotate = 67,
    Nullable = 68,
    NoStrict = 69,
    Intersect = 70,
    FlowInto = 71,
    Tdz = 72,
    SelfReference = 73,
    AsObject = 74,
    AsRef = 75,
    AsType = 76,
    AsClass = 77,
    AsVar = 78,
    AsStatement = 79
}
export declare const FactoryRule: {
    NoClassTypeParameterReflection: FactoryState[];
    NoFlowInto: FactoryState[];
    Nullable: FactoryState[];
    Property: FactoryState[];
};
