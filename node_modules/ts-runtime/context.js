"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var util = require("./util");
var errors_1 = require("./errors");
var factory_1 = require("./factory");
var MutationContext = /** @class */ (function () {
    function MutationContext(sourceFile, options, program, host, scanner, entryFiles, commonDir, context) {
        this._skipNodes = [];
        this._sourceFile = sourceFile;
        this._options = options;
        this._program = program;
        this._checker = program.getTypeChecker();
        this._host = host;
        this._scanner = scanner;
        this._factory = new factory_1.Factory(this, options);
        this._transformationContext = context;
        this._merged = new Set();
        this._entryFiles = entryFiles;
        this._commonDir = commonDir;
    }
    MutationContext.prototype.skip = function (node, recursive) {
        var _this = this;
        if (recursive === void 0) { recursive = false; }
        var exclude = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            exclude[_i - 2] = arguments[_i];
        }
        if (!this.shouldSkip(node) && exclude.indexOf(node) === -1) {
            this._skipNodes.push(node);
        }
        if (recursive) {
            ts.forEachChild(node, function (n) {
                _this.skip.apply(_this, [n, recursive].concat(exclude));
            });
        }
        return node;
    };
    MutationContext.prototype.shouldSkip = function (node) {
        if (this._skipNodes.indexOf(node) !== -1) {
            return true;
        }
        return false;
    };
    MutationContext.prototype.dontSkip = function (node) {
        var index = this._skipNodes.indexOf(node);
        if (index !== -1) {
            this._skipNodes.splice(index, 1);
            return true;
        }
        return false;
    };
    MutationContext.prototype.isEntryFile = function (fileName) {
        return this._entryFiles.indexOf(fileName) !== -1;
    };
    MutationContext.prototype.isImplementationOfOverload = function (node) {
        return !!(ts.isFunctionLike(node) && this.checker.isImplementationOfOverload(node));
    };
    MutationContext.prototype.isDeclared = function (node) {
        if (!node.getSourceFile()) {
            return false;
        }
        var fileName = node.getSourceFile().fileName;
        node = util.getBaseIdentifierOfEntityName(node);
        var typeInfo = this.scanner.getTypeInfo(node);
        var declarations = typeInfo.declarations
            .filter(function (d) { return fileName === d.getSourceFile().fileName; }) || [];
        if (declarations.length > 0) {
            return true;
        }
        return false;
    };
    MutationContext.prototype.wasDeclared = function (node) {
        if (!node.getSourceFile()) {
            return false;
        }
        var fileName = node.getSourceFile().fileName;
        node = util.getBaseIdentifierOfEntityName(node);
        var typeInfo = this.scanner.getTypeInfo(node);
        var declarations = typeInfo.declarations
            .filter(function (d) { return fileName === d.getSourceFile().fileName; });
        for (var _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
            var declaration = declarations_1[_i];
            if (declaration.getEnd() < node.getEnd()) {
                return true;
            }
        }
        return false;
    };
    // public pathIsOutsideRoot(fileName: string): boolean {
    //   const rootDir = this.program.getCompilerOptions().rootDir + path.sep;
    //   return !path.resolve(fileName).startsWith(path.resolve(rootDir));
    // }
    MutationContext.prototype.isAny = function (node) {
        if (util.isAnyKeyword(node)) {
            return true;
        }
        var typeInfo = this.scanner.getTypeInfo(node);
        if (!typeInfo || !typeInfo.typeNode) {
            return false;
        }
        if (util.isAnyKeyword(typeInfo.typeNode)) {
            return true;
        }
        var enclsoingSymbol = this.scanner.getNodeSymbol(typeInfo.enclosing);
        if (typeInfo.enclosing && this.scanner.getNodeSymbol(typeInfo.enclosing)) {
            if (enclsoingSymbol.valueDeclaration && util.canHaveType(enclsoingSymbol.valueDeclaration)) {
                if (enclsoingSymbol.valueDeclaration.type === undefined || util.isAnyKeyword(enclsoingSymbol.valueDeclaration.type)) {
                    return true;
                }
            }
        }
        if (typeInfo.symbol && typeInfo.symbol.valueDeclaration && util.canHaveType(typeInfo.symbol.valueDeclaration)) {
            if (typeInfo.symbol.valueDeclaration.type === undefined || util.isAnyKeyword(typeInfo.symbol.valueDeclaration.type)) {
                return true;
            }
        }
        return false;
    };
    MutationContext.prototype.isSelfReference = function (node) {
        var next = node;
        var typeInfo = this.scanner.getTypeInfo(node.typeName);
        while (next.parent) {
            next = next.parent;
            if (ts.isHeritageClause(node)) {
                return false;
            }
            if (ts.isClassDeclaration(next) || ts.isInterfaceDeclaration(next) || ts.isTypeAliasDeclaration(next)) {
                var symbol = this.scanner.getNodeSymbol(next.name);
                if (typeInfo.symbol === symbol && next.name.text === util.getIdentifierOfEntityName(node.typeName).text) {
                    return true;
                }
            }
        }
        return false;
    };
    // public isSafeAssignment(node: ts.Node, other: ts.Node, strict = false, force = false): boolean {
    //   if (this.options.assertSafe && !force) {
    //     return false;
    //   }
    //
    //   const typeInfo = this.scanner.getTypeInfo(node);
    //   const otherTypeInfo = this.scanner.getTypeInfo(other);
    //
    //   if (!typeInfo || !otherTypeInfo) {
    //     return false;
    //   }
    //
    //   let nodeTypeText = typeInfo.typeText;
    //   let otherTypeText = otherTypeInfo.typeText;
    //
    //   if (!nodeTypeText || !otherTypeText) {
    //     return false;
    //   }
    //
    //   if (!strict && nodeTypeText === 'any') {
    //     return true;
    //   }
    //
    //   if (!strict && !typeInfo.isLiteral && otherTypeInfo.isLiteral) {
    //     otherTypeText = otherTypeInfo.baseTypeText;
    //   }
    //
    //   return nodeTypeText === otherTypeText;
    // }
    MutationContext.prototype.hasSelfReference = function (node) {
        var symbol = this.scanner.getNodeSymbol(node.name || node.typeName || node);
        if (!symbol) {
            return false;
        }
        var declarations = symbol.getDeclarations();
        if (!declarations) {
            return false;
        }
        for (var _i = 0, _a = declarations || []; _i < _a.length; _i++) {
            var decl = _a[_i];
            if (this.hasApparentSelfReference(decl)) {
                return true;
            }
        }
        return false;
    };
    MutationContext.prototype.hasApparentSelfReference = function (node) {
        var _this = this;
        var nodeSymbol = this.scanner.getNodeSymbol(node.name || node.typeName || node);
        var search = function (node) {
            if (ts.isTypeReferenceNode(node)) {
                var symbol = _this.scanner.getNodeSymbol(node.typeName);
                if (nodeSymbol === symbol) {
                    return true;
                }
            }
            return ts.forEachChild(node, function (child) { return search(child); });
        };
        return search(node) || false;
    };
    MutationContext.prototype.hasProperty = function (node, name) {
        var nodeType = this.scanner.getType(node);
        if (!nodeType) {
            return false;
        }
        for (var _i = 0, _a = nodeType.getProperties(); _i < _a.length; _i++) {
            var prop = _a[_i];
            if (prop.name === name) {
                return true;
            }
        }
        return false;
    };
    // TODO: property names may not be unique
    MutationContext.prototype.getPropertyName = function (node, name) {
        var nodeType = this.scanner.getType(node);
        var originalName = name;
        if (!nodeType) {
            return name;
        }
        var ids = nodeType.getProperties().map(function (prop) {
            return prop.name;
        });
        while (ids && ids.indexOf(name) !== -1) {
            name = "_" + name;
        }
        // TODO: use a map to ensure unique name
        name = name + "_" + originalName;
        if (ids && ids.indexOf(name) !== -1) {
            return this.getPropertyName(node, name);
        }
        return name;
    };
    MutationContext.prototype.getIdentifier = function (text) {
        var ids = this.scanner.getIdentifiers(this.sourceFile);
        while (ids && ids.has(text)) {
            text = "_" + text;
        }
        return text;
    };
    MutationContext.prototype.getTypeDeclarationName = function (node) {
        var name = typeof node === 'string' ? node : node.text;
        return this.getIdentifier("" + this.options.declarationPrefix + name + "Type");
    };
    MutationContext.prototype.getReturnTypeDeclarationName = function () {
        return this.getTypeDeclarationName('return');
    };
    // public getInlineTypeName(node: string | ts.Identifier): string {
    //   const name = typeof node === 'string' ? node : node.text;
    //   return this.getIdentifier(`${this.options.declarationPrefix}${name}TypeInline`);
    // }
    MutationContext.prototype.getLibDeclarationName = function () {
        return this.getIdentifier("" + this.options.libNamespace + this.options.libIdentifier);
    };
    MutationContext.prototype.getTypeSymbolDeclarationName = function (node) {
        var name = typeof node === 'string' ? node : node.text;
        return this.getIdentifier("" + this.options.declarationPrefix + name + "TypeParametersSymbol");
    };
    MutationContext.prototype.getTypeSymbolDeclarationInitializer = function (node) {
        var name = typeof node === 'string' ? node : node.text;
        return this.getIdentifier(name + "TypeParameters");
    };
    MutationContext.prototype.getTypeParametersDeclarationName = function () {
        return this.getIdentifier(this.options.declarationPrefix + "typeParameters");
    };
    // public getLibTypeParameterSymbolName(): string {
    //   return 'TypeParametersSymbol';
    // }
    MutationContext.prototype.getMembers = function (node) {
        var nodeSymbol = this.scanner.getNodeSymbol(node.name);
        var merged = new Set();
        if (!nodeSymbol) {
            return util.arrayFromNodeArray(node.members);
        }
        var members = [];
        nodeSymbol.members.forEach(function (member, key) {
            if (member.flags & ts.SymbolFlags.TypeParameter) {
                return;
            }
            members.push(member);
        });
        members.forEach(function (sym) {
            for (var _i = 0, _a = (sym.getDeclarations() || []); _i < _a.length; _i++) {
                var typeElement = _a[_i];
                merged.add(typeElement);
            }
        });
        return Array.from(merged);
    };
    // public getAllMembers(node: ts.ClassDeclaration | ts.InterfaceDeclaration): (ts.TypeElement | ts.ClassElement)[] {
    //   const nodeSymbol = this.scanner.getNodeSymbol(node.name);
    //   const merged: Set<ts.TypeElement | ts.ClassElement> = new Set();
    //   let type: ts.Type;
    //
    //   if (!nodeSymbol) {
    //     type = this.checker.getTypeAtLocation(node);
    //   } else {
    //     type = this.checker.getDeclaredTypeOfSymbol(nodeSymbol);
    //   }
    //
    //   if (!type) {
    //     return util.arrayFromNodeArray(node.members as ts.NodeArray<ts.TypeElement | ts.ClassElement>);
    //   }
    //
    //   (type.getProperties() || []).forEach(sym => {
    //     for (let typeElement of (sym.getDeclarations() || [])) {
    //       if (ts.isTypeElement(typeElement) || ts.isClassElement(typeElement)) {
    //         merged.add(typeElement);
    //       }
    //     }
    //   });
    //
    //   return Array.from(merged);
    // }
    MutationContext.prototype.setMerged = function (symbol) {
        return this._merged.add(symbol);
    };
    MutationContext.prototype.wasMerged = function (symbol) {
        return this._merged.has(symbol);
    };
    Object.defineProperty(MutationContext.prototype, "sourceFile", {
        // public setTransformationContext(transformationContext: ts.TransformationContext): void {
        //   this.transformationContext = transformationContext;
        // }
        // public setSourceFile(sourceFile: ts.SourceFile): void {
        //   this.sourceFile = sourceFile;
        // }
        get: function () {
            return this._sourceFile;
        },
        set: function (sourceFile) {
            if (!ts.isSourceFile(sourceFile)) {
                throw new errors_1.ProgramError("Attemt to set invalid node as SourceFile on MutationContext.");
            }
            this._sourceFile = sourceFile;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "transformationContext", {
        get: function () {
            return this._transformationContext;
        },
        set: function (transformationContext) {
            this._transformationContext = transformationContext;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "compilerOptions", {
        get: function () {
            return this._options.compilerOptions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "options", {
        get: function () {
            return this._options;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "program", {
        get: function () {
            return this._program;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "checker", {
        get: function () {
            return this._checker;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "host", {
        get: function () {
            return this._host;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "scanner", {
        get: function () {
            return this._scanner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "factory", {
        get: function () {
            return this._factory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "map", {
        get: function () {
            return this._scanner.mapNode.bind(this._scanner);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "entryFiles", {
        get: function () {
            return this._entryFiles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutationContext.prototype, "commonDir", {
        get: function () {
            return this._commonDir;
        },
        enumerable: true,
        configurable: true
    });
    return MutationContext;
}());
exports.MutationContext = MutationContext;
