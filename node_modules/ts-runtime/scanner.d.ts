import * as ts from 'typescript';
import { Options } from './options';
export interface TsrDeclaration {
    symbol: ts.Symbol;
    name: string;
    originalName: string;
}
export declare class Scanner {
    private _options;
    private _program;
    private _checker;
    private declarations;
    private aliases;
    private properties;
    private scanned;
    private identifiers;
    private symbols;
    private scanNodes;
    private AllowedDeclarations;
    private DisallowedDeclaratins;
    constructor(program: ts.Program, options: Options);
    scan(): void;
    mapNode<T extends ts.Node>(alias: T, original: ts.Node): T;
    getTypeInfo(node: ts.Node): TypeInfo;
    getNodeSymbol(node: ts.Node): ts.Symbol;
    hasNodeSymbol(node: ts.Node): boolean;
    hasTypeInfo(node: ts.Node): boolean;
    getNode(node: ts.Node): ts.Node;
    getAliasedNode(node: ts.Node): ts.Node;
    getSymbol(type: ts.Type, node: ts.Node): ts.Symbol;
    /**
     * Take a look at src/transform.ts to see, how to obtain all ambient and external declarations recursively
     */
    getDeclarations(): TsrDeclaration[];
    getSymbols(): Map<ts.Node, ts.Symbol>;
    getIdentifiers(sf: ts.SourceFile): Set<string>;
    isAllowedDeclarationSymbol(symbol: ts.Symbol): boolean;
    hasDeclarations(symbol: ts.Symbol): boolean;
    pathIsExternal(fileName: string): boolean;
    getType(node: ts.Node): ts.Type;
    getTypeNode(node: ts.Node, type: ts.Type, enclosing?: ts.Node): ts.TypeNode;
    getBaseType(type: ts.Type): ts.Type;
    private scanRecursive;
    private scanNode;
    private shouldScan;
    private getMappedNode;
    private getNameExpression;
    private getAsExpression;
    private addDeclaration;
    readonly options: Options;
    readonly program: ts.Program;
    readonly checker: ts.TypeChecker;
}
export declare class TypeInfo {
    private scanner;
    private _symbol?;
    private _TSR_DECLARATION;
    private _isTsrDeclaration;
    private _enclosing?;
    private _fileName?;
    private _declarations;
    private _type;
    private _typeText;
    private _typeNode;
    private _baseType?;
    private _baseTypeNode?;
    private _baseTypeText?;
    private _isSynthesized;
    private _isReference;
    private _isLiteral;
    private _isExternalModule;
    private _isAmbient;
    private _isDeclaration;
    private _isExternal;
    private _isInDeclarationFile;
    constructor(scanner: Scanner, enclosing: ts.Node);
    isTsrDeclaration(): boolean;
    hasDeclarations(): boolean;
    private readonly TSR_DECLARATION;
    readonly symbol: ts.Symbol;
    readonly enclosing: ts.Node;
    readonly sourceFiles: ts.SourceFile[];
    readonly fileNames: string[];
    readonly declarations: ts.Declaration[];
    readonly type: ts.Type;
    readonly typeText: string;
    readonly typeNode: ts.TypeNode;
    readonly baseType: ts.Type;
    readonly baseTypeNode: ts.TypeNode;
    readonly baseTypeText: string;
    readonly isSynthesized: boolean;
    readonly isReference: boolean;
    readonly isLiteral: boolean;
    readonly isAmbient: boolean;
    readonly isDeclaration: boolean;
    readonly isInDeclarationFile: boolean;
    readonly isExternal: boolean;
    readonly isExternalModule: boolean;
}
