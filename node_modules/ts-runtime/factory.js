"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ts = require("typescript");
var util = require("./util");
var bus = require("./bus");
var errors_1 = require("./errors");
var Factory = /** @class */ (function () {
    function Factory(_context, options, library) {
        this._context = _context;
        this._state = new Map([[FactoryState.None, 1]]);
        this._namespace = '';
        this._lib = 't';
        this._load = 'ts-runtime/lib';
        this._warnings = [];
        this._strictNullChecks = !!options.compilerOptions.strictNullChecks;
        this._namespace = options.libNamespace || this._namespace;
        this._lib = options.libIdentifier || this._lib;
        this._load = library || this._load;
        return new Proxy(this, {
            get: this.proxy.bind(this)
        });
    }
    Factory.prototype.proxy = function (target, property, receiver) {
        var _this = this;
        var destination = target[property];
        if (typeof destination !== 'function') {
            return destination;
        }
        var states = FactoryState;
        var stateName = property.charAt(0).toUpperCase() + property.slice(1);
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var state = states[stateName];
            _this.addState(state);
            if (_this._state.size > 1) {
                _this.removeState(FactoryState.None);
            }
            var result = destination.bind(receiver).apply(void 0, args);
            if (_this.match(exports.FactoryRule.Nullable, state)) {
                result = _this.nostrict(result);
            }
            _this.removeState(state);
            if (_this._state.size === 0) {
                _this.addState(FactoryState.None);
            }
            return result;
        };
    };
    Factory.prototype.typeReflection = function (node) {
        if (!node) {
            return this.anyTypeReflection();
        }
        switch (node.kind) {
            case ts.SyntaxKind.ParenthesizedType:
                return this.typeReflection(node.type);
            case ts.SyntaxKind.AnyKeyword:
                return this.anyTypeReflection();
            case ts.SyntaxKind.NumberKeyword:
                return this.numberTypeReflection();
            case ts.SyntaxKind.BooleanKeyword:
                return this.booleanTypeReflection();
            case ts.SyntaxKind.StringKeyword:
                return this.stringTypeReflection();
            case ts.SyntaxKind.SymbolKeyword:
                return this.symbolTypeReflection();
            case ts.SyntaxKind.ObjectKeyword:
                return this.objectTypeReflection();
            case ts.SyntaxKind.VoidKeyword:
                return this.voidTypeReflection();
            case ts.SyntaxKind.NeverKeyword:
                return this.voidTypeReflection();
            case ts.SyntaxKind.NullKeyword:
                return this.nullTypeReflection();
            case ts.SyntaxKind.UndefinedKeyword:
                return this.undefinedTypeReflection();
            case ts.SyntaxKind.ThisKeyword:
            case ts.SyntaxKind.ThisType:
                return this.thisTypeReflection();
            case ts.SyntaxKind.LiteralType:
                return this.literalTypeReflection(node);
            case ts.SyntaxKind.ArrayType:
                return this.arrayTypeReflection(node);
            case ts.SyntaxKind.TupleType:
                return this.tupleTypeReflection(node);
            case ts.SyntaxKind.UnionType:
                return this.unionTypeReflection(node);
            case ts.SyntaxKind.IntersectionType:
                return this.intersectionTypeReflection(node);
            case ts.SyntaxKind.TypeReference:
                return this.typeReferenceReflection(node);
            case ts.SyntaxKind.FunctionType:
                return this.functionTypeReflection(node);
            case ts.SyntaxKind.ConstructorType:
                return this.constructorTypeReflection(node);
            case ts.SyntaxKind.TypeQuery:
                return this.typeQueryReflection(node);
            case ts.SyntaxKind.TypeLiteral:
                return this.typeLiteralReflection(node);
            // case ts.SyntaxKind.TypeParameter:
            case ts.SyntaxKind.TypePredicate:
                return this.booleanTypeReflection();
            case ts.SyntaxKind.ExpressionWithTypeArguments:
                return this.expressionWithTypeArgumentsReflection(node);
            case ts.SyntaxKind.MappedType:
                // type Readonly<T> = {
                //   readonly [P in keyof T]: T[P];
                // }
                this.warn('Mapped types are not yet supported.');
                return this.anyTypeReflection();
            case ts.SyntaxKind.IndexedAccessType:
                // function getProperty<T, K extends keyof T>(o: T, name: K): T[K] {
                //     return o[name]; // o[name] is of type T[K]
                // }
                this.warn('Indexed acces types are not yet supported.');
                return this.anyTypeReflection();
            case ts.SyntaxKind.TypeOperator:
                // let a: keyof MyClass;
                this.warn('Type operators are not yet supported.');
                return this.anyTypeReflection();
            default:
                throw new errors_1.ProgramError("No reflection for syntax kind '" + ts.SyntaxKind[node.kind] + "' found.");
        }
    };
    Factory.prototype.warn = function (warning) {
        bus.emit(bus.events.WARN, warning);
        if (this.context.options.log && this._warnings.indexOf(warning) === -1) {
            this._warnings.push(warning);
            console.warn(warning);
            return true;
        }
        return false;
    };
    Factory.prototype.typeDeclaration = function (name /* | ts.ObjectBindingPattern | ts.ArrayBindingPattern*/, node) {
        return ts.createVariableDeclaration(name, undefined, this.typeReflection(node));
    };
    Factory.prototype.typeAssertion = function (id, args) {
        if (args === void 0) { args = []; }
        return this.propertyAccessCall(id, 'assert', args);
    };
    Factory.prototype.typeReflectionAndAssertion = function (node, args) {
        if (args === void 0) { args = []; }
        return this.typeAssertion(this.typeReflection(node), args);
    };
    Factory.prototype.anyTypeReflection = function () {
        return this.libCall('any');
    };
    Factory.prototype.numberTypeReflection = function () {
        return this.libCall('number');
    };
    Factory.prototype.booleanTypeReflection = function () {
        return this.libCall('boolean');
    };
    Factory.prototype.stringTypeReflection = function () {
        return this.libCall('string');
    };
    Factory.prototype.symbolTypeReflection = function () {
        return this.libCall('symbol');
    };
    Factory.prototype.objectTypeReflection = function () {
        return this.libCall('object');
    };
    Factory.prototype.voidTypeReflection = function () {
        return this.libCall('void');
    };
    Factory.prototype.nullTypeReflection = function () {
        return this.libCall('null');
    };
    Factory.prototype.undefinedTypeReflection = function () {
        return this.libCall('undef');
    };
    Factory.prototype.thisTypeReflection = function () {
        return this.libCall('this', ts.createThis());
    };
    Factory.prototype.literalTypeReflection = function (node) {
        switch (node.literal.kind) {
            case ts.SyntaxKind.TrueKeyword:
            case ts.SyntaxKind.FalseKeyword:
                return this.booleanLiteralTypeReflection(node.literal);
            case ts.SyntaxKind.StringLiteral:
                return this.stringLiteralTypeReflection(node.literal);
            case ts.SyntaxKind.NumericLiteral:
                return this.numericLiteralTypeReflection(node.literal);
            default:
                throw new errors_1.ProgramError("No literal type reflection for syntax kind '" + ts.SyntaxKind[node.literal.kind] + "' found.");
        }
    };
    Factory.prototype.booleanLiteralTypeReflection = function (node) {
        return this.libCall('boolean', ts.createLiteral(node.kind === ts.SyntaxKind.TrueKeyword ? true : false));
    };
    Factory.prototype.numericLiteralTypeReflection = function (node) {
        return this.libCall('number', ts.createNumericLiteral(node.text));
    };
    Factory.prototype.stringLiteralTypeReflection = function (node) {
        return this.libCall('string', ts.createLiteral(node.text));
    };
    Factory.prototype.arrayTypeReflection = function (node) {
        return this.libCall('array', this.typeReflection(node.elementType));
    };
    Factory.prototype.tupleTypeReflection = function (node) {
        var _this = this;
        return this.libCall('tuple', node.elementTypes.map(function (n) { return _this.typeReflection(n); }));
    };
    Factory.prototype.unionTypeReflection = function (node) {
        var _this = this;
        return this.libCall('union', node.types.map(function (n) { return _this.typeReflection(n); }));
    };
    Factory.prototype.intersectionTypeReflection = function (node) {
        var _this = this;
        return this.libCall('intersection', node.types.map(function (n) { return _this.typeReflection(n); }));
    };
    Factory.prototype.typeReferenceReflection = function (node) {
        var _this = this;
        var typeNameText = util.getEntityNameText(node.typeName);
        var isArray = typeNameText.toLowerCase() === 'array';
        var typeInfo = this.scanner.getTypeInfo(node);
        var TSR_DECLARATION = typeInfo.isTsrDeclaration();
        var args = [];
        if (util.hasNonEmptyArrayProperty(node, 'typeArguments')) {
            node.typeArguments.forEach(function (typeArgument) {
                args.push(_this.typeReflection(typeArgument));
            });
        }
        if (isArray) {
            return this.libCall('array', args);
        }
        var isTypeParameter = util.isTypeParameter(node);
        var parentClass = !TSR_DECLARATION && isTypeParameter && util.isTypeParameterOfClass(node);
        var isClassTypeParameter = !!parentClass;
        var flowInto = isTypeParameter && !isClassTypeParameter && !this.rule(exports.FactoryRule.NoFlowInto);
        var asLiteral = !isTypeParameter && TSR_DECLARATION;
        var result;
        var identifier;
        var keyword = isTypeParameter ? null : 'ref';
        if (flowInto) {
            keyword = 'flowInto';
        }
        if (isClassTypeParameter && !this.rule(exports.FactoryRule.NoClassTypeParameterReflection)) {
            result = ts.createPropertyAccess(ts.createElementAccess(
            // Static members cannot reference class type parameters
            // util.isInStaticContext(node) ?
            // ts.createElementAccess(
            //   ts.createIdentifier(parentClass.name.text),
            //   ts.createPropertyAccess(
            //     ts.createIdentifier(this.lib),
            //     ts.createIdentifier(this.context.getLibTypeParameterSymbolName())
            //   )
            // ) :
            ts.createThis(), ts.createIdentifier(this.context.getTypeSymbolDeclarationName(parentClass.name.text))), typeNameText);
            return !keyword ? result : this.libCall(keyword, result);
        }
        var isSelfReference = this.context.isSelfReference(node);
        if (typeInfo && typeInfo.symbol) {
            if (util.hasFlag(typeInfo.symbol, ts.SymbolFlags.RegularEnum) || util.hasFlag(typeInfo.symbol, ts.SymbolFlags.ConstEnum)) {
                keyword = asLiteral ? 'ref' : 'enumRef';
            }
            else if (util.hasFlag(typeInfo.symbol, ts.SymbolFlags.EnumMember)) {
                keyword = asLiteral ? 'ref' : 'enumMember';
            }
        }
        if (asLiteral && !isSelfReference) {
            var sf = typeInfo.sourceFiles[0].fileName;
            var hash = util.getHash(sf);
            var name = this.context.checker.getFullyQualifiedName(typeInfo.symbol);
            name = name || typeNameText;
            name = name + "." + hash;
            identifier = ts.createLiteral(name);
        }
        else {
            identifier = ts.createIdentifier(typeNameText);
        }
        var tdz = !isSelfReference && !asLiteral && !isTypeParameter &&
            !this.context.wasDeclared(node.typeName) && this.context.isDeclared(node.typeName);
        if (!this.context.options.libDeclarations && !typeInfo.isExternalModule) {
            tdz = false;
        }
        if (tdz) {
            identifier = this.tdz(identifier);
        }
        args.unshift(identifier);
        return !keyword ? args[0] : this.libCall(keyword, args);
    };
    Factory.prototype.functionTypeReflection = function (node) {
        return this.functionReflection(node);
    };
    Factory.prototype.constructorTypeReflection = function (node) {
        return this.methodReflection(node);
    };
    Factory.prototype.typeQueryReflection = function (node) {
        var typeInfo = this.scanner.getTypeInfo(node.exprName);
        var text = util.getEntityNameText(node.exprName);
        var ref = ts.createIdentifier(text);
        if (typeInfo.isTsrDeclaration()) {
            text = util.getHashedDeclarationName(text, typeInfo.sourceFiles[0].fileName);
            ref = [ts.createLiteral(text), ts.createTrue()];
        }
        return this.libCall('typeOf', ref);
    };
    Factory.prototype.typeLiteralReflection = function (node) {
        return this.asObject(this.elementsReflection(util.arrayFromNodeArray(node.members)));
    };
    Factory.prototype.expressionWithTypeArgumentsReflection = function (node) {
        var _this = this;
        if (node.expression.kind !== ts.SyntaxKind.PropertyAccessExpression && node.expression.kind !== ts.SyntaxKind.Identifier) {
            throw new errors_1.ProgramError('An expression with type argument\â€™s left hand side expression must be a property access expression or an identifier.');
        }
        var identifier = node.expression.kind !== ts.SyntaxKind.Identifier ?
            util.getIdentifierOfPropertyAccessExpressionOrFail(node.expression) :
            node.expression;
        var typeInfo = this.scanner.getTypeInfo(node);
        var asLiteral = typeInfo && typeInfo.isTsrDeclaration();
        var keyword = 'ref';
        if (typeInfo && typeInfo.symbol) {
            if (util.hasFlag(typeInfo.symbol, ts.SymbolFlags.RegularEnum) || util.hasFlag(typeInfo.symbol, ts.SymbolFlags.ConstEnum)) {
                keyword = asLiteral ? 'ref' : 'typeOf';
                ;
            }
            else if (util.hasFlag(typeInfo.symbol, ts.SymbolFlags.EnumMember)) {
                keyword = asLiteral ? 'ref' : 'number';
            }
        }
        var args = [];
        var id;
        if (asLiteral) {
            var fileName = typeInfo.declarations[0].getSourceFile().fileName;
            var name = this.context.checker.getFullyQualifiedName(typeInfo.symbol);
            id = ts.createLiteral(util.getHashedDeclarationName(name, fileName));
        }
        else {
            var typeNameText = ts.isIdentifier(node.expression) ?
                node.expression.text :
                util.getPropertyAccessExpressionTextOrFail(node.expression);
            id = ts.createIdentifier(typeNameText);
        }
        var tdz = !asLiteral && !this.context.wasDeclared(identifier) && this.context.isDeclared(identifier);
        if (!this.context.options.libDeclarations && !typeInfo.isExternalModule) {
            tdz = false;
        }
        if (tdz) {
            id = this.tdz(id);
        }
        args.push(id);
        args.push.apply(args, util.arrayFromNodeArray(node.typeArguments).map(function (a) { return _this.typeReflection(a); }));
        return this.libCall(keyword, args);
    };
    Factory.prototype.typeAliasReflection = function (node, name) {
        var _this = this;
        var typeNameText = util.getEntityNameText(node.name);
        var hasSelfReference = this.context.hasSelfReference(node);
        var hasTypeParameters = util.hasNonEmptyArrayProperty(node, 'typeParameters');
        var reflection = this.typeReflection(node.type);
        var result = reflection;
        if (hasTypeParameters) {
            var typeParameterDeclarations = node.typeParameters.map(function (typeParameter) {
                return _this.typeParameterDeclaration(typeParameter, typeNameText);
            }, true);
            result = this.selfReference(typeNameText, ts.createBlock(typeParameterDeclarations.concat([ts.createReturn(result)]), true));
        }
        else if (hasSelfReference) {
            return this.selfReference(typeNameText, result);
        }
        return this.asType(name || typeNameText, result);
    };
    Factory.prototype.typeAliasSubstitution = function (node) {
        return ts.createVariableStatement(node.modifiers, ts.createVariableDeclarationList([
            ts.createVariableDeclaration(node.name, undefined, this.typeAliasReflection(node))
        ], ts.NodeFlags.Const));
    };
    Factory.prototype.interfaceReflection = function (node, name) {
        var _this = this;
        var typeNameText = util.getEntityNameText(node.name);
        var extendsClause = util.getExtendsClause(node);
        var hasSelfReference = this.context.hasSelfReference(node);
        var hasTypeParameters = util.hasNonEmptyArrayProperty(node, 'typeParameters');
        var hasExtender = util.hasNonEmptyArrayProperty(extendsClause, 'types');
        var members = this.context.getMembers(node);
        var elementsReflection = this.elementsReflection(members);
        var reflection = this.asObject(elementsReflection);
        var result = reflection;
        if (hasExtender) {
            var intersections = extendsClause.types.map(function (expressionWithTypeArguments) {
                return _this.typeReflection(expressionWithTypeArguments);
            });
            result = this.intersect(intersections.concat([result]));
        }
        if (hasTypeParameters) {
            var typeParameterDeclarations = node.typeParameters.map(function (typeParameter) {
                return _this.typeParameterDeclaration(typeParameter, typeNameText);
            }, true);
            result = this.selfReference(typeNameText, ts.createBlock(typeParameterDeclarations.concat([ts.createReturn(result)]), true));
        }
        else if (hasSelfReference) {
            result = this.selfReference(typeNameText, result);
        }
        return this.asType(name || typeNameText, result);
    };
    Factory.prototype.interfaceSubstitution = function (node) {
        var typeNameText = util.getEntityNameText(node.name);
        var interfaceReflection = this.interfaceReflection(node);
        return ts.createVariableStatement(node.modifiers, ts.createVariableDeclarationList([
            ts.createVariableDeclaration(typeNameText, undefined, interfaceReflection)
        ], ts.NodeFlags.Const));
    };
    Factory.prototype.classReflection = function (node, name) {
        var _this = this;
        var typeNameText = util.getEntityNameText(node.name);
        var extendsClause = util.getExtendsClause(node);
        var implementsClause = util.getImplementsClause(node);
        var members = this.context.getMembers(node);
        for (var _i = 0, _a = node.members || []; _i < _a.length; _i++) {
            var member = _a[_i];
            if (util.isStatic(member)) {
                members.push(member);
            }
        }
        var hasSelfReference = this.context.hasSelfReference(node);
        var hasTypeParameters = util.hasNonEmptyArrayProperty(node, 'typeParameters');
        var hasExtender = util.hasNonEmptyArrayProperty(extendsClause, 'types');
        var hasIntersections = util.hasNonEmptyArrayProperty(implementsClause, 'types');
        var elementsReflection = this.elementsReflection(members);
        var reflection = elementsReflection;
        var result;
        var extender;
        var intersections = [];
        // Do not include interfaces in the reflection for now, as they must be implemented in the prototype chain.
        // See: https://github.com/codemix/flow-runtime/issues/127
        //
        // if (hasIntersections) {
        //   intersections = implementsClause.types.map(expressionWithTypeArguments => {
        //     return this.typeReflection(expressionWithTypeArguments);
        //   });
        // }
        //
        // if (intersections.length > 0) {
        //   // reflection = [this.propertyAccessCall(this.intersect([...intersections, this.asObject(reflection)]), 'unwrap')];
        //   // reflection = [this.intersect([...intersections, this.asObject(reflection)]) ];
        // }
        if (hasExtender) {
            extender = this.libCall('extends', extendsClause.types.map(function (expressionWithTypeArguments) {
                return _this.typeReflection(expressionWithTypeArguments);
            }));
            reflection.unshift(extender);
        }
        if (hasTypeParameters) {
            var typeParameterDeclarations = node.typeParameters.map(function (typeParameter) {
                return _this.typeParameterDeclaration(typeParameter, typeNameText);
            }, true);
            result = this.selfReference(typeNameText, ts.createBlock(typeParameterDeclarations.concat([ts.createReturn(ts.createArrayLiteral(util.asArray(reflection)))]), true));
        }
        else if (hasSelfReference) {
            result = this.selfReference(typeNameText, ts.createArrayLiteral(reflection));
        }
        var arg = !result && !reflection.length ? this.libCall('object') : result || reflection;
        result = this.asClass(name || typeNameText, arg);
        return result;
    };
    Factory.prototype.namedDeclarationsReflections = function (name, declarations, originalName) {
        var expressions = [];
        var firstDeclaration = declarations[0];
        var expression = this.namedDeclarationReflection(name, firstDeclaration, originalName);
        if (expression) {
            expressions.push(expression);
        }
        return expressions;
    };
    Factory.prototype.namedDeclarationReflection = function (name, declaration, originalName) {
        var typeName = originalName || name;
        switch (declaration.kind) {
            case ts.SyntaxKind.InterfaceDeclaration:
                return this.libCall('declare', [ts.createLiteral(name), this.interfaceReflection(declaration, typeName)]);
            case ts.SyntaxKind.ClassDeclaration:
                return this.libCall('declare', [ts.createLiteral(name), this.classReflection(declaration, typeName)]);
            case ts.SyntaxKind.TypeLiteral: // remove?
                return this.libCall('declare', [ts.createLiteral(name), this.asType(typeName, this.typeLiteralReflection(declaration))]);
            case ts.SyntaxKind.EnumDeclaration:
                return this.libCall('declare', [ts.createLiteral(name), this.asType(typeName, this.enumReflection(declaration))]);
            case ts.SyntaxKind.EnumMember: // remove?
                return this.libCall('declare', [ts.createLiteral(name), this.asType(typeName, this.enumMemberReflection(declaration))]);
            case ts.SyntaxKind.FunctionDeclaration:
                return this.libCall('declare', [ts.createLiteral(name), this.asType(typeName, this.functionReflection(declaration))]);
            case ts.SyntaxKind.VariableDeclaration:
                return this.libCall('declare', [ts.createLiteral(name), this.asVar(typeName, this.variableReflection(declaration))]);
            case ts.SyntaxKind.TypeAliasDeclaration:
                return this.libCall('declare', [ts.createLiteral(name), this.typeAliasReflection(declaration, typeName)]);
            case ts.SyntaxKind.FunctionType: // remove?
                return this.libCall('declare', [ts.createLiteral(name), this.functionTypeReflection(declaration)]);
            default:
                throw new errors_1.ProgramError("Could not reflect declaration for " + ts.SyntaxKind[declaration.kind]);
        }
    };
    Factory.prototype.enumReflection = function (node) {
        var _this = this;
        return this.libCall('enum', util.arrayFromNodeArray(node.members).map(function (member) {
            return _this.enumMemberReflection(member);
        }));
    };
    Factory.prototype.enumMemberReflection = function (node) {
        return this.libCall('enumMember', ts.createLiteral(this.context.checker.getConstantValue(node)));
    };
    Factory.prototype.variableReflection = function (node) {
        return this.typeReflection(node.type);
    };
    Factory.prototype.functionReflection = function (node, asCallProperty) {
        var _this = this;
        if (asCallProperty === void 0) { asCallProperty = false; }
        var parameters = util.arrayFromNodeArray(node.parameters);
        var args = parameters
            .filter(function (param) { return ts.isIdentifier(param.name); })
            .map(function (param) { return _this.parameterReflection(param); });
        args.push(this.returnTypeReflection(node.type));
        if (node.typeParameters && node.typeParameters.length > 0) {
            var statements = [];
            for (var _i = 0, _a = node.typeParameters; _i < _a.length; _i++) {
                var typeParameter = _a[_i];
                statements.push(this.typeParameterDeclaration(typeParameter, this.namespace + "fn"));
            }
            statements.push(ts.createReturn(ts.createArrayLiteral(args)));
            var block = ts.createBlock(statements, true);
            args = [this.selfReference(this.namespace + "fn", block)];
        }
        return this.libCall('function', args);
    };
    Factory.prototype.returnTypeReflection = function (node) {
        return this.libCall('return', this.typeReflection(node));
    };
    Factory.prototype.typeParameterReflection = function (typeParameter, prop) {
        if (prop === void 0) { prop = this.lib; }
        var args = [
            ts.createLiteral(typeParameter.name.text)
        ];
        if (typeParameter.constraint) {
            args.push(this.typeReflection(typeParameter.constraint));
        }
        if (typeParameter.default) {
            if (!typeParameter.constraint) {
                args.push(ts.createVoidZero());
            }
            args.push(this.typeReflection(typeParameter.default));
        }
        return this.propertyAccessCall(prop, 'typeParameter', args);
    };
    Factory.prototype.indexSignatureReflection = function (node) {
        return this.libCall('indexer', [
            this.declarationNameToLiteralOrExpression(node.parameters[0].name),
            this.typeReflection(node.parameters[0].type),
            this.typeReflection(node.type)
        ]);
    };
    Factory.prototype.propertySignatureReflection = function (node) {
        var args = [
            this.propertyNameToLiteralOrExpression(node.name),
            this.typeReflection(node.type)
        ];
        if (node.questionToken) {
            args.push(ts.createTrue());
        }
        return this.libCall(util.isStatic(node) ? 'staticProperty' : 'property', args);
    };
    Factory.prototype.propertyReflection = function (node) {
        return this.propertySignatureReflection(node);
    };
    Factory.prototype.callSignatureReflection = function (node) {
        return this.libCall(util.isStatic(node) ? 'staticCallProperty' : 'callProperty', this.functionReflection(node));
    };
    Factory.prototype.constructSignatureReflection = function (node) {
        return this.callSignatureReflection(node);
    };
    Factory.prototype.constructorReflection = function (node) {
        return this.libCall('property', [
            ts.createLiteral('constructor'),
            this.nullable(this.functionReflection(node))
        ]);
    };
    Factory.prototype.methodReflection = function (node) {
        return this.methodSignatureReflection(node);
    };
    Factory.prototype.methodSignatureReflection = function (node) {
        return this.libCall(util.isStatic(node) ? 'staticProperty' : 'property', [
            this.propertyNameToLiteralOrExpression(node.name),
            this.nullable(this.functionReflection(node))
        ]);
    };
    Factory.prototype.getAccessorReflection = function (node) {
        return this.methodReflection(node);
    };
    Factory.prototype.setAccessorReflection = function (node) {
        return this.methodReflection(node);
    };
    Factory.prototype.parameterReflection = function (param, reflectType) {
        if (reflectType === void 0) { reflectType = true; }
        var parameter = [
            this.declarationNameToLiteralOrExpression(param.name),
            reflectType ?
                this.typeReflection(param.type) :
                ts.createIdentifier(this.context.getTypeDeclarationName(param.name.text))
        ];
        if (param.questionToken) {
            parameter.push(ts.createTrue());
        }
        return this.libCall(param.dotDotDotToken ? 'rest' : 'param', parameter);
    };
    Factory.prototype.elementReflection = function (node) {
        switch (node.kind) {
            case ts.SyntaxKind.Constructor:
                return this.constructorReflection(node);
            case ts.SyntaxKind.ConstructSignature:
                return this.constructSignatureReflection(node);
            case ts.SyntaxKind.IndexSignature:
                return this.indexSignatureReflection(node);
            case ts.SyntaxKind.PropertyDeclaration:
                return this.propertySignatureReflection(node);
            case ts.SyntaxKind.PropertySignature:
                return this.propertyReflection(node);
            case ts.SyntaxKind.CallSignature:
                return this.callSignatureReflection(node);
            case ts.SyntaxKind.MethodSignature:
                return this.methodSignatureReflection(node);
            case ts.SyntaxKind.MethodDeclaration:
                return this.methodReflection(node);
            case ts.SyntaxKind.GetAccessor:
                return this.getAccessorReflection(node);
            case ts.SyntaxKind.SetAccessor:
                return this.setAccessorReflection(node);
            case ts.SyntaxKind.Parameter:
                return null;
            default:
                throw new errors_1.ProgramError("No type element reflection for syntax kind '" + ts.SyntaxKind[node.kind] + "' found.");
        }
    };
    Factory.prototype.elementsReflection = function (nodes, merge) {
        var _this = this;
        if (merge === void 0) { merge = true; }
        if (merge)
            return this.mergedElementsReflection(nodes);
        return nodes.map(function (node) { return _this.elementReflection(node); });
    };
    Factory.prototype.mergedElementsReflection = function (nodes) {
        var _this = this;
        var methodSignatures = new Map();
        var staticMethodSignatures = new Map();
        var callableSignatures = new Set();
        var staticCallableSignatures = new Set();
        var elements = nodes.map(function (node) {
            if (_this.context.isImplementationOfOverload(node)) {
                return null;
            }
            switch (node.kind) {
                case ts.SyntaxKind.MethodSignature:
                case ts.SyntaxKind.MethodDeclaration:
                    {
                        var id = void 0;
                        if (ts.isIdentifier(node.name)) {
                            id = node.name.text;
                        }
                        else if (ts.isStringLiteral(node.name)) {
                            id = node.name.text;
                        }
                        else if (ts.isNumericLiteral(node.name)) {
                            id = node.name.text;
                        }
                        else {
                            id = node.name.getText();
                        }
                        var collection = util.isStatic(node) ? staticMethodSignatures : methodSignatures;
                        if (!collection.has(id))
                            collection.set(id, new Set());
                        collection.get(id).add(node);
                        return null;
                    }
                case ts.SyntaxKind.CallSignature:
                    {
                        var collection = util.isStatic(node) ? staticCallableSignatures : callableSignatures;
                        collection.add(node);
                        return null;
                    }
                case ts.SyntaxKind.ConstructSignature:
                    {
                        var collection = util.isStatic(node) ? staticCallableSignatures : callableSignatures;
                        collection.add(node);
                        return null;
                    }
                default:
                    return _this.elementReflection(node);
            }
        }).filter(function (node) { return !!node; });
        var mergeSignature = function (signatures) {
            if (signatures.size === 0) {
                return null;
            }
            var returnTypes = [];
            var returnTypesSet = new Set();
            ;
            var parameterTypes = new Map();
            var parameterTypesMap = new Map();
            var minParameters = Array.from(signatures)
                .map(function (node) {
                return util.arrayFromNodeArray(node.parameters)
                    .filter(function (param) { return !param.questionToken && !param.dotDotDotToken; });
            })
                .map(function (params) {
                return params.length;
            })
                .reduce(function (a, b) {
                return Math.min(a, b);
            });
            var typeParameters = [];
            var typeParametersSet = new Set();
            var lastSignature;
            signatures.forEach(function (node) {
                lastSignature = node;
                // return type
                var typeInfo = _this.scanner.getTypeInfo(node);
                var returnTypeText = typeInfo.typeText;
                if (!returnTypesSet.has(returnTypeText)) {
                    returnTypesSet.add(returnTypeText);
                    returnTypes.push(node.type);
                }
                // type parameters
                for (var _i = 0, _a = node.typeParameters || []; _i < _a.length; _i++) {
                    var typeParameter = _a[_i];
                    var typeParameterText = typeParameter.name.text;
                    if (!typeParametersSet.has(typeParameterText)) {
                        typeParametersSet.add(typeParameterText);
                        typeParameters.push(typeParameter);
                    }
                }
                // parameters
                var parameterIndex = 0;
                for (var _b = 0, _c = node.parameters; _b < _c.length; _b++) {
                    var parameter = _c[_b];
                    var typeInfo_1 = _this.scanner.getTypeInfo(parameter);
                    var parameterTypeText = typeInfo_1.typeText;
                    if (!parameterTypesMap.has(parameterIndex)) {
                        parameterTypesMap.set(parameterIndex, new Set([parameterTypeText]));
                        parameterTypes.set(parameterIndex, [parameter.type]);
                    }
                    else {
                        var parameterTypeTexts = parameterTypesMap.get(parameterIndex);
                        if (!parameterTypeTexts.has(parameterTypeText)) {
                            parameterTypesMap.get(parameterIndex).add(parameterTypeText);
                            parameterTypes.get(parameterIndex).push(parameter.type);
                        }
                    }
                    parameterIndex++;
                }
            });
            var returnTypeNode;
            if (returnTypes.length === 1) {
                returnTypeNode = returnTypes[0];
            }
            else if (returnTypes.length > 1) {
                returnTypeNode = ts.createNode(ts.SyntaxKind.UnionType);
                returnTypeNode.types = ts.createNodeArray(returnTypes);
            }
            else {
                returnTypeNode = ts.createNode(ts.SyntaxKind.AnyKeyword);
            }
            var parameterDeclarations = [];
            parameterTypes.forEach(function (paramTypes, index) {
                var param = paramTypes[0].parent;
                var parameterTypeNode;
                if (paramTypes.length === 1) {
                    parameterTypeNode = paramTypes[0];
                }
                else if (paramTypes.length > 0) {
                    parameterTypeNode = ts.createNode(ts.SyntaxKind.UnionType);
                    parameterTypeNode.types = ts.createNodeArray(paramTypes);
                }
                else {
                    parameterTypeNode = ts.createNode(ts.SyntaxKind.AnyKeyword);
                }
                var questionToken = index + 1 > minParameters ? ts.createToken(ts.SyntaxKind.QuestionToken) : undefined;
                var parameterDeclaration = ts.createParameter(undefined, undefined, undefined, param.name, questionToken, parameterTypeNode, undefined);
                parameterDeclarations.push(parameterDeclaration);
            });
            var mergedSignature;
            switch (lastSignature.kind) {
                case ts.SyntaxKind.MethodSignature:
                    mergedSignature = ts.createMethodSignature(typeParameters, parameterDeclarations, returnTypeNode, lastSignature.name, undefined);
                    break;
                case ts.SyntaxKind.MethodDeclaration:
                    mergedSignature = ts.createMethod(undefined, lastSignature.modifiers, lastSignature.asteriskToken, lastSignature.name, undefined, typeParameters, parameterDeclarations, returnTypeNode, undefined);
                    break;
                case ts.SyntaxKind.CallSignature:
                case ts.SyntaxKind.ConstructSignature:
                    mergedSignature = ts.createCallSignature(typeParameters, parameterDeclarations, returnTypeNode);
                    break;
                default:
                    throw new errors_1.ProgramError("Could not merge " + ts.SyntaxKind[lastSignature.kind] + ".");
            }
            return _this.elementReflection(mergedSignature);
        };
        elements.push(mergeSignature(callableSignatures));
        elements.push(mergeSignature(staticCallableSignatures));
        methodSignatures.forEach(function (signatures) {
            elements.push(mergeSignature(signatures));
        });
        staticMethodSignatures.forEach(function (signatures) {
            elements.push(mergeSignature(signatures));
        });
        return elements.filter(function (element) { return !!element; });
    };
    Factory.prototype.classTypeParameterSymbolDeclaration = function (name) {
        return ts.createVariableDeclarationList([ts.createVariableDeclaration(this.context.getTypeSymbolDeclarationName(name), undefined, ts.createCall(ts.createIdentifier('Symbol'), undefined, [ts.createLiteral(this.context.getTypeSymbolDeclarationInitializer(name))]))], ts.NodeFlags.Const);
    };
    Factory.prototype.classTypeParameterSymbolConstructorDeclaration = function (name) {
        return ts.createStatement(ts.createBinary(ts.createElementAccess(ts.createThis(), ts.createIdentifier(this.context.getTypeSymbolDeclarationName(name))), ts.SyntaxKind.EqualsToken, ts.createIdentifier(this.context.getTypeParametersDeclarationName())));
    };
    Factory.prototype.classTypeParameterSymbolPropertyDeclaration = function (name) {
        return ts.createProperty(undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], ts.createComputedPropertyName(ts.createPropertyAccess(ts.createIdentifier(this.context.getLibDeclarationName()), ts.createIdentifier('TypeParametersSymbol'))), undefined, undefined, ts.createIdentifier(this.context.getTypeSymbolDeclarationName(name)));
    };
    Factory.prototype.typeParameterDeclaration = function (typeParameter, prop) {
        if (prop === void 0) { prop = this.lib; }
        var callExpression = this.typeParameterReflection(typeParameter, prop);
        return ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(typeParameter.name.text, undefined, callExpression)], ts.NodeFlags.Const));
    };
    Factory.prototype.typeParametersLiteral = function (typeParameters, asStatement) {
        var _this = this;
        if (asStatement === void 0) { asStatement = false; }
        return ts.createObjectLiteral(typeParameters.map(function (param) {
            return ts.createPropertyAssignment(param.name, _this.typeParameterReflection(param));
        }), true);
    };
    Factory.prototype.typeParametersLiteralDeclaration = function (typeParameters) {
        return ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
            ts.createVariableDeclaration(this.context.getTypeParametersDeclarationName(), undefined, this.typeParametersLiteral(typeParameters))
        ], ts.NodeFlags.Const));
    };
    Factory.prototype.typeParameterBindingDeclaration = function (typeArguments) {
        // this.setGlobalFlags(FactoryFlags.NoFlowInto);
        var _this = this;
        return ts.createStatement(ts.createCall(ts.createPropertyAccess(ts.createIdentifier(this.context.getLibDeclarationName()), ts.createIdentifier('bindTypeParameters')), undefined, [
            ts.createThis()
        ].concat(typeArguments.map(function (arg) { return _this.typeReflection(arg); }))));
    };
    Factory.prototype.assertReturnStatements = function (node, type) {
        var _this = this;
        var visitor = function (node) {
            if (type && util.isAnyKeyword(type)) {
                return node;
            }
            if (node.type && util.isAnyKeyword(node.type)) {
                return node;
            }
            if (util.isKind(node, ts.SyntaxKind.FunctionDeclaration, ts.SyntaxKind.FunctionExpression, ts.SyntaxKind.ArrowFunction)) {
                return node;
            }
            if (ts.isReturnStatement(node)) {
                // if (this.context.isSafeAssignment(type, node.expression)) {
                //   return node;
                // }
                var assertion = _this.typeAssertion(_this.context.getTypeDeclarationName('return'), node.expression);
                return ts.updateReturn(node, assertion);
            }
            return ts.visitEachChild(node, visitor, _this.context.transformationContext);
        };
        return ts.visitEachChild(node, visitor, this.context.transformationContext);
    };
    Factory.prototype.mutateFunctionBody = function (n) {
        var node = n;
        if (!node.body) {
            return node;
        }
        if (ts.isArrowFunction(node) && !ts.isBlock(node.body)) {
            var body_1 = ts.createBlock([ts.createReturn(node.body)], true);
            node = ts.updateArrowFunction(node, node.modifiers, node.typeParameters, node.parameters, node.type, node.equalsGreaterThanToken, body_1);
        }
        var bodyDeclarations = [];
        var bodyAssertions = [];
        if (node.typeParameters && node.typeParameters.length > 0) {
            for (var _i = 0, _a = node.typeParameters; _i < _a.length; _i++) {
                var typeParameter = _a[_i];
                bodyDeclarations.push(this.typeParameterDeclaration(typeParameter));
            }
        }
        for (var _b = 0, _c = node.parameters; _b < _c.length; _b++) {
            var param = _c[_b];
            if (util.isAnyKeyword(param.type)) {
                continue;
            }
            if (!ts.isIdentifier(param.name)) {
                continue;
            }
            var paramNameDeclaration = this.context.getTypeDeclarationName(param.name.text);
            bodyDeclarations.push(ts.createVariableStatement([], ts.createVariableDeclarationList([
                ts.createVariableDeclaration(paramNameDeclaration, undefined, this.typeReflection(param.type))
            ], ts.NodeFlags.Let)));
            bodyAssertions.push(ts.createStatement(this.typeAssertion(this.parameterReflection(param, false), ts.createIdentifier(param.name.text))));
        }
        if (node.type && !util.isAnyKeyword(node.type)) {
            bodyDeclarations.push(ts.createVariableStatement([], ts.createVariableDeclarationList([
                ts.createVariableDeclaration(this.context.getReturnTypeDeclarationName(), undefined, this.returnTypeReflection(node.type))
            ], ts.NodeFlags.Const)));
        }
        var body = ts.updateBlock(node.body, this.assertReturnStatements(node.body, node.type).statements);
        var bodyStatements = (body && util.arrayFromNodeArray(body.statements)) || [];
        bodyStatements.unshift.apply(bodyStatements, bodyAssertions);
        bodyStatements.unshift.apply(bodyStatements, bodyDeclarations);
        body = ts.updateBlock(body, bodyStatements);
        var method;
        switch (node.kind) {
            case ts.SyntaxKind.Constructor:
                method = ts.updateConstructor(node, node.decorators, node.modifiers, node.parameters, body);
                break;
            case ts.SyntaxKind.MethodDeclaration:
                method = ts.updateMethod(node, node.decorators, node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, body);
                break;
            case ts.SyntaxKind.GetAccessor:
                method = ts.updateGetAccessor(node, node.decorators, node.modifiers, node.name, node.parameters, node.type, body);
                break;
            case ts.SyntaxKind.SetAccessor:
                method = ts.updateSetAccessor(node, node.decorators, node.modifiers, node.name, node.parameters, body);
                break;
            case ts.SyntaxKind.FunctionExpression:
                method = ts.updateFunctionExpression(node, node.modifiers, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, body);
                break;
            case ts.SyntaxKind.FunctionDeclaration:
                method = ts.updateFunctionDeclaration(node, node.decorators, node.modifiers, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, body);
                break;
            case ts.SyntaxKind.ArrowFunction:
                method = ts.updateArrowFunction(node, node.modifiers, node.typeParameters, node.parameters, node.type, node.equalsGreaterThanToken, body);
                break;
        }
        return method;
    };
    Factory.prototype.propertyNameToLiteralOrExpression = function (node) {
        switch (node.kind) {
            case ts.SyntaxKind.Identifier:
                return ts.createLiteral(node.text);
            case ts.SyntaxKind.StringLiteral:
                var str = node.text;
                return ts.createLiteral(str.substring(1, str.length - 1));
            case ts.SyntaxKind.NumericLiteral:
                return ts.createNumericLiteral(node.text);
            case ts.SyntaxKind.ComputedPropertyName:
                return node.expression;
            default:
                throw new errors_1.ProgramError("Property name for syntax kind '" + ts.SyntaxKind[node.kind] + "' could not be generated.");
        }
    };
    Factory.prototype.declarationNameToLiteralOrExpression = function (node) {
        switch (node.kind) {
            case ts.SyntaxKind.Identifier:
            case ts.SyntaxKind.StringLiteral:
            case ts.SyntaxKind.NumericLiteral:
            case ts.SyntaxKind.ComputedPropertyName:
                return this.propertyNameToLiteralOrExpression(node);
            case ts.SyntaxKind.ObjectBindingPattern:
            case ts.SyntaxKind.ArrayBindingPattern:
            default:
                throw new errors_1.ProgramError("Declaration name for syntax kind '" + ts.SyntaxKind[node.kind] + "' could not be generated.");
        }
    };
    Factory.prototype.importLibStatement = function () {
        return ts.createImportDeclaration(undefined, undefined, ts.createImportClause(ts.createIdentifier(this.context.factory.lib), undefined), ts.createLiteral(this.context.factory.package));
    };
    Factory.prototype.importDeclarationsStatement = function () {
        return ts.createImportDeclaration(undefined, undefined, undefined, ts.createLiteral("./" + this.context.options.declarationFileName));
    };
    Factory.prototype.decorate = function (expressions) {
        return this.libCall('decorate', expressions);
    };
    Factory.prototype.annotate = function (expressions) {
        return this.libCall('annotate', expressions);
    };
    Factory.prototype.nullable = function (reflection) {
        return this.strictNullChecks ? reflection : this.libCall('nullable', reflection);
    };
    Factory.prototype.nostrict = function (reflection) {
        return this.strictNullChecks ? reflection : this.libCall('nullable', reflection);
    };
    Factory.prototype.intersect = function (args) {
        return this.libCall('intersect', args);
    };
    Factory.prototype.flowInto = function (args) {
        return this.libCall('flowInto', args);
    };
    Factory.prototype.tdz = function (body, name) {
        var args = [
            ts.createArrowFunction(undefined, undefined, [], undefined, ts.createToken(ts.SyntaxKind.EqualsGreaterThanToken), body),
            ts.createLiteral(body)
        ];
        if (name) {
            args.push(ts.createLiteral(name));
        }
        return this.libCall('tdz', args);
    };
    Factory.prototype.selfReference = function (name, body) {
        return ts.createArrowFunction(undefined, undefined, [ts.createParameter(undefined, undefined, undefined, name)], undefined, ts.createToken(ts.SyntaxKind.EqualsGreaterThanToken), body);
    };
    Factory.prototype.asObject = function (nodes) {
        return this.libCall('object', nodes);
    };
    Factory.prototype.asRef = function (arg) {
        return this.libCall('ref', arg);
    };
    Factory.prototype.asType = function (name, args, keyword) {
        if (keyword === void 0) { keyword = 'type'; }
        args = util.asArray(args);
        args.unshift(ts.createLiteral(name));
        return this.libCall(keyword, args);
    };
    Factory.prototype.asClass = function (name, args) {
        return this.asType(name, args, 'class');
    };
    Factory.prototype.asVar = function (name, expression) {
        return this.libCall('var', [ts.createLiteral(name), expression]);
    };
    Factory.prototype.asStatement = function (expression) {
        return ts.createStatement(expression);
    };
    Factory.prototype.libCall = function (prop, args) {
        if (args === void 0) { args = []; }
        return this.propertyAccessCall(this.lib, prop, args);
    };
    Factory.prototype.propertyAccessCall = function (id, prop, args) {
        if (args === void 0) { args = []; }
        id = typeof id === 'string' ? ts.createIdentifier(id) : id;
        args = util.asArray(args);
        return ts.createCall(ts.createPropertyAccess(id, prop), [], args);
    };
    Factory.prototype.addState = function (state) {
        if (state === undefined)
            return;
        var counter = this._state.get(state) || 0;
        this._state.set(state, ++counter);
    };
    Factory.prototype.removeState = function (state) {
        if (state === undefined)
            return;
        var counter = this._state.get(state) || 1;
        if (counter < 0)
            counter = 0;
        this._state.set(state, --counter);
        if (counter === 0)
            this._state.delete(state);
    };
    Factory.prototype.state = function (state) {
        return this._state.has(state);
    };
    Factory.prototype.rule = function (rule) {
        for (var _i = 0, rule_1 = rule; _i < rule_1.length; _i++) {
            var state = rule_1[_i];
            if (this.state(state)) {
                return true;
            }
        }
        return false;
    };
    Factory.prototype.match = function (rule, state) {
        return rule.indexOf(state) !== -1;
    };
    Object.defineProperty(Factory.prototype, "scanner", {
        get: function () {
            return this.context.scanner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Factory.prototype, "context", {
        get: function () {
            return this._context;
        },
        set: function (context) {
            this._context = context;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Factory.prototype, "strictNullChecks", {
        get: function () {
            return this._strictNullChecks;
        },
        set: function (strictNullChecks) {
            this._strictNullChecks = strictNullChecks;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Factory.prototype, "lib", {
        get: function () {
            return this.context.getIdentifier("" + this.namespace + this._lib);
        },
        set: function (lib) {
            this._lib = lib;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Factory.prototype, "package", {
        get: function () {
            return this._load;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Factory.prototype, "namespace", {
        get: function () {
            return this._namespace;
        },
        set: function (namespace) {
            this._namespace = namespace;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Factory.prototype, "warnings", {
        get: function () {
            return this._warnings;
        },
        enumerable: true,
        configurable: true
    });
    return Factory;
}());
exports.Factory = Factory;
var FactoryState;
(function (FactoryState) {
    FactoryState[FactoryState["None"] = 0] = "None";
    FactoryState[FactoryState["TypeDeclaration"] = 1] = "TypeDeclaration";
    FactoryState[FactoryState["TypeAssertion"] = 2] = "TypeAssertion";
    FactoryState[FactoryState["TypeDeclarationAndAssertion"] = 3] = "TypeDeclarationAndAssertion";
    FactoryState[FactoryState["AnyTypeReflection"] = 4] = "AnyTypeReflection";
    FactoryState[FactoryState["NumberTypeReflection"] = 5] = "NumberTypeReflection";
    FactoryState[FactoryState["BooleanTypeReflection"] = 6] = "BooleanTypeReflection";
    FactoryState[FactoryState["StringTypeReflection"] = 7] = "StringTypeReflection";
    FactoryState[FactoryState["SymbolTypeReflection"] = 8] = "SymbolTypeReflection";
    FactoryState[FactoryState["ObjectTypeReflection"] = 9] = "ObjectTypeReflection";
    FactoryState[FactoryState["VoidTypeReflection"] = 10] = "VoidTypeReflection";
    FactoryState[FactoryState["NullTypeReflection"] = 11] = "NullTypeReflection";
    FactoryState[FactoryState["UndefinedTypeReflection"] = 12] = "UndefinedTypeReflection";
    FactoryState[FactoryState["ThisTypeReflection"] = 13] = "ThisTypeReflection";
    FactoryState[FactoryState["LiteralTypeReflection"] = 14] = "LiteralTypeReflection";
    FactoryState[FactoryState["BooleanLiteralTypeReflection"] = 15] = "BooleanLiteralTypeReflection";
    FactoryState[FactoryState["NumericLiteralTypeReflection"] = 16] = "NumericLiteralTypeReflection";
    FactoryState[FactoryState["StringLiteralTypeReflection"] = 17] = "StringLiteralTypeReflection";
    FactoryState[FactoryState["ArrayTypeReflection"] = 18] = "ArrayTypeReflection";
    FactoryState[FactoryState["TupleTypeReflection"] = 19] = "TupleTypeReflection";
    FactoryState[FactoryState["UnionTypeReflection"] = 20] = "UnionTypeReflection";
    FactoryState[FactoryState["IntersectionTypeReflection"] = 21] = "IntersectionTypeReflection";
    FactoryState[FactoryState["TypeReferenceReflection"] = 22] = "TypeReferenceReflection";
    FactoryState[FactoryState["FunctionTypeReflection"] = 23] = "FunctionTypeReflection";
    FactoryState[FactoryState["ConstructorTypeReflection"] = 24] = "ConstructorTypeReflection";
    FactoryState[FactoryState["TypeQueryReflection"] = 25] = "TypeQueryReflection";
    FactoryState[FactoryState["TypeLiteralReflection"] = 26] = "TypeLiteralReflection";
    FactoryState[FactoryState["ExpressionWithTypeArgumentsReflection"] = 27] = "ExpressionWithTypeArgumentsReflection";
    FactoryState[FactoryState["TypeAliasReflection"] = 28] = "TypeAliasReflection";
    FactoryState[FactoryState["TypeAliasSubstitution"] = 29] = "TypeAliasSubstitution";
    FactoryState[FactoryState["InterfaceReflection"] = 30] = "InterfaceReflection";
    FactoryState[FactoryState["InterfaceSubstitution"] = 31] = "InterfaceSubstitution";
    FactoryState[FactoryState["ClassReflection"] = 32] = "ClassReflection";
    FactoryState[FactoryState["NamedDeclarationReflection"] = 33] = "NamedDeclarationReflection";
    FactoryState[FactoryState["NamedDeclarationsReflections"] = 34] = "NamedDeclarationsReflections";
    FactoryState[FactoryState["EnumReflection"] = 35] = "EnumReflection";
    FactoryState[FactoryState["EnumMemberReflection"] = 36] = "EnumMemberReflection";
    FactoryState[FactoryState["VariableReflection"] = 37] = "VariableReflection";
    FactoryState[FactoryState["FunctionReflection"] = 38] = "FunctionReflection";
    FactoryState[FactoryState["MethodSignatureReflection"] = 39] = "MethodSignatureReflection";
    FactoryState[FactoryState["MethodReflection"] = 40] = "MethodReflection";
    FactoryState[FactoryState["GetAccessorReflection"] = 41] = "GetAccessorReflection";
    FactoryState[FactoryState["SetAccessorReflection"] = 42] = "SetAccessorReflection";
    FactoryState[FactoryState["ConstructorReflection"] = 43] = "ConstructorReflection";
    FactoryState[FactoryState["ParameterReflection"] = 44] = "ParameterReflection";
    FactoryState[FactoryState["ReturnTypeReflection"] = 45] = "ReturnTypeReflection";
    FactoryState[FactoryState["TypeParameterReflection"] = 46] = "TypeParameterReflection";
    FactoryState[FactoryState["ElementReflection"] = 47] = "ElementReflection";
    FactoryState[FactoryState["ElementsReflection"] = 48] = "ElementsReflection";
    FactoryState[FactoryState["MergedElementsReflection"] = 49] = "MergedElementsReflection";
    FactoryState[FactoryState["IndexSignatureReflection"] = 50] = "IndexSignatureReflection";
    FactoryState[FactoryState["PropertySignatureReflection"] = 51] = "PropertySignatureReflection";
    FactoryState[FactoryState["PropertyReflection"] = 52] = "PropertyReflection";
    FactoryState[FactoryState["CallSignatureReflection"] = 53] = "CallSignatureReflection";
    FactoryState[FactoryState["ConstructSignatureReflection"] = 54] = "ConstructSignatureReflection";
    FactoryState[FactoryState["ClassTypeParameterSymbolDeclaration"] = 55] = "ClassTypeParameterSymbolDeclaration";
    FactoryState[FactoryState["ClassTypeParameterSymbolConstructorDeclaration"] = 56] = "ClassTypeParameterSymbolConstructorDeclaration";
    FactoryState[FactoryState["ClassTypeParameterSymbolPropertyDeclaration"] = 57] = "ClassTypeParameterSymbolPropertyDeclaration";
    FactoryState[FactoryState["TypeParameterDeclaration"] = 58] = "TypeParameterDeclaration";
    FactoryState[FactoryState["TypeParametersLiteral"] = 59] = "TypeParametersLiteral";
    FactoryState[FactoryState["TypeParametersLiteralDeclaration"] = 60] = "TypeParametersLiteralDeclaration";
    FactoryState[FactoryState["TypeParameterBindingDeclaration"] = 61] = "TypeParameterBindingDeclaration";
    FactoryState[FactoryState["AssertReturnStatements"] = 62] = "AssertReturnStatements";
    FactoryState[FactoryState["MutateFunctionBody"] = 63] = "MutateFunctionBody";
    FactoryState[FactoryState["ImportLibStatement"] = 64] = "ImportLibStatement";
    FactoryState[FactoryState["ImportDeclarationsStatement"] = 65] = "ImportDeclarationsStatement";
    FactoryState[FactoryState["Decorate"] = 66] = "Decorate";
    FactoryState[FactoryState["Annotate"] = 67] = "Annotate";
    FactoryState[FactoryState["Nullable"] = 68] = "Nullable";
    FactoryState[FactoryState["NoStrict"] = 69] = "NoStrict";
    FactoryState[FactoryState["Intersect"] = 70] = "Intersect";
    FactoryState[FactoryState["FlowInto"] = 71] = "FlowInto";
    FactoryState[FactoryState["Tdz"] = 72] = "Tdz";
    FactoryState[FactoryState["SelfReference"] = 73] = "SelfReference";
    FactoryState[FactoryState["AsObject"] = 74] = "AsObject";
    FactoryState[FactoryState["AsRef"] = 75] = "AsRef";
    FactoryState[FactoryState["AsType"] = 76] = "AsType";
    FactoryState[FactoryState["AsClass"] = 77] = "AsClass";
    FactoryState[FactoryState["AsVar"] = 78] = "AsVar";
    FactoryState[FactoryState["AsStatement"] = 79] = "AsStatement";
})(FactoryState = exports.FactoryState || (exports.FactoryState = {}));
exports.FactoryRule = {
    NoClassTypeParameterReflection: [
        FactoryState.ClassReflection,
        FactoryState.NamedDeclarationReflection
    ],
    NoFlowInto: [
        FactoryState.ReturnTypeReflection,
        FactoryState.ExpressionWithTypeArgumentsReflection,
        FactoryState.TypeParameterBindingDeclaration,
        FactoryState.InterfaceReflection,
        FactoryState.TypeAliasReflection
    ],
    Nullable: [
        FactoryState.NumberTypeReflection,
        FactoryState.BooleanTypeReflection,
        FactoryState.StringTypeReflection,
        FactoryState.SymbolTypeReflection,
        FactoryState.ObjectTypeReflection,
        FactoryState.UndefinedTypeReflection,
        FactoryState.ThisTypeReflection,
        FactoryState.LiteralTypeReflection,
        FactoryState.ArrayTypeReflection,
        FactoryState.TupleTypeReflection,
        FactoryState.UnionTypeReflection,
        FactoryState.IntersectionTypeReflection,
        FactoryState.TypeReferenceReflection,
        FactoryState.FunctionTypeReflection,
        FactoryState.ConstructorTypeReflection
    ],
    Property: [
        FactoryState.PropertySignatureReflection,
        FactoryState.MethodSignatureReflection,
        FactoryState.ConstructorReflection
    ]
};
