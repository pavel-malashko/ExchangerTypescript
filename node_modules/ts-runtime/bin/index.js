#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var ts = require("typescript");
var commander = require("commander");
var util = require("./util");
var program = require("./program");
var transform_1 = require("../transform");
var errors_1 = require("../errors");
var options_1 = require("../options");
var pkgDir = ts.sys.fileExists(path.join(__dirname, '../package.json')) ?
    path.join(__dirname, '../package.json') : path.join(__dirname, '../../package.json');
var pkg = require(pkgDir);
var options = Object.assign({}, options_1.defaultOptions);
var compilerOptions = '{}';
var parsedCompilerOptions;
var tsConfigPath;
var fastMode = false;
function defaultAction() {
    if (fastMode) {
        options.log = true;
    }
    else {
        program.start(options, pkg.version);
        options.log = false;
    }
    var files = commander.args
        .filter(function (arg) { return typeof arg === 'string'; });
    if (files.length === 0) {
        throw new errors_1.ProgramError('No entry file(s) passed to transform.');
    }
    try {
        parsedCompilerOptions = JSON.parse(compilerOptions);
    }
    catch (e) {
        throw new errors_1.ProgramError("Could not parse compiler configuration.");
    }
    if (tsConfigPath) {
        if (!ts.sys.fileExists(tsConfigPath)) {
            throw new errors_1.ProgramError("Could not load configuration from " + tsConfigPath + ".");
        }
        var resolvedTsConfigPath = path.resolve(tsConfigPath);
        var tsConfig = require(resolvedTsConfigPath);
        if (tsConfig.hasOwnProperty('compilerOptions')) {
            parsedCompilerOptions = tsConfig.compilerOptions;
        }
        else {
            if (options.log) {
                console.warn("No compiler options found in " + tsConfigPath + ", used defaults.");
            }
            else {
                program.status.warn("No compiler options found in " + tsConfigPath + ", used defaults.");
            }
            parsedCompilerOptions = {};
        }
    }
    var opts = ts.convertCompilerOptionsFromJson(parsedCompilerOptions, '.');
    options.compilerOptions = opts.options;
    if (opts.errors.length > 0) {
        var formattedDiagnostics = util.formatDiagnostics(opts.errors);
        if (options.log) {
            for (var _i = 0, formattedDiagnostics_1 = formattedDiagnostics; _i < formattedDiagnostics_1.length; _i++) {
                var diagnostic = formattedDiagnostics_1[_i];
                console.error(diagnostic);
            }
            process.exit(1);
        }
        program.status.diagnostics(util.formatDiagnostics(opts.errors));
        program.status.error();
        return;
    }
    if (fastMode) {
        transform_1.transform(files, options);
    }
    else {
        program.transform(files);
    }
}
function useTsConfig(path) {
    tsConfigPath = path;
}
function setNoAnnotate() {
    options.noAnnotate = true;
}
function setCompilerOptions(opts) {
    compilerOptions = opts;
}
function setDeclarationFileName(fileName) {
    var ext = path.extname(fileName);
    if (ext) {
        fileName = fileName.slice(0, ext.length * -1);
    }
    if (path.basename(fileName) !== fileName) {
        throw new errors_1.ProgramError('Declaration file name must not be a path.');
    }
    options.declarationFileName = fileName;
}
function setExcludeDeclarationFile() {
    options.excludeDeclarationFile = true;
}
function setExcludeLib() {
    options.excludeLib = true;
}
function setForce() {
    options.force = true;
}
function setFast() {
    fastMode = true;
}
// function setKeepTemp() {
//   options.keepTemp = true;
// }
function setLibIdentifier(identifier) {
    options.libIdentifier = identifier;
}
function setLibDeclarations() {
    options.libDeclarations = true;
}
function setLibNamespace(namespace) {
    options.libNamespace = namespace;
}
function setModuleAlias() {
    options.moduleAlias = true;
}
function setDeclarationPrefix(prefix) {
    options.declarationPrefix = prefix;
}
function setStackTraceOutput(limit) {
    options.stackTraceOutput = parseInt(limit);
}
// function setTempFolderName(name: string) {
//   options.tempFolderName = name;
// }
commander
    .version(pkg.version, '-v, --version')
    .description("---------  ts-runtime  ---------\n  Turn TypeScript type annotations\n  --> into runtime type checks <--\n  --------------------------------")
    .usage('<file...> [options]')
    .option('-a, --noAnnotate', 'do not annotate classes and functions', setNoAnnotate)
    .option('-c, --tsConfig <path>', 'use the compiler options of the given tsconfig.json', useTsConfig)
    .option('-C, --compilerOptions <compilerOptions>', 'set TypeScript compiler options. defaults to "{}"', setCompilerOptions)
    .option('-d, --declarationFileName <fileName>', 'set file name for global declarations. defaults to "tsr-declarations"', setDeclarationFileName)
    .option('-e, --excludeDeclarationFile', 'do not import the ambient declarations file. defaults to false', setExcludeDeclarationFile)
    .option('-E, --excludeLib', 'do not automatically import the runtime library. defaults to false', setExcludeLib)
    .option('-f, --force', 'try to finish on TypeScript compiler error. defaults to false', setForce)
    .option('-F, --fast', 'no status for the command line, but faster processing. defaults to false', setFast)
    // .option('-k, --keepTemp', 'keep temporary files. defaults to false', setKeepTemp)
    .option('-l, --libIdentifier <name>', 'lib import name. defaults to "t"', setLibIdentifier)
    .option('-L, --libDeclarations', 'reflect declarations from global libs (e.g. DOM). defaults to false', setLibDeclarations)
    .option('-m, --moduleAlias', 'import package module-alias on top of every file.', setModuleAlias)
    .option('-n, --libNamespace <namespace>', 'prefix for lib and code additions. defaults to ""', setLibNamespace)
    .option('-p, --declarationPrefix <namespace>', 'prefix for added variables. defaults to "_"', setDeclarationPrefix)
    .option('-s, --stackTraceOutput <limit>', 'output a specified number of lines of the stack trace. defaults to 3', setStackTraceOutput)
    // .option('-t, --tempFolderName <name>', 'set folder name for temporary files. defaults to ".tsr"', setTempFolderName)
    .on('--help', function () {
    console.log();
    console.log('  Examples:');
    console.log();
    console.log('    $ tsr entry.ts --force');
    console.log('    $ tsr src/entry1 bin/entry2 lib/entry3');
    console.log('    $ tsr entry.ts -c tsconfig.json');
    console.log();
});
commander.parse(process.argv);
if (!process.argv.slice(2).length) {
    commander.outputHelp();
    process.exit();
}
else {
    defaultAction();
}
